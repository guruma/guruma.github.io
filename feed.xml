<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://guruma.github.io/' rel='self' type='application/rss+xml'/>
<title>
Computat ergo est
</title>
<link>
http://guruma.github.io/
</link>
<description>
guruma's Blog
</description>
<lastBuildDate>
Sun, 21 Apr 2019 23:34:25 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://guruma.github.io/posts/2018-11-18-Continuation-Concept/
</guid>
<link>
http://guruma.github.io/posts/2018-11-18-Continuation-Concept/
</link>
<title>
후속문(Continuation) : 제1부. 개념과 call/cc
</title>
<description>
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;차례&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문_개념잡기&quot;&gt;1. 후속문 개념잡기&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_암묵적_후속문&quot;&gt;1.1. 암묵적 후속문&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문의_실체화_reification_of_continuation&quot;&gt;1.2. 후속문의 실체화(Reification of Continuation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_일급_후속문_first_class_continuation&quot;&gt;1.3. 일급 후속문(First-Class Continuation)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문_프로그래밍&quot;&gt;2. 후속문 프로그래밍&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_call_cc&quot;&gt;2.1. call/cc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_v_표기법&quot;&gt;2.2. v 표기법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_call_cc_적용하기&quot;&gt;2.3. call/cc 적용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_탈출_escape&quot;&gt;2.4. 탈출(escape)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_return문_구현하기&quot;&gt;2.5. return문 구현하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문_함수_저장하기&quot;&gt;2.6. 후속문 함수 저장하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문_이디엄&quot;&gt;2.7. 후속문 이디엄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_v_인자_대입법&quot;&gt;2.8. v 인자 대입법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_후속문_함수의_호출은_인자가_딸린_goto&quot;&gt;2.9. 후속문 함수의 호출은 인자가 딸린 GOTO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_음양&quot;&gt;2.10. 음양&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_비결정적_선택_nondeterministic_choice&quot;&gt;2.11. 비결정적 선택(Nondeterministic Choice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_코루틴&quot;&gt;2.12. 코루틴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_1부를_마치면서&quot;&gt;3. 1부를 마치면서&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_2부_예고&quot;&gt;3.1. 2부 예고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
table#gromit td.valign-bottom { background: #f9f9f9; padding-bottom: 0px}
table#gromit td.valign-bottom p { margin-bottom: 0px}
table#gromit td.valign-top { background: #f9f9f9; padding-top: 0px}
table#gromit td.valign-top .imageblock { margin-bottom: 5px}
table#gromit tr:nth-child(3) p { line-height: 1.2; }

.cont1 { background-color: #c1aef9; }
.cont2 { background-color: #c0efc4; }
&lt;/style&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 글은 &lt;a href=&quot;http://guruma.github.io/posts/2018-09-27-Project-Loom-Fiber-And-Continuation/&quot;&gt;Loom Project&lt;/a&gt;를 소개하면서 다루기로 하고 미루었던 후속문(Continuation)에 대한 글이다. 최근에 동시성 프로그래밍의 복잡성을 해결하는 방법으로 코루틴이나 파이버와 같은 경량 스레드에 대한 요구가 증가하고 있다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_1&quot; class=&quot;footnote&quot; href=&quot;#_footnote_1&quot; title=&quot;View footnote.&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt; 그에 따라 이런 경량 스레드를 구현하는데 사용되는 후속문에 대한 이해가 중요해졌다. 하지만 아직 후속문에 대한 한글 자료가 많지 않은데, 이 글이 도움이 되길 바란다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_후속문_개념잡기&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문_개념잡기&quot;&gt;&lt;/a&gt;1. 후속문 개념잡기&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문(Continuation)은 프로그램 제어에 관한 추상화 개념이다. 모든 프로그램은 후속문 관점으로 볼 수 있다. if 문은 2가지 후속문 중 선택이며, 예외(Exception)는 후속문을 버리는 것이고, for 문은 후속문의 반복이다. 모든 언어는 후속문을 암묵적으로 사용하고 있지만, 후속문을 일급 객체(First Class)로서 명시적으로 지원하는 언어들은 Lisp나 ML 계열의 일부 비주류 언어들뿐이었다. 하지만 최근에는 Python(&lt;a href=&quot;http://www.stackless.com/spcpaper.htm&quot;&gt;Stackless Python&lt;/a&gt;), Ruby(&lt;a href=&quot;http://ruby-doc.org/core-2.1.1/Continuation.html&quot;&gt;Continuation&lt;/a&gt;)뿐만 아니라, C++(&lt;a href=&quot;https://www.boost.org/doc/libs/1_65_0/libs/context/doc/html/context/cc/class__continuation_.html&quot;&gt;boost.context.continuation&lt;/a&gt;)이나 Java(&lt;a href=&quot;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&quot;&gt;Loom Project&lt;/a&gt;), Javascript(&lt;a href=&quot;https://wiki.apache.org/cocoon/RhinoWithContinuations&quot;&gt;rhino&lt;/a&gt;) 등 주류 언어들에서도 후속문을 지원하거나 지원 예정에 있다. 이 글에서는 후속문의 개념에 관해 설명한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sidebarblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;번역 용어의 선정&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;한국어로 아직은 프로그래밍 용어로서의 'Continuation&amp;#8217;에 대한 번역 용어가 없다. 일본어로는 '계속(継続)', 중국어로는 '계산속체(计算续体)'이라고 번역하고 있다. 일본어 번역은 직역이고, 중국어 번역은 그나마 좀 의미를 제대로 담고는 있으나 그 의미가 금방 와닿지 않는다. 둘 다 Continuation의 개념을 파악하는데 별로 도움이 되지 않는다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;영어에서 'Continuation&amp;#8217;이라는 단어는 일상 언어에서 크게 2가지 의미가 있다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_2&quot; class=&quot;footnote&quot; href=&quot;#_footnote_2&quot; title=&quot;View footnote.&quot;&gt;2&lt;/a&gt;]&lt;/sup&gt; 하나는 '계속&amp;#8217;이나 '연속&amp;#8217;이라는 추상적 의미로서의 '상태&amp;#8217;를 나타낸다. 이에 대한 Merriam-Webster 사전에서의 정의는 다음과 같다: 'the act or fact of continuing in or the prolongation of a state or activity'. 다른 하나는 앞의 의미에서 파생된 의미로서 '계속&amp;#8217;이나 '연속&amp;#8217;이라는 상태를 담지한 구체적인 물체나 대상을 의미한다. 이에 대한 Merriam-Webster 사전에서의 정의는 다음과 같다: 'something that continues, increases, or adds'&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;반면 한국어에서 '계속/연속&amp;#8217;은 추상적 상태만을 나타낸다. 국립국어원의 표준국어대사전&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_3&quot; class=&quot;footnote&quot; href=&quot;#_footnote_3&quot; title=&quot;View footnote.&quot;&gt;3&lt;/a&gt;]&lt;/sup&gt;에서 '계속&amp;#8217;은 '끊이지 않고 이어 나감', '끊어졌던 행위나 상태를 다시 이어 나감&amp;#8217;으로 설명되고 있으며, '연속&amp;#8217;은 '끊이지 아니하고 죽 이어지거나 지속함&amp;#8217;으로 설명되고 있다. 한국어에서는 '계속/연속&amp;#8217;이라는 단어가 영어에서처럼 '계속/연속&amp;#8217;이라는 상태를 담지한 물건이나 대상을 지칭하는 데 사용되지 않는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이처럼 영어에서는 'Continuation&amp;#8217;이라는 단어가 대상이나 물체를 나타낼 수 있어서 'Continuation follows', 'continuation of a line', 'Continuation to a building' 등은 자연스러운 표현이다. 실제로 이들은 한국말로 이야기의 '속편', 줄의 '연장', 건물의 '증축&amp;#8217;으로 번역되고 있다. 이때의 Continuation들은 '계속/연속&amp;#8217;이라는 상태를 의미하는 것이 아니라, 그런 상태의 담지체로서의 물건이나 대상이다. 다시 말해 '계속되는 이야기', '연장된 줄', '이어진 건물' 등을 의미하는 것이다. 하지만 이것을 한국어로 '계속/연속&amp;#8217;이라는 단어로 번역하면 '상태&amp;#8217;만을 의미하기 때문에 부자연스러운 표현이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 글의 주제인, 프로그래밍에서의 'Continuation&amp;#8217;이라는 용어도 '계속/연속&amp;#8217;이라는 상태를 의미하는 것이 아니라, 그런 상태의 담지체인 구체적인 대상을 의미한다. 실제로 컴퓨터 공학 논문들에서 Continuation의 개념을 설명할 때 많이 나오는 영어 표현이 'rest of program' 혹은 'rest of computation' 이다. '프로그램의 나머지' 혹은 '계산의 나머지' 정도가 되는데, 풀어쓰면 '현재 실행되고 있는 코드 뒤로 이어서 실행될 코드들&amp;#8217;이라고 이해하면 된다. 위에서 설명한 바와 같이 영어에서는 'Continuation&amp;#8217;이 원래 구체적인 물체나 대상을 지칭하기 위해 사용되었기에, 컴퓨터 공학에서도 '나머지 프로그램&amp;#8217;이라는 의미를 나타낼 때도 'Continuation&amp;#8217;이라는 단어는 매우 자연스러웠을 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 이유로 이 글에서의 Continuation은 추상적 의미로서의 '상태&amp;#8217;를 나타내는 '계속/연속&amp;#8217;이 아닌, 보다 구체적 의미를 지닌 용어로 번역되어야 맞다고 판단했다. 이야기의 '속편', 줄의 '연장', 건물의 '증축&amp;#8217;과 같은 구체화된 '실체&amp;#8217;를 가장 잘 드러내는 용어로 번역되어야 한다. 그래서 이 글에서는 Continuation을 '뒤이어 이어지는 코드&amp;#8217;라는 의미에서 '후속문(後續文)'이라는 번역용어를 채택하게 되었다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 프로그램이 실행될 때는 현재 실행되고 있는 코드가 프로그래머의 관심의 초점이다. 후속문은 프로그래머의 관심을 현재 실행되고 있는 코드가 아니라 뒤이어 실행될 코드로 옮긴다(마치 주식에서 현물이 아닌 선물을 거래하는 것처럼). 만약 현재 실행되고 있는 코드에 뒤이어서 실행될 코드, 즉 후속문을 프로그래머가 마음대로 결정할 수 있다면, 그것은 바로 프로그램 제어를 마음대로 결정한다는 것을 의미한다. 후속문의 제어가 곧 프로그램의 제어 흐름을 결정하는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;table id=&quot;gromit&quot; class=&quot;tableblock frame-none grid-none spread center&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-bottom&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-bottom&quot;&gt;&lt;div&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em class=&quot;red&quot;&gt;레일을 까는 것이 곧 기차의 경로이다.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-bottom&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div&gt;&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://media.giphy.com/media/3oz8xtBx06mcZWoNJm/giphy.gif&quot; alt=&quot;Gromit&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;span class=&quot;small&quot;&gt;그로밋이 일급 레일 연장(First-Class continuation of rail)을 깔고 있다. 플라톤의 국가론을 읽었던 그는 Continuation 개념을 탑재했음이 분명하다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;프로그램에서 제어 흐름을 결정할 때 if, for, while 등의 제어문을 사용한다. 이런 제어문들은 컴파일러에서 기본으로 제공해 주는 것이지만, 만약 후속문이 지원된다면 보다 더 정교하고 다양한 제어 흐름을 프로그래머가 직접 만들어 사용할 수 있다. 예를 들어 map을 순회(iterate)할 때 보통은 map의 끝까지 가야 하나 후속문을 사용하면 조건에 맞는 map의 요소(element)에서 바로 리턴하게 만든다든가, 평가가 끝날 때까지 중간에 리턴할 수가 없는 Lisp 같은 언어에서 평가 중간에 리턴하게 만들 수가 있다. 사실 컴파일러는 if.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_4&quot; class=&quot;footnote&quot; href=&quot;#_footnote_4&quot; title=&quot;View footnote.&quot;&gt;4&lt;/a&gt;]&lt;/sup&gt;, for, while 같은 문법 요소를 내부적으로는 후속문으로 구현할 수 있다. 이뿐만 아니라 후속문은 예외(Exception), 파이버(Fiber), 코루틴(Coroutine), 제너레이터(Generator), 비결정적 선택(Non-deterministic Choice)과 같은 고급 제어 문법 요소를 구현하는 데도 사용된다. 사실 컴파일러 자체를 후속문을 기반으로 만들기도 한다.(&lt;a href=&quot;https://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X&quot;&gt;Compiling with Continuations&lt;/a&gt;) 이처럼 후속문은 프로그램 제어 흐름에 대한 가장 근본적인 개념을 제공하기 때문에, 프로그래밍 언어에서 후속문을 일급 객체(First-class Entity)로써 제공한다는 것은 곧 컴파일러가 할 수 있는 프로그램 제어 흐름에 대한 모든 능력을 프로그래머에게 제공하는 것이 된다. 즉 일급 객체가 된 후속문은 프로그램 제어에 관한 최상의 도구이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_암묵적_후속문&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_암묵적_후속문&quot;&gt;&lt;/a&gt;1.1. 암묵적 후속문&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;모든 프로그램은 암묵적 후속문의 관점에서 볼 수 있다. 현재 실행되고 있는 코드 뒤에는 항상 이어서 나오는 코드가 있으니까. 하지만 후속문 관점에서 프로그램을 해석한다는 것은 후속문에 익숙지 않은 프로그래머들에게는 사실 매우 낯설기만 하다. 그래서 아주 간단한 예부터 시작해서 후속문 개념에 익숙해질 필요가 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문이라는 개념을 익히기 위해서 모든 프로그램을 임시로 전행문, 현행문, 후행문으로 나누어서 생각해보자. 전행문은 앞서 이미 실행된 코드이고, 현행문은 지금 실행되고 있는 코드이고, 후행문은 바로 뒤에 이어서 실행될 코드라고 하자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 프로그램을 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;implicit-cont1&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 1. 암묵적 후속문 1&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  var a = 10;     ; 전행문 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
  var b = a + 5;  ; 현행문 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
  var c = b + 2;  ; 후행문 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서는 현행문을 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;라고 정했다. 프로그램을 해석할 때 현행문은 프로그래머가 실제로 실행되고 있는 코드라고 여기면서 현재 그 동작에 관심을 두는 코드라고 보면 된다. 현재 우리는 &lt;code&gt;var b = a + 5&lt;/code&gt; 라는 코드에 관심이 있다고 가정했기 때문에 이 코드가 현행문이 되는 것이다. 이 코드 이전 코드는 전행문이고, 그 이후 코드는 후행문이다. 따라서 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;은 전행문이고, &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;은 후행문이다. 그리고 후행문은 실행되는 후속문이다. 반면 실행되지 않는 후속문도 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;implicit-cont2&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 2. 암묵적 후속문 2&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  var a = 10;                 ; 전행문 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
  if (a &amp;gt; 0)                  ; 현행문 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    console.log(&quot;Positive&quot;);  ; 후행문 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  else
    console.log(&quot;Negative&quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서는 현행문이 비교문이다. 그리고 후행문은 3 라인이다. 5 라인은 실행되지는 않지만 현행문 뒤에 있으므로 후행문은 아니지만 후속문이다. 후속문은 실행되지 않는 것까지 포함하는 개념이다(프로그램에서 예외를 던지는 경우에서처럼). 즉 5라인은 실행되지 않도록 결정된 후속문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;implicit-cont3&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 3. 암묵적 후속문 3&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  var sum = 0;                ; 전행문 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
  for (var i=0; i&amp;lt;10; i++) {  ; 현행문, 후행문 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    sum += i;                 ; 현행문, 후행문 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서 현행문은 &lt;code&gt;for&lt;/code&gt; 문이다. &lt;code&gt;for&lt;/code&gt; 문은 2개 라인에 걸쳐 있다. 그런데 &lt;code&gt;for&lt;/code&gt; 문의 끝에 다다르면 제어가 다시 &lt;code&gt;for&lt;/code&gt; 문의 처음으로 가기 때문에 &lt;code&gt;for&lt;/code&gt; 문 자체는 또한 후행문이다. 즉 이 경우는 현행문이 후행문이 되는 경우다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 3가지 예들을 통해서 프로그램을 후속문의 관점에서 보았다. 위 예들에서 후행문은 후속문이다. 후속문은 실행과는 관계없이 뒤에 이어지는 코드를 말하기 때문에 후행문이 아닌 후속문도 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 위 예제들에서 후속문은 암묵적 상태에 있다. 이 코드들은 그저 작성된 순서대로 실행될 뿐이다. 일단 실행이 되면 이 코드들은 마치 밤하늘에 붙박이처럼 박혀있는 별자리와 같이, 혹은 운명처럼, 그 실행 순서가 정해져 있다. 결코 프로그래머가 그 순서를 바꿀 수가 없다. 프로그래머가 그 실행 순서를 바꾸고 다루고 조작할 수 있으려면 그것을 실체화하고(reify) 이름을 부여해야 한다. 이 말은 후속문이 일급객체가 되어야 한다는 것이다. 그런데 후속문은 코드이기 때문에 이것이 일급객체가 된다는 것은 곧 함수가 된다는 것이다. 함수는 프로그래머가 다룰 수 있는 개체(entity)이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_후속문의_실체화_reification_of_continuation&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문의_실체화_reification_of_continuation&quot;&gt;&lt;/a&gt;1.2. 후속문의 실체화(Reification of Continuation)&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;암묵적 후속문은 실체화(reify)되어 프로그래머가 다룰 수 있는 하나의 함수로 만들 수 있다. 프로그래머는 후속문을 함수처럼 다양하게 조작할 수 있다. 즉 호출하거나 혹은 호출하지 않거나, 호출한다면 몇 번이나 할 것인지, 그리고 언제 어디서 호출할 것인지, 또 어딘가에 저장하거나 혹은 전달하거나 등등 . 하지만 프로그램은 실체화 이전이나 이후나 하는 일은 똑같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 예에서 위의 &lt;a href=&quot;#implicit-cont1&quot;&gt;예제 1&lt;/a&gt;. 암묵적 후속문 1을 함수로 실체화하고 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 4. 후속문 실체화 1&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  function add2(x) { c = x + 2; }

  var a = 10;
  var b = a + 5;
  var c;
  add2(b)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;암묵적 후속문이었던 &lt;code&gt;var c = b + 2&lt;/code&gt;를 &lt;code&gt;add2&lt;/code&gt;라는 함수로 실체화하면서 원래 후속문이 있던 자리에서는 &lt;code&gt;add2&lt;/code&gt;함수의 호출로 바뀐다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 위의 &lt;a href=&quot;#implicit-cont2&quot;&gt;예제 2&lt;/a&gt;. 암묵적 후속문 2를 실체화하고 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 5. 후속문 실체화 2&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  function cont_then(x) {
    console.log(&quot;Positive&quot;);
  }

  function cont_else(x) {
    console.log(&quot;Negative&quot;);
  }

  var a = 10;

  if (a &amp;gt; 0)
    cont_then();
  else
    cont_else();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;암묵적 후속문 2의 비교문에서 then 절의 코드는 &lt;code&gt;cont_then&lt;/code&gt; 함수로 else 절의 코드는 &lt;code&gt;cont_else&lt;/code&gt; 함수로 각각 이동하면서, 그 자리에는 호출을 남겼다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 위의 &lt;a href=&quot;#implicit-cont3&quot;&gt;예제 3&lt;/a&gt;. 암묵적 후속문 3을 실체화하고 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 6. 후속문 실체화 3&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;  var sum = 0;

  function cont_for(i, last, step) {
    sum += i;
    if (i &amp;lt; last)
      cont_for(i + step, last, step);
  }

  cont_for(0, 10, 1);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;암묵적 후속문 3의 &lt;code&gt;for&lt;/code&gt; 문을 &lt;code&gt;cont_for&lt;/code&gt;라는 재귀함수로 실체화하였다. &lt;code&gt;for&lt;/code&gt; 문은 그 자체가 현행문이면서 동시에 후속문이기 때문에 함수가 다시 자신을 호출하는 재귀함수로 구현된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제들을 보다 보면 후속문은 함수의 형태이기 때문에 도대체 함수와 어떻게 다른 것인지 궁금해질 것이다. 사실 거의 모든 함수가 후속문이라고 할 수 있다. 왜냐하면, 어떤 함수든 결국 어떤 코드 뒤에서 호출된 것이라고 볼 수 있기 때문이다. 어떤 함수를 그냥 함수로 볼 것인지 아니면 후속문으로 볼 것인지는 결국 관점의 차이이다. 만일 함수를 어떤 일의 뒤에 실행된다는 관점에서 본다면 그 함수는 후속문이 된다. 그래서 용어가 중요한 것이다. 함수를 후속문이라고 부른다면, 그 함수를 어떤 일의 뒤에 실행되는 코드라는 관점에서 보겠다는 것이 된다. 이런 점에서 콜백 함수는 후속문이다. 왜냐하면, 콜백 함수는 어떤 일이 수행된 후에 이 함수를 호출해달라는 표현이기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_일급_후속문_first_class_continuation&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_일급_후속문_first_class_continuation&quot;&gt;&lt;/a&gt;1.3. 일급 후속문(First-Class Continuation)&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 우리는 후속문의 실체화를 직접 수행했다. 후속문을 함수로 랩핑하고 그 함수를 호출하는 것을 직접 우리가 했다. 그런데 후속문 실체화를 언어 차원에서 제공할 수도 있다. 프로그래머는 그런 기능을 사용하기만 하면 후속문이 &lt;strong&gt;자동으로&lt;/strong&gt; 함수로 실체화되어 프로그래머에게 주어진다. 이렇게 언어 차원에서 실체화되는 후속문을 일급 후속문이라고 하는데, 우리가 보통 후속문이라고 할 때는 바로 일급 후속문을 말하는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_후속문_프로그래밍&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문_프로그래밍&quot;&gt;&lt;/a&gt;2. 후속문 프로그래밍&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서도 언급했지만 후속문을 일급 객체로서 지원하는 언어들은 많다. 그런데 언어마다 후속문을 지원하는 방식은 조금씩 다르다. 마치 어떤 기능(예를 들어 스레드)에 대한 API가 언어마다 다른 것과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 이런 다름에도 불구하고, 후속문을 일급 객체로서 지원하는 언어들 대부분이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Call-with-current-continuation&quot;&gt;call/cc&lt;/a&gt;라는 API를 지원한다. call/cc는 Scheme이라는 언어에서 처음으로 지원되었는데, 이후 다른 언어들에서도 지원하게 되었다. 따라서 후속문 프로그래밍에서 call/cc를 아는 것은 중요하며, 알아두면 그 지식을 다른 언어에서도 유용하게 적용할 수 있다. 또한, 한 단계 발전한 한정 후속문(&lt;a href=&quot;https://en.wikipedia.org/wiki/Delimited_continuation&quot;&gt;Delimited Continuation&lt;/a&gt;)을 알기 위해서도 먼저 call/cc를 알아둘 필요가 있다. 이 글에서는 Scheme의 방언인 Racket으로 call/cc에 대해 설명을 이어간다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 글의 call/cc 예제 코드의 실행은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Racket_(programming_language)&quot;&gt;Racket&lt;/a&gt;(Scheme의 방언) 언어의 IDE인 DrRacket에서 했다. 독자분들도 DrRacket을 설치하면 별도의 과정이나 수정 없이  예제 코드를 간단히 복사/붙이기 하면 바로 실행해 볼 수 있다[&lt;a href=&quot;https://racket-lang.org/download/&quot;&gt;다운로드&lt;/a&gt;].&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 Racket 언어에는 다양한 한정 후속문(Delimited Continuation)들이 구현되어 있다. 우리가 나중에 살펴볼 한정 후속문인 shift/reset도 Racket 언어로 테스트해 볼 것이다. 첨언하면 Racket 언어를 만든 사람과 한정 후속문 중 하나인 prompt/control을 만든 사람이 같은 사람(&lt;a href=&quot;https://en.wikipedia.org/wiki/Matthias_Felleisen&quot;&gt;Matthias Felleisen&lt;/a&gt;)이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_call_cc&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_call_cc&quot;&gt;&lt;/a&gt;2.1. call/cc&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;call/cc는 call-with-current-continuation의 준말이다. call/cc가 단어 길이가 짧아서 더 많이 쓰인다(Scheme에서는 call-with-current-continuation라는 함수만 있고, Racket에서는 call/cc가 call-with-current-continuation의 alias로 정의되어 있다). 그래서 call/cc는 call-with-current-continuation 라는 이름에서처럼 &lt;code&gt;현후속문(current continuation)을 인자로 해서 호출하기&lt;/code&gt; 라는 의미라고 보면 된다. 현후속문이란 이제 방금 실체화되어(reify) 일급 객체가 된 따끈따끈한 후속문이라고 생각하면 되겠다. 사실 일급 객체가 된 후속문은 저장이 가능해서 이미 이전에 실체화된 후속문이 여럿 존재할 수 있기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;말을 좀 더 단순하게 하기 위해 인수가 하나인 함수를 '단항 함수&amp;#8217;라고 부르겠다. call/cc는 단항 함수를 입력받는 단항 함수다. call/cc가 하는 일은 후속문을 캡처하고, 이 캡처한 후속문을 인자로 해서, 입력받은 단항 함수를 호출하는 것이다. 이 후속문은 call/cc가 호출된 지점에서의 후속문을 캡처한 것이다(call/cc와 같은 후속문 관련 API들이 후속문을 자동으로 실체화하는 것을 '&lt;strong&gt;캡처한다&lt;/strong&gt;'라고 한다). 다시 말해 call/cc는 입력받은 단항 함수를, 캡처한 후속문을 인자로 해서 호출하는 단항 함수이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 call/cc의 정의를 가장 간단하게 나타낸 것이다. 아마도 call/cc는 다음과 같이 정의되어 있을 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 7. call/cc의 가상 정의(슈도 코드)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define (call/cc f)  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (let ((k .....))   &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      (f k)))          &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;call/cc 함수를 정의하고 있다. f는 call/cc의 인수이다. 보다시피 call/cc는 단항함수이다. f도 단항함수이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.....&lt;/code&gt;는 후속문을 캡처하는 코드를 나타낸다. 이것은 언어 차원에서 캡처를 해주는 것이기 때문에 구체적으로 어떻게 캡처하는지는 모르지만, 어쨌든 캡처된 후속문은 함수가 되어 지역변수 k에 바인딩한다(일반적으로 후속문 함수를 나타내는 변수명은 알파벳 k로 표기한다. 일관성을 위해 이후로 후속문 함수는 k로 나타낸다).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;보다시피 f도 단항함수인데 후속문 k를 인자로 해서 호출한다. 사실 이게 call/cc가 하는 역할의 전부다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;예제 7의 가상 정의 코드로 call/cc가 하는 일을 정리하면 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;단항함수를 인자로 받는다 : &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;후속문을 캡처해서 후속문 함수로 만든다 : &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;의 후속문 함수를 인자로 해서 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;의 단항함수를 호출한다 : &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;아마도 call/cc의 출력에 대해서는 왜 이야기하지 않는지 궁금한 독자도 있을 것이다. call/cc도 함수이므로 당연히 출력이 있다. 하지만 좀 복잡하다. 사용자 코드(바로 뒤에서 설명한다)에서 후속문 함수를 호출하느냐 아니냐에 따라, 출력이 있는 경우도 있고 없는 경우도 있다. 후속문 함수를 호출하는 경우에 코드의 흐름이 어떻게 되느냐를 파악하는 것이 call/cc 프로그래밍의 관건이며, 바로 이 글의 목적이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 call/cc의 사용법을 보여준다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 8. call/cc의 사용법&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (call/cc        &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (lambda (k)   &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      ...k...))   &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;call/cc를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;람다 함수를 만들어서 call/cc의 인자로 전달한다. 이 람다 함수를 위의 call/cc의 정의에서 인수 f로 받게 되는데, 이 함수는 call/cc 구현부에서 후속문 함수를 인자로 해서 호출될 것이다. 여기서도 후속문 함수를 받는 변수는 k로 표기한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;...k...&lt;/code&gt;는 실제 후속문 함수를 사용하는 &lt;strong&gt;사용자 코드&lt;/strong&gt;이다. &lt;strong&gt;사용자 코드&lt;/strong&gt;에서는 후속문 함수를 저장할 수도 있고, 호출할 수도 있고, 호출하지 않을 수도 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;call/cc는 인자로 받은 단항 함수의 &lt;strong&gt;사용자 코드&lt;/strong&gt;(&lt;code&gt;...k...&lt;/code&gt;)를 실행해주는 역할을 한다는 것을 파악하는 것이 중요하다. 단지 그 단항 함수의 &lt;strong&gt;사용자 코드&lt;/strong&gt;에서 후속문 함수를 유저가 사용할 수 있도록 만들어 주고 있을 뿐이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;예제 8의 &lt;code&gt;...k...&lt;/code&gt;를 '&lt;strong&gt;사용자 코드&lt;/strong&gt;'라고 부른다. 사실 '&lt;strong&gt;사용자 코드&lt;/strong&gt;''라는 말은 이 글에서만 사용하는 용어이다. call/cc는 결국 &lt;strong&gt;사용자 코드&lt;/strong&gt;에서 후속문 함수를 사용할 수 있도록 캡처해주는 역할만 하는 것으로 볼 수 있다. 결국, 중요한 것은 &lt;strong&gt;사용자 코드&lt;/strong&gt;가 어떤 일을 하는가이다. 그래서 따로 이름을 붙이는 것이 요긴하다. 이후부터 계속 call/cc에 의해 실행되는 이와 같은 코드를 call/cc의 &lt;strong&gt;사용자 코드&lt;/strong&gt;라고 부르겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 call/cc의 호출이 결국 사용자 코드의 실행으로 되는 과정을 보여준다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;callcc&quot; class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/callcc.png&quot; alt=&quot;callcc&quot; width=&quot;95%&quot; height=&quot;95%&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 1. call/cc는 결국 사용자 코드의 실행이다.&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;call/cc 호출로 람다 함수가 인자가 되어 인수 f에 바인딩된다. 옅은 보라색 사각형은 사용자 코드를 나타낸다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;f를 호출한다. 이때 캡처한 후속문 함수 k가 인자로 람다 함수에 전달된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;f의 호출은 결국 바인딩된 람다 함수의 호출이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;람다 함수의 호출은 람다 함수의 몸체(body)의 코드의 실행이다. 결국, 이것은 call/cc의 사용자 코드의 실행이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 call/cc에 관해 설명하였는데, call/cc를 사용할 때 중요한 것은 call/cc가 호출될 당시의 후속문이 무엇인지에 대한 파악이다. 즉 사용자 코드에서 사용하게 될 후속문 함수가 어떤 모양새의 함수가 되는지에 대해 프로그래머는 바로 알 수 있어야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;영어에서는 후속문과 후속문 함수를 구분하지 않고 통칭해서 Continuation이라고 표현하고 있는데, 이 때문에 때로 혼동을 일으키는 경우도 있다. 이 글에서는 명확하게 하기 위해 후속문과 후속문 함수를 구분한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이를 위해 후속문을 찾는데 쓰는 방법인 v 표기법에 대해 알아보겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_v_표기법&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_v_표기법&quot;&gt;&lt;/a&gt;2.2. v 표기법&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;v 표기법&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_5&quot; class=&quot;footnote&quot; href=&quot;#_footnote_5&quot; title=&quot;View footnote.&quot;&gt;5&lt;/a&gt;]&lt;/sup&gt;은 call/cc의 후속문 함수가 어떤 함수인지를 파악하게 해주는 방법이다. v 표기법은 뒤에서 설명할 v 인자 대입법과 함께 call/cc를 사용하는 코드를 해석하는데 요긴한 코드 해석 기법이다. v 표기법을 사용하면 call/cc의 후속문 함수를 머릿속으로 구성해 낼 수 있는데, 이것이 되어야 call/cc의 사용자 코드가 어떻게 동작하는지에 대한 파악이 가능해진다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;v 표기법은 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;현재 코드의 현행문을 정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 현행문을 알파벳 문자 v로 바꾼다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전체 코드를 람다 함수로 감싼다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 &lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt; 코드에 v 표기법을 적용하는 과정을 보여준다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (* 3 4) 5) ==&amp;gt; (+ v 5) ==&amp;gt; (lambda (v) (+ v 5))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드에서는 &lt;code&gt;(* 3 4)&lt;/code&gt;를 현행문으로 정했다. 이 현행문을 &lt;code&gt;v&lt;/code&gt;로 바꾼다. 그리고 나서 인수 &lt;code&gt;v&lt;/code&gt;를 받는 람다 함수 &lt;code&gt;(lambda (v) .....)&lt;/code&gt;로 감싼다. 이렇게 해서 만들어진 &lt;code&gt;(lambda (v) (+ v 5))&lt;/code&gt; 이 &lt;code&gt;(* 3 4)&lt;/code&gt;를 현행문으로 했을 때의 후속문 함수이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;현행문 &lt;code&gt;(* 3 4)&lt;/code&gt;를 인자로 해서 후속문 함수를 호출하면 원래 코드와 같게 된다. 즉 &lt;code&gt;((lambda (v) (+ v 5)) (* 3 4))&lt;/code&gt;는 원래 코드인 &lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt; 와 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 코드에서는 3을 현행문으로 보았다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (* 3 4) 5) ==&amp;gt; (+ (* v 4) 5) ==&amp;gt; (lambda (v) (+ (* v 4) 5))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드에서는 현행문 &lt;code&gt;3&lt;/code&gt;을 &lt;code&gt;v&lt;/code&gt;로 바꾼 후, 역시 인수 &lt;code&gt;v&lt;/code&gt;를 받는 람다 함수로 감쌌다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;마찬가지로 현행문 &lt;code&gt;3&lt;/code&gt;을 인자로 해서 후속문 함수를 호출하면 원래 코드와 같게 된다. 즉 &lt;code&gt;((lambda (v) (+ (* v 4) 5)) 3)&lt;/code&gt;는 원래 코드인 &lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt; 와 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;전체 코드를 현행문으로 볼 수도 있는데 그러면 후속문 함수는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%AD%EB%93%B1_%ED%95%A8%EC%88%98:&quot;&gt;identity&lt;/a&gt; 함수가 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (* 3 4) 5) ==&amp;gt; v ==&amp;gt; (lambda (v) v)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서도 다음과 같이 현행문을 인자로 해서 후속문을 호출하면 결국 원래 코드와 같다 : &lt;code&gt;lambda (v) v) (+ (* 3 4) 5&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그러면 &lt;code&gt;5&lt;/code&gt;를 현행문으로 정하면 후속문 함수는 무엇이 될까? 연습으로 여러분의 머릿속에서 직접 생각해보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 &lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt; 식의 각 항에 v 표기법을 적용하여 후속문를 구하는 과정을 나타낸다.&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 1. v 표기법의 적용&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;col&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;표현식&lt;/th&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;현행문&lt;/th&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;v 축약식&lt;/th&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;후속문 함수&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(* 3 4)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ v 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(lambda (v) (+ v 5))&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;3&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* v 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(lambda (v) (+ (* v 4) 5))&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;4&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 v) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(lambda (v) (+ (* 3 v) 5))&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;5&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) v)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(lambda (v) (+ (* 3 4) v))&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;v&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;(lambda (v) v)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 이제 call/cc를 사용해 볼 때가 되었다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_call_cc_적용하기&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_call_cc_적용하기&quot;&gt;&lt;/a&gt;2.3. call/cc 적용하기&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 사용했던 코드 &lt;code&gt;(+ (* 3 4) 5)&lt;/code&gt;에 call/cc를 적용해 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 현행문을 &lt;code&gt;(* 3 4)&lt;/code&gt;로 정했을 때의 call/cc를 사용한 코드이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;escape1&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 9. call/cc 사용하기&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (call/cc
       (lambda (k)
         (* 3 4)))  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
     5)
  ;=&amp;gt; 17&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;사용자 코드에서 후속문 k를 사용하지 않았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드의 결과는 17이다. 위 코드는 다음과 같이 동작한다. 앞서 보았듯이 call/cc는 사용자 코드를 실행하는 것이 전부이다. 그래서 call/cc의 결과는 사용자 코드의 결과이다. 현재 사용자 코드는 &lt;code&gt;(* 3 4)&lt;/code&gt;이므로 위의 코드에서의 call/cc는 &lt;code&gt;(* 3 4)&lt;/code&gt;의 결과인 12를 리턴한다. call/cc가 12를 리턴했으니 전체 코드는 &lt;code&gt;(+ 12 5)&lt;/code&gt;이 되어 최종 결과는 17이 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위의 코드에서는 call/cc에 의해 캡처된 후속문 함수 k를 사용하지 않았다. 다음 예제에서는 사용자 코드에서 후속문 함수 k를 호출한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;escape2&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 10. 후속문 함수 k 호출하기&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (call/cc
       (lambda (k)
         (k (* 3 4))))  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
     5)
  ;=&amp;gt; 17&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;사용자 코드에서 후속문 함수 k를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;재밌게도 위 코드의 결과도 17이다. 후속문 함수 k를 호출하지 않은 경우와 결과가 같다.  왜일까?&lt;br&gt;
그 이유를 알려면 후속문 함수 k의 중요한 특성인 탈출(espace)에 대해서 알아야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_탈출_escape&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_탈출_escape&quot;&gt;&lt;/a&gt;2.4. 탈출(escape)&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;call/cc에 의해 캡처된 후속문 함수는 탈출 함수이다. 무슨 말인고 하면, call/cc에서 후속문 함수를 호출하면 그 시점에서의 모든 스택이 풀리면서, 제어는 최상위 코드단으로 이동하고 call/cc를 감싸고 있는 코드는 실행되지 않는다. 마치 예외를 던진 것과 같다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_6&quot; class=&quot;footnote&quot; href=&quot;#_footnote_6&quot; title=&quot;View footnote.&quot;&gt;6&lt;/a&gt;]&lt;/sup&gt; 그래서 사실 위의 코드에서 call/cc 이후의 코드 &lt;code&gt;(+ 5)&lt;/code&gt;는 실행되지 않는다. 그런데도 결과가 같은 이유는? 그것은 후속문 함수가 &lt;code&gt;(lambda (v) (+ v 5))&lt;/code&gt; 이기 때문에 여기에 &lt;code&gt;(* 3 4)&lt;/code&gt;의 결과인 12를 인자로 호출하면 결국 17이 되기 때문이다. 즉 후속문 함수가 자신이 탈출한 코드와 같기 때문에 같은 결과가 나온 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 11. 후속문 함수 k 의 탈출(escape)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (+ (call/cc
       (lambda (k)
         (+ 3 (k 4))))  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
     5)
  ;=&amp;gt; 9&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;사용자 코드에서 후속문 함수 k의 호출이  다른 사용자 코드 &lt;code&gt;(+ 3 .....)&lt;/code&gt; 이 수행되기 전에 이루어지고 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제에서는 후속문 함수 k가 실행되면서 최상위 코드단으로 제어가 이동하기 때문에, 나머지 사용자 코드 &lt;code&gt;(+ 3 .....)&lt;/code&gt;은 수행되지 않는다. 위의 경우, 후속문 함수 &lt;code&gt;(lambda (v) (+ v 5))&lt;/code&gt;에 인자 4가 적용되어, 결과는 9가 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 후속문 함수가 하위 함수들에서 호출되어도 탈출되는 것을 보여준다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 12. 후속문 함수 k 의 탈출2(escape)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define (f2 k)  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (println &quot;f2 entered&quot;)
    (k &quot;continuation&quot;)
    (println &quot;not printed&quot;))

  (define (f1 k)  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    (println &quot;f1 entered&quot;)
    (f2 k)
    (println &quot;not printed&quot;))

  (let ((s (call/cc  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
             (lambda (k)
               (begin
                 (println &quot;called in call/cc&quot;)
                 (f1 k)  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
                 (println &quot;not printed&quot;))))))
    (println (string-append s &quot; returned&quot;)))  &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;

  ;&amp;gt;&amp;gt; &quot;called in call/cc&quot;
  ;&amp;gt;&amp;gt; &quot;f1 entered&quot;
  ;&amp;gt;&amp;gt; &quot;f2 entered&quot;
  ;&amp;gt;&amp;gt; &quot;continuation returned&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f2&lt;/code&gt; 함수를 정의한다. 인수 &lt;code&gt;k&lt;/code&gt;에는 후속문 함수가 들어온다. &lt;code&gt;f2&lt;/code&gt; 함수는 이 후속문 함수를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f1&lt;/code&gt; 함수를 정의한다. 인수 &lt;code&gt;k&lt;/code&gt;에는 후속문 함수가 들어온다. &lt;code&gt;f1&lt;/code&gt; 함수는 이 후속문 함수를 호출하지 않고 &lt;code&gt;f2&lt;/code&gt; 함수에 전달한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;마치 &lt;code&gt;call/cc&lt;/code&gt;의 리턴값이 지역 변수 &lt;code&gt;s&lt;/code&gt;에 바인딩되는 것으로 보인다. 이때 이 리턴값은 &lt;code&gt;f2&lt;/code&gt; 함수에서 후속문 함수를 호출하는데 사용된 인자이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;후속문 함수를 인자로 해서 &lt;code&gt;f1&lt;/code&gt; 함수를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;후속문 함수가 리턴한 값을 프린트한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제에서 3개의 &lt;code&gt;(println &quot;not printed&quot;)&lt;/code&gt; 식은 모두 실행되지 않는다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제에서 후속문 함수는 &lt;code&gt;f1&lt;/code&gt; 함수를 거쳐 &lt;code&gt;f2&lt;/code&gt; 함수로 전달되어서 &lt;code&gt;f2&lt;/code&gt; 함수에서 호출되고 있다. &lt;code&gt;f2&lt;/code&gt; 함수에서 후속문 함수가 호출되면 제어는 스택 프레임을 뛰어넘어서 &lt;code&gt;call/cc&lt;/code&gt;가 호출되었던 지점으로 이동한다(왜냐하면 &lt;code&gt;call/cc&lt;/code&gt; 호출 이후가 바로 후속문이므로). 제어의 이동과 함께, 후속문 함수가 받은 인자 &lt;code&gt;&quot;continuation&quot;&lt;/code&gt;이라는 문자열도 &lt;code&gt;call/cc&lt;/code&gt; 가 호출되었던 지점으로 전달된다. 그리고나서 이 값이 지역 변수 &lt;code&gt;s&lt;/code&gt;에 바인딩된다. 이것은 위 코드상으로만 본다면 마치 &lt;code&gt;call/cc&lt;/code&gt;가 그 값을 리턴한 것처럼 보인다(사실은 호출한 것인데). 하지만 위 코드에서 &lt;code&gt;call/cc&lt;/code&gt;는 값을 결코 리턴하지 못한다. 왜냐하면 &lt;code&gt;(f1 k)&lt;/code&gt; 이후의 코드는 실행되지 않기 때문이다. 마찬가지로 &lt;code&gt;f1&lt;/code&gt; 함수와 &lt;code&gt;f2&lt;/code&gt; 함수의 마지막 식들은 실행되지 않는다. 후속문 함수가 호출되는 순간, 제어는 &lt;code&gt;call/cc&lt;/code&gt; 자리로 이동하기 때문에(그리고 후속문 함수의 인자도), 후속문 함수 호출 이후의 코드들은 실행되지 못한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문 함수의 이런 특성은 자바나 C++의 throw/catch와 비슷하다. throw/catch처럼 제어가 스택 프레임상의 몇 단계 위로 이동할 수 있는 이러한 특성을 Non-local Exit&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_7&quot; class=&quot;footnote&quot; href=&quot;#_footnote_7&quot; title=&quot;View footnote.&quot;&gt;7&lt;/a&gt;]&lt;/sup&gt;라고 한다. throw/catch 외에 Non-local Exit 기능을 구현한 것으로는 C언어의 setjmp/longjmp&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_8&quot; class=&quot;footnote&quot; href=&quot;#_footnote_8&quot; title=&quot;View footnote.&quot;&gt;8&lt;/a&gt;]&lt;/sup&gt;가 있다. 하지만 후속문 함수의 탈출은 Non-local Exit보다는 더 큰 개념이다. Non-local Exit은 한 스택 안에서 제어가 스택 위로 이동하는 것이지만, 후속문 함수의 호출은 별도의 스택으로 대체되는 것이다. 스택을 완전히 대체하는 것이기 때문에 후속문 함수의 호출은 캡처되었던 당시의 모든 지역 변수들이 복원된다. 반면 Non-local Exit은 스택 프레임을 빠져나오면서 일부 지역 변수를 잃어버리게 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;callcc-stack&quot; class=&quot;sidebarblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;call/cc 호출시 콜스택의 변화&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문 함수의 탈출 대한 이해를 돕기 위해, &lt;a href=&quot;#escape1&quot;&gt;예제 9&lt;/a&gt;와 &lt;a href=&quot;#escape2&quot;&gt;예제 10&lt;/a&gt;에서 call/cc 호출시 콜 스택의 변화를 비교해 본다. 아래 그림2와 그림 3은 실제의 콜 스택을 나타낸다기보다는 이해를 돕기 위해서 콜 스택에 대한 개념도 수준으로 그려본 것이다. 그림에서 실선 화살표는 호출을, 파선 화살표는 리턴을, 굵은 쇄선 화살표는 후속문 함수의 탈출을 나타낸다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/escape1.png&quot; alt=&quot;escape1&quot; width=&quot;100%&quot; height=&quot;90%&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 2. &lt;a href=&quot;#escape1&quot;&gt;예제 9&lt;/a&gt;의 call//cc 호출시 콜 스택의 변화&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;#escape1&quot;&gt;예제 9&lt;/a&gt;에서 가장 먼저 실행되는 함수는 &lt;code&gt;(lambda (k) (* 3 4))&lt;/code&gt; 이다. 이 함수가 실행될 때의 콜 스택을 위 그림 2의 (1) 에서 나타내었다. 이 함수는 '무명함수&amp;#8217;를 리턴한다. 이 '무명함수&amp;#8217;를 인자로 해서 call/cc가 호출된다. call/cc는 인자로 받은 '무명함수&amp;#8217;를 호출하고, '무명함수&amp;#8217;는 &lt;code&gt;(* 3 4)&lt;/code&gt;를 호출한다. &lt;code&gt;*&lt;/code&gt; 연산자는 12를 리턴하고, 무명함수도 12를 리턴한다. 여기까지의 콜 스택을 위 그림 2의 (2) 에서 나타내었다. call/cc가 12를 리턴하고 스택을 빠져나가면, &lt;code&gt;(+ 12 5)&lt;/code&gt;가 콜 스택에 들어온다. 이제 콜 스택은 위 그림 2의 (3) 의 상태가 된다. &lt;code&gt;(+12 5)&lt;/code&gt;는 17을 리턴해서 스택에는 위 그림 2의 (4) 에서처럼 17이 최종값이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 그림 2는 call/cc가 호출되더라도 후속문 함수가 호출되지 않는다면, 콜 스택은 일반적인 함수 호출과 같다는 사실을 보여준다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 &lt;a href=&quot;#escape2&quot;&gt;예제 10&lt;/a&gt;에서 후속문 함수가 호출되는 경우, 스택의 변화는 어떻게 되는지 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/escape2.png&quot; alt=&quot;escape1&quot; width=&quot;100%&quot; height=&quot;90%&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 3. &lt;a href=&quot;#escape2&quot;&gt;예제 10&lt;/a&gt;의 call//cc 호출시 콜 스택의 변화&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;#escape2&quot;&gt;예제 10&lt;/a&gt;에서도 가장 먼저 실행되는 함수는 &lt;code&gt;(lambda (k) (k (* 3 4)))&lt;/code&gt; 이다. 그리고 &lt;code&gt;(*3 4)&lt;/code&gt;가 호출되고 12를 리턴하는 상황까지는 그림 2와 같다. 달라지는 것은 리턴된 12를 받아 후속문 함수 k가 호출된다는 것이다. 그 상황을 위 그림 3의 (3)에서 나타내었다. 그런데 후속문 함수 k가 호출되면 스택에 또 쌓이는 것이 아니라, 스택이 완전히 비워지면서 후속문 함수 k, 즉 &lt;code&gt;(lambda (v) (+ v 4))&lt;/code&gt;만 스택에 남게 된다. 이때의 스택의 상태를 위 그림 3의 (4) 에서 나타내었다. 바로 이 지점이 후속문 함수의 탈출을 잘 보여주는 장면이다. 위 그림 3의 (3) 에서 후속문 함수 k가 호출되지만, 후속문 함수의 실제 실행은 그림 3의 (4) 와 같이, 지금까지 쌓였던 모든 스택 프레임을 비우고, 오직 후속문 함수만 스택에 남게 된다. 이후부터는 다시 정상적인 호출이 진행된다. &lt;code&gt;(+ 12 5)&lt;/code&gt; 가 호출되면서 스택 프레임이 쌓이고, 17이 리턴되면, 후속문 함수가 받아서 다시 17을 리턴한다. 이제 스택은 위 그림 3의 (5) 에서처럼 17이 최종값으로 남게 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_return문_구현하기&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_return문_구현하기&quot;&gt;&lt;/a&gt;2.5. return문 구현하기&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;call/cc에 의해 캡처된 후속문 함수의 탈출이라는 이러한 특성을 이용하면, Scheme이나 Racket 같은 리스프 언어에는 없는 return을 구현할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 return을 구현한 아주 간단한 예제이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 13. 후속문 함수로 return 구현하기&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define (f return)  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (return 2)
    3)

  (f (lambda (x) x))) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
  ;=&amp;gt; 3

  (call/cc f)         &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  ;=&amp;gt; 2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;return을 인수로 받는 함수 f를 정의한다. return은 함수인데, f 함수 안에서 호출된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;함수 f를 identity 함수(입력을 그대로 출력하는 함수)를 인자로 해서 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;함수 f를 call/cc로 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제의 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;에서 함수 &lt;code&gt;f&lt;/code&gt;는 identity 함수를 인자로 받아 호출한다. identity 함수는 인자가 되어 함수 &lt;code&gt;f&lt;/code&gt;에서 return 인수에 바인딩된다. 식 &lt;code&gt;(return 2&lt;/code&gt;)가 호출되면 &lt;code&gt;return&lt;/code&gt;은 identity 함수이므로 2를 그대로 리턴하고 버려지며, 마지막 식인 3이 함수 &lt;code&gt;f&lt;/code&gt;의 리턴값이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;반면 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;에서 함수 &lt;code&gt;f&lt;/code&gt;는 call/cc의 인자로서 호출되고 있기 때문에, 함수 &lt;code&gt;f&lt;/code&gt;의 &lt;code&gt;return&lt;/code&gt; 인수에는 후속문 함수가 전달된다. 식 &lt;code&gt;(return 2)&lt;/code&gt;가 실행되면 &lt;code&gt;return&lt;/code&gt;은 후속문 함수이기 때문에 바로 그 자리에서 제어는 탈출하게 된다. 따라서 아래에 있는 코드 3은 수행되지 않고, 2가 함수 &lt;code&gt;f&lt;/code&gt;의 리턴값이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 위 예제는 별로 유용한 코드는 아니다. 후속문 함수를 이용한 &lt;code&gt;return&lt;/code&gt; 사용법을 보여주기 위해 억지로 만든 코드이기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 &lt;code&gt;return&lt;/code&gt;을 좀 더 유용한 방식으로 사용한 예제이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 14. 후속문 함수를 for-each에서 사용하기&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define (print-list a-list)  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (for-each (lambda (element)
                (printf &quot;~a &quot; element))
              a-list))

  (print-list '(1 2 3 0 4 5))  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
  ;&amp;gt;&amp;gt; 1 2 3 0 4 5


  (define (print-list-till-zero a-list)  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    (call/cc (lambda (return)
               (for-each (lambda (element)
                           (if (= 0 element)
                             (return (void))
                             (printf &quot;~a &quot; element)))
                         a-list))))

  (print-list-till-zero '(1 2 3 0 4 5))  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
  ;&amp;gt;&amp;gt; 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;print-list&lt;/code&gt; 함수를 정의한다. 인수 &lt;code&gt;a-list&lt;/code&gt;는 리스트를 받는다. 이 함수는 인수의 요소들을 프린트한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;리스트 &lt;code&gt;'(1 2 3 0 4 5)&lt;/code&gt;를 인자로 &lt;code&gt;print-list&lt;/code&gt; 함수를 호출한다. &lt;code&gt;1 2 3 0 4 5&lt;/code&gt;가 프린트된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;print-list-till-zero&lt;/code&gt; 함수를 정의한다. 인수 &lt;code&gt;a-list&lt;/code&gt;는 리스트를 받는다. 이 함수는 &lt;code&gt;print-list&lt;/code&gt; 함수와 같이 리스트의 요소들을 프린트한다. 다른 점은 리스트에서 0을 만나면 프린트를 중단한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;리스트 &lt;code&gt;'(1 2 3 0 4 5)&lt;/code&gt;를 인자로 &lt;code&gt;print-list-till-zero&lt;/code&gt; 함수를 호출한다. &lt;code&gt;1 2 3&lt;/code&gt;이 프린트된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;for-each&lt;/code&gt;는 두 번째 인자로 받은 리스트의 모든 요소를 순회하면서 첫 번째 인자로 받은 함수를 호출한다. 정상적인 경우에 &lt;code&gt;for-each&lt;/code&gt;는 리스트의 모든 요소를 순회하게 된다. 그러나 가끔 리스트를 순회하다가 특정 요소에서 중단하고 싶을 때가 있다. 이럴 경우 위와 같이 call/cc를 이용하면 중간에 리턴할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;return은 후속문 함수의 탈출을 이용하는 것이기 때문에 &lt;code&gt;for-each&lt;/code&gt; 문이 call/cc의 사용자 코드 속으로 들어왔다. 위 코드에서 후속문 함수는 return이라는 의미를 살리기 위해 &lt;code&gt;k&lt;/code&gt;가 아니라 &lt;code&gt;return&lt;/code&gt; 인수가 받는다. 사용자 코드에서 &lt;code&gt;return&lt;/code&gt;을 호출하면 후속문 함수의 호출이기 때문에 전체 사용자 코드를 탈출하게 된다. 이런 식으로 &lt;code&gt;for-each&lt;/code&gt; 중간에서 실행을 중단하는 것이 가능하게 되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_후속문_함수_저장하기&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문_함수_저장하기&quot;&gt;&lt;/a&gt;2.6. 후속문 함수 저장하기&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문 함수의 진정한 힘은 후속문 함수를 저장할 때 나온다. 저장된 후속문 함수를 필요할 때 다시 호출할 수 있다는 것은 엄청난 파워를 갖는다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 15. 후속문 함수 저장하기&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define *k* #f) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

  (+ (call/cc
       (lambda (k)
         (begin
           (set! *k* k)  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
           (k (* 3 4)))))
     5)
  ;=&amp;gt; 17

  *k* &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  ;=&amp;gt; #&amp;lt;continuation&amp;gt;

  (*k* (* 3 4)) &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
  ;=&amp;gt; 17

  (*k* 1)
  ;=&amp;gt; 6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;후속문 함수를 저장하기 위한 전역변수 &lt;code&gt;*k*&lt;/code&gt;를 정의한다. (당장은 임시로 불린값(boolean value) &lt;code&gt;#f&lt;/code&gt;로 설정한다)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;후속문 함수를 전역변수 &lt;code&gt;*k*&lt;/code&gt;에 저장한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;전역변수 &lt;code&gt;*k*&lt;/code&gt;에 저장한 것은 후속문 함수임을 확인한다. &lt;code&gt;#&amp;lt;continuation&amp;gt;&lt;/code&gt;은 후속문 함수임을 보여준다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;전역변수 &lt;code&gt;*k*&lt;/code&gt;에 저장한 후속문 함수를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제는 후속문 함수를 저장했다가 다시 호출할 수 있음을 보여주고 있다. 전역변수뿐만 아니라 지역변수나 리스트 등에 저장해서 사용할 수도 있다. 후속문 함수가 저장되었다가 나중에 다시 호출될 수 있다는 것은 엄청난 파워를 의미하는데, 이것은 이후 예제를 통해 살펴보게 될 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_후속문_이디엄&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문_이디엄&quot;&gt;&lt;/a&gt;2.7. 후속문 이디엄&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;call/cc를 사용할 때 자주 쓰는 이디엄(Idiom)이 있다. 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 16. 후속문 이디엄&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (let ((x (call/cc (lambda (k) k)))) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt; &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    (x (lambda (ignore) &quot;hi&quot;)))       &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  ;=&amp;gt; &quot;hi&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;call/cc의 사용자 코드는 단지 &lt;code&gt;k&lt;/code&gt;뿐이므로, 후속문 함수 &lt;code&gt;k&lt;/code&gt;를 리턴하기만 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;리턴된 후속문 함수를 지역변수 &lt;code&gt;x&lt;/code&gt;에 바인딩한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;저장된 후속문 함수를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제는 call/cc를 사용하는 코드에서 많이 볼 수 있는 이디엄을 아주 간략하게 보여주고 있다. 이후의 예제들에서 call/cc를 적용하는 복잡한 코드를 이해하기 위해서는 이 이디엄을 잘 이해해야 한다. 이 예제가 어떻게 동작하는지 하나씩 분석해보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;우선 후속문 함수 &lt;code&gt;k&lt;/code&gt;는 어떤 모양일지 파악해보자. call/cc 문(즉 &lt;code&gt;(call/cc (lambda (k) k))&lt;/code&gt;)의 바깥에 있는 모든 코드가 후속문이다. 예제 16에서 후속문이 되는 코드를 아래에 보라색 바탕의 이탤릭체로 표기하였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;em class=&quot;cont1&quot;&gt;(let ((x&lt;/em&gt; (call/cc (lambda (k) k))&lt;em class=&quot;cont1&quot;&gt;))&lt;/em&gt;
  &lt;em class=&quot;cont1&quot;&gt;(x (lambda (ignore) &quot;hi&quot;)))&lt;/em&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 v 표기법을 사용해서 call/cc 문을 v로 대체하고, 람다 함수로 랩핑하면, 후속문 함수가 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (lambda (v)
    (let ((x v))
      (x (lambda (ignore) &quot;hi&quot;))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드에서 let 문만 보면 원래 코드(예제 16)에서 call/cc 문을 v로 대체한 게 전부다. call/cc 프로그래밍에 익숙해지면 call/cc 문을 v로 대체해버리는 방식으로 코드를 해석하게 된다(굳이 후속문 함수를 만드는 복잡한 과정 없이, 단순하게 v 표기법으로 코드 해석이 가능해진다).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 예제 16의 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;을 보자. call/cc의 사용자 코드 내부에서 후속문 함수 &lt;code&gt;k&lt;/code&gt;를 호출하지 않고 리턴만 했기 때문에 탈출은 없다. 그래서 call/cc는 캡처한 후속문 함수 &lt;code&gt;k&lt;/code&gt;를 바로 리턴한다. 리턴된 후속문 함수는 &lt;code&gt;let&lt;/code&gt;문에서 변수 &lt;code&gt;x&lt;/code&gt;에 바인딩된다. 그러고나서 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;에서 &lt;code&gt;x&lt;/code&gt;에 바인딩된 후속문 함수를 호출하는데, 이때 인자는 &lt;code&gt;(lambda (ignore) &quot;hi&quot;)&lt;/code&gt;이다. 이 람다 함수를 편의상 '람다 함수 hi&amp;#8217;라고 부르자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문 함수의 호출 &lt;code&gt;(x (lambda (ignore) &quot;hi&quot;))&lt;/code&gt;에 의해 이제 예제 16은 다음 코드가 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  ((lambda (v)
    (let ((x v))
      (x (lambda (ignore) &quot;hi&quot;))))
   (lambda (ignore) &quot;hi&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드는 람다 함수 hi를 인자로 해서 후속문 함수를 호출하는 것이다. 이 코드가 실행되면 후속문 함수의 인수 &lt;code&gt;v&lt;/code&gt;에 람다 함수 hi가 들어가고 후속문 함수의 본문(body)이 실행된다. 후속문 함수의 본문의 &lt;code&gt;let&lt;/code&gt;식에서 &lt;code&gt;v&lt;/code&gt;는 람다 함수 hi로 대체된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 예제 16은 다음 코드가 된다. 이것은 후속문 함수 본문(body)의 실행이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (let ((x (lambda (ignore) &quot;hi&quot;)))
      (x (lambda (ignore) &quot;hi&quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 코드를 보면 원래 코드(예제 16)의 &lt;code&gt;call/cc&lt;/code&gt; 자리를 람다 함수 hi로 대체한 것과 같다. 이번에는 &lt;code&gt;let&lt;/code&gt;식에서 지역 변수 &lt;code&gt;x&lt;/code&gt;에 람다 함수 hi가 바인딩된다. 그리고 다시 &lt;code&gt;x&lt;/code&gt;에 바인딩된 함수, 즉 람다 함수 hi가 호출되는데, 이번에는 인자가 람다 함수 hi 자기 자신이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 예제 16은 다음 코드가 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  ((lambda (ignore) &quot;hi&quot;) (lambda (ignore) &quot;hi&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드에서 앞의 람다 함수 hi의 인수 &lt;code&gt;ignore&lt;/code&gt;에 뒤의 람다 함수 hi 자기 자신이 들어간다. 그런데 이 람다 함수 hi는 인수를 사용하지 않고 단지 &lt;code&gt;&quot;hi&quot;&lt;/code&gt;만을 리턴한다. 이 리턴값이 예제 16의 최종값이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_v_인자_대입법&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_v_인자_대입법&quot;&gt;&lt;/a&gt;2.8. v 인자 대입법&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지의 과정을 하나씩 보았는데 좀 복잡해 보일 수 있다. 하지만 실제로는 코드가 어떻게 실행되는지 간단하게 머릿속에서 유추해 볼 수 있다. 원래 코드(예제 16)에 v 표기법과 v 인자 대입법을 차례로 적용하면 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;v 인자 대입법&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_9&quot; class=&quot;footnote&quot; href=&quot;#_footnote_9&quot; title=&quot;View footnote.&quot;&gt;9&lt;/a&gt;]&lt;/sup&gt;은 위에서 설명한 v 표기법과 함께 call/cc를 사용하는 코드를 해석하기 위한 코드 해석 기법이다. v 인자 대입법은 후속문 함수가 호출될 때 적용하는 기법이다. 후속문 함수가 호출되는 과정을 보면, 호출시에 받은 인자가 후속문 함수의 인수 v에 바인딩되고, 이 인자는 후속문 함수 몸체(body)에서 나타나는 v를 대체하게 된다. 이 과정을 짧게 한 것이 v 인자 대입법이다. 즉 v 표기법에 의해 call/cc 문을 v 로 바꾸고, 다시 v를 후속문 함수의 인자로 바꾸는 것이다. 예제 16의 코드에  v 표기법과 v 인자 대입법을 적용해서 코드를 해석하는 과정을 아래에 나타냈다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/v-args.png&quot; alt=&quot;v 인자 대입법&quot; width=&quot;60%&quot; height=&quot;60%&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 4. v 인자 대입법&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;(1)의 첫째 줄의 &lt;code&gt;call/cc&lt;/code&gt; 에 v 표기법을 적용해서 (2)가 된다. 이때 &lt;code&gt;x&lt;/code&gt;는 &lt;code&gt;call/cc&lt;/code&gt;가 리턴한 후속문 함수로 바인딩된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;(2)의 둘째 줄에서 &lt;code&gt;x&lt;/code&gt;의 호출은 후속문 함수의 호출이 된다. 호출되면서 람다 함수 hi가 인자가 되어, 후속문 함수의 인수에 바인딩된다. 이때 후속문 함수의 코드 속의 &lt;code&gt;v&lt;/code&gt;가 아니라, 이 대신에 (2)의 첫째 줄의 &lt;code&gt;v&lt;/code&gt;를 둘째 줄의 람다 함수 hi로 대체하고 코드 해석을 &lt;code&gt;v&lt;/code&gt;가 있던 자리에서 다시 시작한다. 이것이 v 인자 대입법이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;v 인자 대입법에 의해 코드는 (2)에서 (3)이 된다. 코드 해석도 v가 대체된 자리에서 다시 시작한다. 그래서 이제 &lt;code&gt;x&lt;/code&gt;는 람다 함수 hi에 바인딩된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;(3)의 둘째 줄의 &lt;code&gt;x&lt;/code&gt;의 호출은 람다 함수 hi의 호출이다. 그리고 인자는 람다 함수 hi가 자기 자신이므로, (4)의 코드가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 코드 (1)은 예제 16과 같은 코드다. 코드 (1)에 v 표기법을 적용하면 코드 (2)로 바뀐다. 코드 (2)에서 &lt;code&gt;x&lt;/code&gt;는 이미 후속문 함수가 바인딩되어 있는 상태이다. 그래서 코드 (2)에서 &lt;code&gt;x&lt;/code&gt;의 호출은 후속문 함수의 호출이 된다. 이때 인자는 람다 함수 hi이다. 이 인자가 바로 위에 있는 &lt;code&gt;v&lt;/code&gt; 를 대체한다. 이것이 v 인자 대입법이다. 이렇게 해서 코드 (2)는 코드 (3)이 된다. 이제 코드 (3)에서 &lt;code&gt;x&lt;/code&gt;에는 람다 함수 hi가 바인딩된다. 결국 코드 (3)은 코드 (4)가 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_후속문_함수의_호출은_인자가_딸린_goto&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_후속문_함수의_호출은_인자가_딸린_goto&quot;&gt;&lt;/a&gt;2.9. 후속문 함수의 호출은 인자가 딸린 GOTO&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 v 표기법과 v 인자 대입법이라는 것을 배웠다. 사실 이 두 개를 합치면 후속문 함수 호출은 마치 인자가 딸린 GOTO처럼 해석될 수 있다. 즉 v 표기법은 마치 GOTO문에서 점프할 위치에 라벨을 붙이는 것과 같이 call/cc 자리를 v로 표기하는 것이고, v 인자 대입법은 GOTO의 점프가 해당 라벨로 제어를 옮기는 것처럼, 후속문 함수를 호출하면 제어가 v가 표기된 자리로 점프하는데, 이때 인자도 같이 전달되면서 그 라벨 자리(v로 대체된 call/cc 자리)에 인자가 들어가게 된다. 즉 후속문 호출은 마치 &lt;code&gt;GOTO label argument&lt;/code&gt;에서처럼 label위치로 점프하면서 그 label위치에 argument를 전달하는 것과 같은 것이다. 결국, call/cc 자리는 마치 GOTO의 라벨처럼 나중에 제어가 점프하면서 인자가 전달되는 곳이 된다. 후속문 함수가 호출되면 call/cc 자리로 제어가 점프하고 인자도 그 자리로 전달되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;후속문이 GOTO라는 관점을 이용하면, 예제 15는 더 간단한 과정으로 해석될 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/cont-goto.png&quot; alt=&quot;GOTO&quot; width=&quot;60%&quot; height=&quot;60%&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 5. 후속문 함수 호출은 GOTO이다.&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;후속문 함수가 호출되면서 제어는 call/cc 자리로 점프하고, 인자는 call/cc 자리로 전달된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;람다 함수 hi가 자기 자신을 인자로 해서 호출된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 call/cc를 사용하는 좀 더 복잡한 코드를 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 예제들에서 저장된 후속문을 다양하게 이용하는 여러 방법에 대해 배운다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_음양&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_음양&quot;&gt;&lt;/a&gt;2.10. 음양&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음으로 후속문 이디엄을 사용하는, 간단하면서도 중요한 응용 기법을 보여주는 예제를 볼 것이다. 후속문 프로그래밍을 강력하게 만드는 기법 중 하나가 call/cc로 캡처되는 후속문 속에 call/cc를 두는 기법이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yin-yang&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 17. 음양&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (let* ((yin  ((lambda (k) (display #\@) k) (call/cc (lambda (k) k))))   &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
         (yang ((lambda (k) (display #\*) k) (call/cc (lambda (k) k)))))  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    (yin yang))  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;예제 17은 일명 yin-yang인데, 이것은 후속문을 주제로 하는 컴퓨터 공학 논문에서 자주 다뤄지는 예제이다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_10&quot; class=&quot;footnote&quot; href=&quot;#_footnote_10&quot; title=&quot;View footnote.&quot;&gt;10&lt;/a&gt;]&lt;/sup&gt; yin-yang은 '음양&amp;#8217;의 중국식 발음을 영문으로 나타낸 것이다. 위 코드를 실행하면 문자 @와 *가 번갈아 가며 반복해서 무한히 찍힌다. 반복시마다 @는 한 번만 찍히지만 *는 찍히는 횟수가 반복할 때마다 1회 증가하면서 찍힌다. 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@*@**@***@****@*****@******@*******@********@*********@**********@***********@************@*************@**************@***************@****************@*****************@******************@*******************@********************@*********************@**********************@***********************@************************@*************************@**************************@**********&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 음양 코드가 어떻게 동작하는지 하나씩 분석해보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;먼저 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;을 보자. 위에서 나왔던 전형적인 후속문 이디엄이 나온다. &lt;code&gt;call/cc&lt;/code&gt;는 호출된 지점에서의 후속문 함수를 캡처해서 바로 리턴한다. 리턴된 후속문 함수를 인자로 해서 람다 함수 &lt;code&gt;(lambda (k) (display #\@) k)&lt;/code&gt; 호출된다. 이 람다 함수는 문자 &lt;code&gt;@&lt;/code&gt;를 찍고는 인수 &lt;code&gt;k&lt;/code&gt;에 저장된 후속문 함수를 다시 리턴한다. 후속문 함수는 이제 &lt;code&gt;yin&lt;/code&gt; 지역변수에 저장된다. 요약하면 &lt;code&gt;call/cc&lt;/code&gt;에서 후속문 함수를 캡처한 후, 문자 &lt;code&gt;@&lt;/code&gt;를 찍고, 캡처한 후속문 함수를 지역변수 &lt;code&gt;yin&lt;/code&gt;에 저장하는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;도 찍히는 문자 &lt;code&gt;*&lt;/code&gt;만 다를 뿐 비슷한 코드여서 코드가 하는 일을 다음과 같이 요약할 수 있다. &lt;code&gt;call/cc&lt;/code&gt;에서 후속문 함수를 캡처한 후, 문자 &lt;code&gt;*&lt;/code&gt;를 찍고, 캡처한 후속문 함수를 지역변수 &lt;code&gt;yang&lt;/code&gt;에 저장한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;에서는 &lt;code&gt;yin&lt;/code&gt;은 첫 번째 후속문 함수이고 &lt;code&gt;yang&lt;/code&gt;은 두 번째 후속문 함수이므로, 첫 번째 후속문 함수가 두 번째 후속문 함수를 인자로 해서 호출되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제부터 편의상 yin에 저장된 첫 번째 후속문 함수를 음 후속문 함수라고 부르고, yang에 저장된 두 번째 후속문 함수를 양 후속문 함수라고 부르겠다. 그러면 음 후속문 함수는 어떤 모양인지 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;아래에 첫 번째 call/cc에 의해서 캡처될 음 후속문을 보라색 바탕의 이탤릭체으로 표기하였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;em class=&quot;cont1&quot;&gt;(let* ((yin  ((lambda (k) (display #\@) k)&lt;/em&gt; (call/cc (lambda (k) k))&lt;em class=&quot;cont1&quot;&gt;))&lt;/em&gt;
       &lt;em class=&quot;cont1&quot;&gt;(yang ((lambda (k) (display #\*) k) (call/cc (lambda (k) k)))))&lt;/em&gt;
  &lt;em class=&quot;cont1&quot;&gt;(yin yang))&lt;/em&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;v 표기법에 따라 call/cc 자리를 v로 표기하면 음 후속문 함수는 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yin-cont&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 18. 음 후속문 함수&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (lambda (v)
    (let* ((yin  ((lambda (k) (display #\@) k) v))                         &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
           (yang ((lambda (k) (display #\*) k) (call/cc (lambda (k) k))))) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      (yin yang))) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;v 표기법 적용. 인수 &lt;code&gt;v&lt;/code&gt;는 &lt;code&gt;yin&lt;/code&gt;에 저장된다. 문자 &lt;code&gt;@&lt;/code&gt;를 찍는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;call/cc&lt;/code&gt;가 호출되면서 새로운 양 후속문 함수가 캡처되어 &lt;code&gt;yang&lt;/code&gt;에 저장된다. 문자 &lt;code&gt;*&lt;/code&gt;를 찍는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;yin&lt;/code&gt;에 저장된 함수가 &lt;code&gt;yang&lt;/code&gt;에 저장된 후속문 함수를 인자로 해서 호출된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위의 음 후속문 함수의 특이한 점은 후속문 함수 안에서 또 call/cc를 호출하면서 새로운 후속문 함수를 캡처하고 있다는 점이다. 즉 음 후속문 함수가 호출될 때마다,  새로운 양 후속문 함수가 생성된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음으로 양 후속문 함수가 어떤 모양일지 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;아래에 두 번째 call/cc에 의해서 캡처될 양 후속문을 보라색 바탕의 이탤릭체으로 표기하였다. 연두색 바탕의 이탤릭체으로 표기한 코드는 두 번째 call/cc가 호출되기 이전에 이미 실행된 선행문이다. 이 선행문은 캡처되지 않는다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;&lt;em class=&quot;cont1&quot;&gt;(let* (&lt;/em&gt;&lt;em class=&quot;cont2&quot;&gt;(yin  ((lambda (k) (display #\@) k) (call/cc (lambda (k) k))))&lt;/em&gt;
       &lt;em class=&quot;cont1&quot;&gt;(yang ((lambda (k) (display #\*) k)&lt;/em&gt; (call/cc (lambda (k) k))&lt;em class=&quot;cont1&quot;&gt;)))&lt;/em&gt;
  &lt;em class=&quot;cont1&quot;&gt;(yin yang))&lt;/em&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;v 표기법에 따라 call/cc 자리를 v로 표기하면 양 후속문 함수는 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yang-cont&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 19. 양 후속문 함수&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (let ((yin #&amp;lt;yin-continuation&amp;gt;))  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (lambda (v)
      (let ((yang ((lambda (k) (display #\*) k) v))) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        (yin yang)))) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;이미 실행된 선행문을 &lt;code&gt;let&lt;/code&gt; 문으로 표현했다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;v 표기법 적용. 인수 &lt;code&gt;v&lt;/code&gt;는 &lt;code&gt;yang&lt;/code&gt;에 저장된다. &lt;code&gt;*&lt;/code&gt;를 찍는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;yin&lt;/code&gt;에 저장된 함수를 &lt;code&gt;yang&lt;/code&gt;에 저장된 후속문을 인자로 해서 호출한다&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;에서 &lt;code&gt;yin&lt;/code&gt;은 자유 변수&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_11&quot; class=&quot;footnote&quot; href=&quot;#_footnote_11&quot; title=&quot;View footnote.&quot;&gt;11&lt;/a&gt;]&lt;/sup&gt;가 아니다. 양 후속문 함수가 캡처될 때, &lt;code&gt;yin&lt;/code&gt;은 이미 음 후속문 함수를 저장하고 있는 상태이기 때문이다. 따라서 양 후속문 함수는 클로저(closure)인 셈이다. 클로저(closure)란, 함수인데 그것이 실행되는데 필요한 별도의 정보를 따로 지닌 함수를 말한다. 이 별도의 정보를 클로저의 환경(environment) 혹은 컨텍스트(context)라고 한다. 양 후속문 함수는 &lt;code&gt;yin&lt;/code&gt;이라는 정보를 담은 컨텍스트를 갖는다. 그리고 그 컨텍스트에는 &lt;code&gt;yin&lt;/code&gt;이 음 후속문 함수로 설정되어 있다. 위 코드에서는 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;에서처럼 이 컨텍스트를 &lt;code&gt;let&lt;/code&gt;문으로 표현하였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;음양 예제를 분석하기 위해 위 코드를 좀 더 간략하게 표기할 필요가 있다. 지역변수 &lt;code&gt;yin&lt;/code&gt;과 &lt;code&gt;yang&lt;/code&gt;은 간단히 각각 &lt;code&gt;음&lt;/code&gt;과 &lt;code&gt;양&lt;/code&gt;으로 바꾸어 표기한다. 음 후속문 함수와 양 후속문 함수는 간단히 각각 &lt;code&gt;A&lt;/code&gt;와 &lt;code&gt;B&lt;/code&gt;로 표기한다. 뒤에서 보겠지만 음 후속문 함수 &lt;code&gt;A&lt;/code&gt;에서 계속 호출되면서 새로운 양 후속문 함수가 계속 캡처되는데, 이렇게 새로 캡처된 양 후속문 함수들은 &lt;code&gt;B1&lt;/code&gt;, &lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt; 라고 표기한다. 또한 방금 위에서 언급한 컨텍스트는 &lt;code&gt;[]&lt;/code&gt;로 표기한다. 따라서 사실 양 함수는 컨텍스트가 있는 클로저이므로 &lt;code&gt;B[&amp;#8230;&amp;#8203;]&lt;/code&gt;로 표기한다. 그리고 &lt;code&gt;@&lt;/code&gt;와 &lt;code&gt;*&lt;/code&gt; 문자가 찍히는 것을 첫 번째 칼럼에 표시하겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이에 따라서 음양 &lt;a href=&quot;#yin-yang&quot;&gt;예제 17&lt;/a&gt; 코드는 다음과 같이 간략하게 표기된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yin-yang-pseudo&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 20. 음양(&lt;a href=&quot;#yin-yang&quot;&gt;예제 17&lt;/a&gt;)을 간략화한 슈도 코드&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@  음 &amp;lt;- new A                &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
*  양 &amp;lt;- new B[음=A]           &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
   (음 양) =&amp;gt; (A B[음=A])      &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;음 후속문 함수 &lt;code&gt;A&lt;/code&gt;가 캡처되어 &lt;code&gt;음&lt;/code&gt;에 저장한다. 문자 &lt;code&gt;@&lt;/code&gt;이 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;양 후속문 함수 &lt;code&gt;B&lt;/code&gt;가 캡처된다. 이때 &lt;code&gt;음=A&lt;/code&gt;라는 컨텍스트 정보가 붙는다. &lt;code&gt;양&lt;/code&gt;에 &lt;code&gt;B[음=A]&lt;/code&gt;가 저장된다. 문자 &lt;code&gt;*&lt;/code&gt;이 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;A&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;B[음=A]&lt;/code&gt; 이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(A B[음=A])&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드는 &lt;a href=&quot;#yin-yang&quot;&gt;예제 17&lt;/a&gt;과 정확하게 같은 의미의 코드이다. 비록 실제 실행되지는 않는 코드이지만 최소한 우리의 분석 목적으로 사용하기에는 좋다. 왜냐하면 이 코드는 &lt;a href=&quot;#yin-yang&quot;&gt;예제 17&lt;/a&gt;과는 달리 양 후속문 함수의 컨텍스트를 나타내고 있기 때문이다. 위에서 언급했다시피 양 후속문 함수 &lt;code&gt;B&lt;/code&gt;는 클로저라서 실행시에 컨텍스트가 실제 무엇인지 파악하는 것이 중요하다. 그래서 이 코드에서는 후속문 함수 &lt;code&gt;B&lt;/code&gt; 바로 뒤에 &lt;code&gt;[]&lt;/code&gt;를 붙여서 컨텍스트를 표기하였다. &lt;code&gt;[]&lt;/code&gt;안에는 함수 &lt;code&gt;B&lt;/code&gt;가 실행시에 필요한 정보를 담는다. 여기서는 이 정보를 &lt;code&gt;음&lt;/code&gt; 지역변수가 음 후속문 함수 &lt;code&gt;A&lt;/code&gt;라는 의미로 &lt;code&gt;음=A&lt;/code&gt;라고 표기하였다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 똑같은 방식으로 &lt;a href=&quot;#yin-cont&quot;&gt;예제 18&lt;/a&gt;의 음 후속문 함수도 다음과 같이 바꿀 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yin-cont-pseudo&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 21. 음 후속문 함수(&lt;a href=&quot;#yin-cont&quot;&gt;예제 18&lt;/a&gt;)를 간략화한 슈도 코드&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@  음 &amp;lt;- v                    &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
*  양 &amp;lt;- new B[음=v]           &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
   (음 양) =&amp;gt; (v B[음=v])      &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;음 후속문 &lt;code&gt;A&lt;/code&gt;가 호출되면, 그 인자는 인수 &lt;code&gt;v&lt;/code&gt;로 들어와서 &lt;code&gt;음&lt;/code&gt;에 저장된다. v 인자 대입법이 적용된다. 문자 &lt;code&gt;@&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;새로운 양 후속문 함수 &lt;code&gt;B&lt;/code&gt;가 캡처되어 &lt;code&gt;양&lt;/code&gt;에 저장된다. 이때 &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;에 의해 &lt;code&gt;음=v&lt;/code&gt;이 &lt;code&gt;B&lt;/code&gt;의 컨텍스트 정보가 된다. &lt;code&gt;B&lt;/code&gt;의 컨텍스트 &lt;code&gt;[]&lt;/code&gt;에 &lt;code&gt;음=v&lt;/code&gt;를 넣는다. 그러므로 &lt;code&gt;양&lt;/code&gt;에 저장되는 것은 &lt;code&gt;B[음=v]&lt;/code&gt;이다. 문자 &lt;code&gt;*&lt;/code&gt;이 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;v&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;B[음=v]&lt;/code&gt; 이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(v B[음=v])&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 음 후속문 함수의 코드에서 새로 캡처되는 양 후속문 함수 &lt;code&gt;B&lt;/code&gt;는 실제 실행될 때마다 그 전에 캡처된 양 후속문 함수와 구별하기 위해 &lt;code&gt;B1&lt;/code&gt;, &lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt;, &amp;#8230;&amp;#8203;로 표기될 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 똑같은 방식으로 &lt;a href=&quot;#yang-cont&quot;&gt;예제 19&lt;/a&gt;의 양 후속문 함수도 다음과 같이 바꿀 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yang-cont-pseudo&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 22. 양 후속문 함수(&lt;a href=&quot;#yang-cont&quot;&gt;예제 19&lt;/a&gt;)를 간략화한 슈도 코드&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   [음=?]             &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
*  양 &amp;lt;- v            &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   (음 양) =&amp;gt; (? v)   &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;양 후속문 함수 &lt;code&gt;B&lt;/code&gt;가 호출되면, 인자는 인수 &lt;code&gt;v&lt;/code&gt;로 들어와서 &lt;code&gt;양&lt;/code&gt;에 저장된다. v 인자 대입법이 적용된다. 문자 &lt;code&gt;*&lt;/code&gt;이 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 양 후속문 &lt;code&gt;B&lt;/code&gt; 호출시의 컨텍스트에서 이미 정해진 값이다. 현재 여기서는 컨텍스트에 무엇이 저장되어 있는지 모르므로 &lt;code&gt;?&lt;/code&gt;로 표기한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;?&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;v&lt;/code&gt;이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(? v)&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 이제 모든 준비가 끝났다. 음양을 구동시켜 보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;#yin-yang-pseudo&quot;&gt;예제 20&lt;/a&gt;의 &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;에서의 호출이 진행되면 어떻게 될까? 음 후속문 함수 &lt;code&gt;A&lt;/code&gt;(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 21&lt;/a&gt;)의 인수 &lt;code&gt;v&lt;/code&gt;에 인자 &lt;code&gt;B[음=A]&lt;/code&gt;가 들어갈 것이다. (v 인자 대입법)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 23. 음 후속문 A(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 21&lt;/a&gt;)를 실행&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@  음 &amp;lt;- B[음=A]                          &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
*  양 &amp;lt;- new B1[음=B[음=A]]               &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
   (음 양) =&amp;gt; (B[음=A] B1[음=B[음=A]])     &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 21&lt;/a&gt;의 인수 &lt;code&gt;v&lt;/code&gt;가 인자 &lt;code&gt;B[음 A]&lt;/code&gt;로 대체된다. v 인자 대입법의 적용이다.  문자 &lt;code&gt;@&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;새로운 양 후속문 &lt;code&gt;B1&lt;/code&gt;이 캡처된다. 이때 &lt;code&gt;음&lt;/code&gt;이 새로 캡처된 후속문 &lt;code&gt;B1&lt;/code&gt;의 컨텍스트 정보이다. 그래서 &lt;code&gt;B1&lt;/code&gt;의 컨텍스트 &lt;code&gt;[]&lt;/code&gt;에 &lt;code&gt;음=B[음=A]&lt;/code&gt;를 넣는다. &lt;code&gt;양&lt;/code&gt;에는 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt;가 저장된다. 문자 &lt;code&gt;*&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;B[음=A]&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt; 이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(B[음=A] B1[음=B[음=A]])&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 이 코드는 &lt;code&gt;B1&lt;/code&gt;을 인자로 해서 &lt;code&gt;B&lt;/code&gt;를 호출한다. 양 후속문 함수 &lt;code&gt;B&lt;/code&gt;(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 22&lt;/a&gt;)가 실행된다. 아래와 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 24. 양 후속문 B(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 22&lt;/a&gt;)를 실행&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   [음=A]                         &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
*  양 &amp;lt;- B1[음=B[음=A]]            &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   (음 양) =&amp;gt; (A B1[음=B[음=A]])   &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;인수 &lt;code&gt;v&lt;/code&gt;가 인자 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt;로 대체된다. v 인자 대입법의 적용이다. 문자 &lt;code&gt;*&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;호출된 후속문 함수인 &lt;code&gt;B&lt;/code&gt;의 컨텍스트 정보이다. 이것은 &lt;code&gt;B&lt;/code&gt;가 만들어질 때, &lt;code&gt;음&lt;/code&gt;이 &lt;code&gt;A&lt;/code&gt;로 설정되었다는 사실을 나타낸다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;A&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt; 이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(A B1[음=B[음=A]])&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 코드는 &lt;a href=&quot;#yin-yang-pseudo&quot;&gt;예제 20&lt;/a&gt;과 똑같이 후속문 함수 &lt;code&gt;A&lt;/code&gt;를 다시 호출한다. 다만 인자가 그 전보다 더 복잡해졌다. 처음에는 인자가 &lt;code&gt;B[음=A]&lt;/code&gt;였는데, 이제는 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt;이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 음 후속문 함수 &lt;code&gt;A&lt;/code&gt;(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 21&lt;/a&gt;)가 다시 아래와 같이 실행된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 25. 음 후속문 A(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 21&lt;/a&gt;)를 실행&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@  음 &amp;lt;- B1[음=B[음=A]]                                   &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
*  양 &amp;lt;- new B2[음=B1[음=B[음=A]]]                         &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
   (음 양) =&amp;gt; (B1[음=B[음=A]] B2[음=B1[음=B[음=A]]])        &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;인수 &lt;code&gt;v&lt;/code&gt;가 인자 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt;로 대체된다. v 인자 대입법의 적용. 문자 &lt;code&gt;@&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;새로운 양 후속문 &lt;code&gt;B2&lt;/code&gt;가 캡처된다. 이때 &lt;code&gt;음&lt;/code&gt;이 새로 캡처된 후속문 &lt;code&gt;B2&lt;/code&gt;의 컨텍스트 정보가 된다. 그래서 &lt;code&gt;B2&lt;/code&gt;의 컨텍스트 &lt;code&gt;[]&lt;/code&gt;에 &lt;code&gt;음=B1[음=B[음=A]]]&lt;/code&gt;를 넣는다. &lt;code&gt;양&lt;/code&gt;에 &lt;code&gt;B2[음=B1[음=B[음=A]]]&lt;/code&gt;가 저장된다. 문자 &lt;code&gt;*&lt;/code&gt;가 찍힌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;음&lt;/code&gt;은 &lt;code&gt;B1[음=B[음=A]]&lt;/code&gt;이고, &lt;code&gt;양&lt;/code&gt;은 &lt;code&gt;B2[음=B1[음=B[음=A]]]&lt;/code&gt; 이므로, 호출 &lt;code&gt;(음 양)&lt;/code&gt;은 &lt;code&gt;(B1[음=B[음=A]] B2[음=B1[음=B[음=A]]])&lt;/code&gt;가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 이제 위 코드에서는 &lt;code&gt;B1&lt;/code&gt;이 호출된다. 그러면 양 후속문 함수(&lt;a href=&quot;#yin-cont-pseudo&quot;&gt;예제 22&lt;/a&gt;)가 실행될 것이다. 이것이 실행되면 예제 24에서처럼 &lt;code&gt;B1&lt;/code&gt;의 컨텍스트가 &lt;code&gt;[음=B[음=A]]&lt;/code&gt;이므로 다음에는 &lt;code&gt;B&lt;/code&gt;가 실행된다. 그리고 &lt;code&gt;B&lt;/code&gt;의 컨텍스트가 &lt;code&gt;[음=A]&lt;/code&gt;이므로 다음에는 &lt;code&gt;A&lt;/code&gt;가 실행된다. 다시 또 A가 실행되는 것이다. 대신 인자는 더 복잡해질 것이다. 그리고 &lt;code&gt;A&lt;/code&gt;가 실행되면서 새로운 후속문 &lt;code&gt;B3&lt;/code&gt;가 만들어질 것이다. &lt;code&gt;B3&lt;/code&gt;의 컨텍스트는 &lt;code&gt;[음=B2[&amp;#8230;&amp;#8203;]]&lt;/code&gt;일 것이다. 또 반복이다. 결국, 이 모든 과정에서 호출되는 후속문들의 연쇄는 아래와 같이 되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt; A -&amp;gt; B -&amp;gt; A -&amp;gt; B1 -&amp;gt; B -&amp;gt; A -&amp;gt; B2 -&amp;gt; B1 -&amp;gt; B -&amp;gt; A -&amp;gt; B3 -&amp;gt; B2 -&amp;gt; B1 -&amp;gt; B ...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 &lt;code&gt;A&lt;/code&gt;를 &lt;code&gt;@&lt;/code&gt;로, &lt;code&gt;B&lt;/code&gt;들은 &lt;code&gt;*&lt;/code&gt;로 바꾸면 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt; @ -&amp;gt; * -&amp;gt; @ -&amp;gt; * -&amp;gt; * -&amp;gt; @ -&amp;gt; * -&amp;gt; * -&amp;gt; * -&amp;gt; @ -&amp;gt; * -&amp;gt; * -&amp;gt; * -&amp;gt; * ...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;전체적인 전개 과정은 다음과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;yin-yang-output&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt; @  음 &amp;lt;- new A
 *  양 &amp;lt;- new B1[음 A]
    (음 양) =&amp;gt; (A B1[음 A])

-------------------------------------------------------------------

 @  음 &amp;lt;- B1[음 A]
 *  양 &amp;lt;- new B2[음 B1[음 A]]
    (음 양) =&amp;gt; (B1[음 A] B2[음 B1[음 A]])

    [음 A]
 *  양 &amp;lt;- B2[음 B1[음 A]]
    (음 양) =&amp;gt; (A B2[음 B1[음 A]])

-------------------------------------------------------------------

 @  음 &amp;lt;- B2[음 B1[음 A]]
 *  양 &amp;lt;- new B3[음 B2[음 B1[음 A]]]
    (음 양) =&amp;gt; (B2[음 B1[음 A]] B3[음 B2[음 B1[음 A]]])

    [음 B1[음 A]]
 *  양 &amp;lt;- B3[음 B2[음 B1[음 A]]]
    (음 양) =&amp;gt; (B1[음 A] B3[음 B2[음 B1[음 A]]])

    [음 A]
 *  양 &amp;lt;- B3[음 B2[음 B1[음 A]]]
    (음 양) =&amp;gt; (A B3[음 B2[음 B1[음 A]]])

-------------------------------------------------------------------

 @  음 &amp;lt;- B3[음 B2[음 B1[음 A]]]
 *  양 &amp;lt;- new B4[음 B3[음 B2[음 B1[음 A]]]]
    (음 양) =&amp;gt; (B3[음 B2[음 B1[음 A]]] B4[음 B3[음 B2[음 B1[음 A]]]])

    [음 B2[음 B1[음 A]]]
 *  양 &amp;lt;- B4[음 B3[음 B2[음 B1[음 A]]]]
    (음 양) =&amp;gt; (B2[음 B1[음 A]] B4[음 B3[음 B2[음 B1[음 A]]]])

    [음 B1[음 A]]
 *  양 &amp;lt;- B4[음 B3[음 B2[음 B1[음 A]]]]
    (음 양) =&amp;gt; (B1[음 A] B4[음 B3[음 B2[음 B1[음 A]]]])

    [음 A]]
 *  양 &amp;lt;- B4[음 B3[음 B2[음 B1[음 A]]]]
    (음 양) =&amp;gt; (A B4[음 B3[음 B2[음 B1[음 A]]]])&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;yin-yang 예제는 후속문 프로그래밍이 어떻게 힘을 발휘하게 되는지를 보여준다. 하지만 이 예제는 그리 실용적이지 않다. 이젠 후속문 프로그래밍의 막강한 힘이 어떻게 유용하게 사용되는지 볼 차례가 되었다. 후속문 프로그래밍의 힘은 기존에는 없었던 제어 흐름 구조를 만들어 낼 수 있다는 점이다. 바로 이런 점을 보여주는 예로 비결정적 선택이라는 예제를 볼 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_비결정적_선택_nondeterministic_choice&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_비결정적_선택_nondeterministic_choice&quot;&gt;&lt;/a&gt;2.11. 비결정적 선택(Nondeterministic Choice)&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴퓨터 공학에서 비결정성(Nondeterminism)&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_12&quot; class=&quot;footnote&quot; href=&quot;#_footnote_12&quot; title=&quot;View footnote.&quot;&gt;12&lt;/a&gt;]&lt;/sup&gt; 이란 프로그램의 제어가 어디로 가게 될 지를 사전에 알 수 없고, 런타임에 임의로 그 흐름이 결정되는 것을 말한다. 즉 랜덤값이 아니라 랜덤제어흐름이다. 비결정성의 대표적인 것이 스레드이다. 선점형 스레딩 모델에서 한 스레드에서 다른 스레드로 제어가 넘어가는 것은 비결정적이다. 스레드의 이런 비결정성을 프로그래머가 처리하도록 한 것은 최악의 선택이었다. 스레드는 비결정성이 잘못 도입된 대표적인 예이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 때로는 비결정성의 도입이 문제 해결에 더 좋은 방법을 제공하기도 한다. 이런 경우에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nondeterministic_algorithm&quot;&gt;비결정적 알고리즘&lt;/a&gt;(Nondeterministic algorithm)이라는 방식을 사용한다. 보통 알고리즘은 주어진 입력에서 출력까지에 이르는 하나의 로직의 흐름이라고 할 수 있다. 즉 입력이 주어지면 하나의 로직 경로를 거쳐서 하나의 출력이 나온다는 점에서 결정론적이다. 결정론적 알고리즘에서 중요한 것은 그 하나의 로직 경로를 잘 설계하는 것이다. 반면 비결정적 알고리즘은 하나의 로직 경로를 설계하는데 관심을 두지 않는다. 대신 하나의 입력에서 나올 수 있는 가능한 모든 출력에 이르는 경로들을 탐색하면서, 해당 출력들 중에서 정답을 선택한다. 비결정적 알고리즘은 결국 모든 해를 준비해놓고 각 해가 맞는지 틀리는지만 정해주는 방식이다. 그래서 비결정적 알고리즘에서 중요한 것은 하나의 해를 찾는 로직이 아니라 모든 가능한 해를 탐색하는 로직이 중요하다. 그 탐색에서 우리는 어느 것이 정답인지를 선택하면 된다. 비유를 하자면 결정적 알고리즘은 도끼 찾으러 호수 속으로 직접 뛰어 들어가는 것이다. 이때 중요한 것은 도끼까지의 경로이다. 반면 비결정적 알고리즘은 호수 속 모든 도끼를 찾을 수 있는 산신령이 나타나 하나씩 '이 도끼가 네 도끼냐?'하고 물으면 '제 도끼가 아닙니다&amp;#8217;라거나 '제 도끼가 맞습니다&amp;#8217;라고 말하면서 금도끼&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_13&quot; class=&quot;footnote&quot; href=&quot;#_footnote_13&quot; title=&quot;View footnote.&quot;&gt;13&lt;/a&gt;]&lt;/sup&gt;를 선택하는 것이다. 여기서 중요한 것은 모든 도끼를 가져올 수 있는 산신령이다. 이 산신령만 있다면 선택하는 것은 매우 쉬우니 도끼 찾는 일은 식은 죽 먹기가 된다. 그럼, 이 산신령을 어떻게 만들어 낼 수 있을까? 관건은 탐색을 자동화하는 것이다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_14&quot; class=&quot;footnote&quot; href=&quot;#_footnote_14&quot; title=&quot;View footnote.&quot;&gt;14&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;비결정적 알고리즘은 2가지 로직으로 구성된다. 하나는 전체 해를 찾는 자동화된 탐색 로직이고, 다른 하나는 선택하는 로직이다. 전자가 산신령이라면, 후자는 나무꾼이다. 나무꾼이 하는 일은 금도끼인지 아닌지만 테스트하는 아주 쉬운 일이다(튼튼한 이빨과 질산만 있으면 된다). 산신령이 하는 일은 호수 속의 모든 도끼를 빠짐없이 하나씩 찾아서 나무꾼에게 보여주는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 주어진 자연수 집합에서 피타고라스 수를 비결정적 방식으로 찾는 코드이다. 예상했겠지만 자연수를 탐색하는 로직을 만드는데 역시 후속문을 사용한다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_15&quot; class=&quot;footnote&quot; href=&quot;#_footnote_15&quot; title=&quot;View footnote.&quot;&gt;15&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;nondeterministic-choices&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 26. 비결정적 선택(Nondeterministic Choices)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define (cc)  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    (call/cc (lambda (k) k)))

  (define fail-stack '())  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;

  (define (push-k k)
    (set! fail-stack (cons k fail-stack)))

  (define (pop-k)
    (let ((k (car fail-stack)))
      (set! fail-stack (cdr fail-stack))
     k))

  (define (fail)  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    (if (empty? fail-stack)
      (error &quot;backtracking stack exhausted!&quot;)
      (begin
        (let ((backtrack-point (pop-k)))
          (backtrack-point backtrack-point)))))

  (define (amb choices)  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
    (let ((k (cc)))
      (if (empty? choices)
        (fail)
        (let ((choice (car choices)))
          (set! choices (cdr choices))
          (push-k k)
          choice))))

  (define (assert condition)  &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
    (if (not condition)
      (fail)
      #t))

  (let ((a (amb (list 1 2 3 4 5 6 7)))    &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
        (b (amb (list 1 2 3 4 5 6 7)))    &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;(7)&lt;/b&gt;
        (c (amb (list 1 2 3 4 5 6 7))))   &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;&lt;b&gt;(8)&lt;/b&gt;
    (assert (= (* c c) (+ (* a a) (* b b))))  &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;(9)&lt;/b&gt;
    (println (list a b c)))

  ;&amp;gt;&amp;gt; (3 4 5)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cc&lt;/code&gt; 함수는 현재 시점에서의 후속문 함수를 반환한다. 앞에서 설명했던 후속문 이디엄을 함수화한 것이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fail-stack&lt;/code&gt;은 후속문 함수들을 담는 스택이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fail&lt;/code&gt; 함수는 &lt;code&gt;fail-stack&lt;/code&gt;에서 후속문 함수 하나를 꺼내서 실행한다. 없으면 예외를 던진다. 호출시에 이 후속문 함수의 인자는 자기 자신이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;amb&lt;/code&gt; 함수는 후속문 함수를 생성해서 &lt;code&gt;fail-stack&lt;/code&gt;에 넣는다. 그리고 인수 choices 리스트에서 요소 하나를 꺼내 리턴한다. 리스트가 소진되면 &lt;code&gt;fail&lt;/code&gt; 함수를 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;assert&lt;/code&gt; 함수는 인수로 받은 &lt;code&gt;condition&lt;/code&gt;이 거짓이면 &lt;code&gt;fail&lt;/code&gt; 함수를 호출한다. 참이면 &lt;code&gt;#t&lt;/code&gt;를 리턴한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(list 1 2 3 4 5 6 7)&lt;/code&gt;을 비결정적 선택으로 만든다. &lt;code&gt;a&lt;/code&gt;는 비결정적 요소가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;7&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(list 1 2 3 4 5 6 7)&lt;/code&gt;을 비결정적 선택으로 만든다. &lt;code&gt;b&lt;/code&gt;는 비결정적 요소가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;&lt;b&gt;8&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(list 1 2 3 4 5 6 7)&lt;/code&gt;을 비결정적 선택으로 만든다. &lt;code&gt;c&lt;/code&gt;는 비결정적 요소가 된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;9&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;피타고라스 수가 되는 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;를 선택한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 코드에서 재밌는 부분은 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;이다. 먼저 이 코드들을 해석해보자. 의미론적으로.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;우선 핵심은 &lt;code&gt;amb&lt;/code&gt; 함수&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_16&quot; class=&quot;footnote&quot; href=&quot;#_footnote_16&quot; title=&quot;View footnote.&quot;&gt;16&lt;/a&gt;]&lt;/sup&gt;이다.  이 함수는 리스트를 받아서 호출시마다 리스트의 요소를 하나씩 리턴한다. 함수의 내부 구현은 그렇게 되어 있지만, 의미론적 관점에서는 다르게 해석해야 한다. 이 함수가 리턴한 것은 그냥 리스트의 요소가 아니라, 인수로 받은 리스트의 요소 중 어느 것이다. 그런데 그 어느 것이 결정된 것은 아니다. 리스트의 요소 중 어느 것이 나올지는 모른다. 혼재되어 있다. 그래서 'ambiguous&amp;#8217;이다. 위 코드의 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;에서 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 각각은 1~7의 숫자 중에서 임의의 하나를 나타낸다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;는 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;중 피타고라스 수의 조건에 맞는 실제의 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 값을 결정한다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;는 원래 1~7의 숫자 중에서 어떤 값으로도 결정되지 않은 상태인데, &lt;code&gt;assert&lt;/code&gt; 함수의 조건을 만나는 순간 그 조건에 맞는 값들로 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;가 결정되는 것이다. 이것은 마치 양자역학에서 한 입자가 측정하기 전까지는 어떤 값으로도 결정되지 않은 양자 상태에 있다가 측정을 하는 순간 하나의 값으로 상태가 결정되는 것과 같다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt; ~ &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt; 까지의 코드를 보면, 그냥 문제를 기술한 것으로 보인다. 즉 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;는 각각 1~7까지의 숫자이다. &lt;code&gt;c&lt;/code&gt;가 빗변이라고 할 때 피타고라스 수가 되는 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;를 구하라. 환상적이지 않나? 어떻게 이게 가능한가? 산신령이 나셨기 때문&amp;#8230;&amp;#8203;.이 아니고.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기까지가 의미론적 해석이다. 이것이 작동하려면 결국 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;의 값들의 조합이 생성되어 &lt;code&gt;assert&lt;/code&gt; 함수가 실행되는데, 실패하면 다시 새로운 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;의 값들의 조합을 가져와서 &lt;code&gt;assert&lt;/code&gt; 함수가 성공할 때까지 실행되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 위의 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;이 탐색 로직이고 &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;가 선택 로직이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 로직은 다음과 같이 동작한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;에서 리스트가 비었으면 초기화한다(리스트 a라고 하자). 있으면 요소 하나를 꺼내 &lt;code&gt;a&lt;/code&gt;에 넣는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;에서 리스트가 비었으면 초기화한다(리스트 b라고 하자). 있으면 요소 하나를 꺼내 &lt;code&gt;b&lt;/code&gt;에 넣는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;에서 리스트가 비었으면 초기화한다(리스트 c라고 하자). 있으면 요소 하나를 꺼내 &lt;code&gt;c&lt;/code&gt;에 넣는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;에서 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;에 대해 &lt;code&gt;assert&lt;/code&gt; 함수를 수행한다.&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;실패이면 3으로 간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성공이면 &lt;code&gt;println&lt;/code&gt; 하고 종료.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3~4가 반복된다. 리스트 c가 소진될 때까지.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리스트 c가 소진되면 2로 간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2~6가 반복된다. 리스트 b가 소진될 때까지.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리스트 b가 소진되면 1로 간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1~7가 반복된다. 리스트 a가 소진될 때까지.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위의 과정으로 탐색이 수행되면서 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;는 (1 1 1), (1 1 2), (1 1 3)&amp;#8230;&amp;#8203;(7 7 6), (7 7 7)까지 모든 가능한 해를 지니게 된다. 그중에서 &lt;code&gt;assert&lt;/code&gt; 함수에 주어진 조건에 맞는 것을 선택하게 되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위의 과정을 보면 제어가 &lt;code&gt;assert&lt;/code&gt; 함수 실패시에는 &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;로, c 리스트가 소진되면 &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;로, b 리스트가 소진되면 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;으로 이동하는 것을 볼 수 있다. 이렇게 제어를 이동시키는 역할을 하는 것이 &lt;code&gt;fail&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;fail&lt;/code&gt; 함수는 제어를 관리하기 위해 &lt;code&gt;fail-stack&lt;/code&gt;을 이용한다. &lt;code&gt;fail-stack&lt;/code&gt;은 &lt;code&gt;amb&lt;/code&gt; 함수에서 만들어진 후속문 함수를 담고 있다. &lt;code&gt;fail&lt;/code&gt; 함수는 &lt;code&gt;fail-stack&lt;/code&gt;에서 마지막으로 들어간 후속문 함수를 꺼내서 실행한다. 이 말은 곧 그 후속문 함수가 생성된 곳으로 제어를 옮긴다는 의미다. 그래서 &lt;code&gt;fail-stack&lt;/code&gt;에서 꺼낸 후속문 함수를 받는 지역 변수 이름이 &lt;code&gt;backtrack-point&lt;/code&gt;인 것이다. 그리고 인자도 함께 넘기는데 &lt;code&gt;backtrack-point&lt;/code&gt; 자기 자신이다. 이렇게 제어와 인자가 넘겨지는 곳은 &lt;code&gt;amb&lt;/code&gt; 함수 내의 &lt;code&gt;cc&lt;/code&gt; 함수가 호출된 자리이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;amb&lt;/code&gt; 함수가 하는 일은 지역변수 &lt;code&gt;k&lt;/code&gt;에 바인딩된 후속문 함수를 &lt;code&gt;fail-stack&lt;/code&gt;에 넣고, &lt;code&gt;choices&lt;/code&gt;에서 꺼낸 수를 리턴하는 것이다. &lt;code&gt;amb&lt;/code&gt; 함수는 사실 2가지 경로로 실행된다. 하나는 &lt;code&gt;amb&lt;/code&gt; 함수를 호출하면서 실행되는 경로이고, 다른 하나는 후속문 함수의 호출로 제어가 &lt;code&gt;amb&lt;/code&gt; 함수로 넘어오면서 실행되는 경로이다. 이 2가지 경로에 따라 인수 &lt;code&gt;choices&lt;/code&gt;도 달라지고, 지역변수 &lt;code&gt;k&lt;/code&gt;에 후속문 함수가 바인딩되는 방식도 달라진다. &lt;code&gt;amb&lt;/code&gt; 함수를 호출하는 경우에는 인수 &lt;code&gt;choices&lt;/code&gt;에는 새로운 인자 &lt;code&gt;(list 1 2 3 4 5 6 7)&lt;/code&gt;이 들어와서 초기화되고, 지역 변수 &lt;code&gt;k&lt;/code&gt;에는 &lt;code&gt;cc&lt;/code&gt; 함수에 의해 새로 캡처된 후속문 함수가 바인딩된다. 하지만 이 후속문 함수가 &lt;code&gt;fail&lt;/code&gt; 함수에 의해 호출되면서 제어가 다시 &lt;code&gt;amb&lt;/code&gt; 함수로 넘어오는 경우에는 &lt;code&gt;choices&lt;/code&gt;는 기존값을 계속 사용하게 되고, 지역 변수 &lt;code&gt;k&lt;/code&gt;에도 기존 후속문 함수가 바인딩된다. 그래서 제어가 &lt;code&gt;fail&lt;/code&gt; 함수에서 &lt;code&gt;amb&lt;/code&gt; 함수로 넘어올 때마다 &lt;code&gt;choices&lt;/code&gt;는 하나씩 자신의 원소를 꺼내게 되어 계속 줄어들게 되고, &lt;code&gt;fail-stack&lt;/code&gt;은 pop 되었던 기존 후속문 함수가 다시 push 되면서 이전과 똑같아진다. 이로써 &lt;code&gt;amb&lt;/code&gt; 함수 이후의 코드(예를 들어 &lt;code&gt;assert&lt;/code&gt; 함수)는 다른 모든 것은 똑같은 채 단지 &lt;code&gt;choices&lt;/code&gt;에서 꺼내온 다음 요소로 실행되게 된다. 그러다가 &lt;code&gt;choices&lt;/code&gt;가 소진되면 &lt;code&gt;amb&lt;/code&gt; 함수는 &lt;code&gt;fail&lt;/code&gt; 함수를 호출한다. 하지만 &lt;code&gt;fail-stack&lt;/code&gt;에는 다른 후속문 함수가 들어있으므로 &lt;code&gt;fail&lt;/code&gt; 함수는 다른 곳으로 제어를 옮긴다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 전체 동작이 어떻게 이루어지는지 하나씩 살펴보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;먼저 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;을 보자. &lt;code&gt;amb&lt;/code&gt;함수가 실행되면서 &lt;code&gt;cc&lt;/code&gt; 함수가 캡처한 후속문 함수를 &lt;code&gt;fail-stack&lt;/code&gt;에 넣는다. 이 후속문 함수를 a 후속문 함수라고 하자. 그리고 리스트에서 요소 하나를 꺼내서 리턴한다. 그래서 &lt;code&gt;a&lt;/code&gt;는 1이 된다. 이제 &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;에서도 마찬가지로 &lt;code&gt;amb&lt;/code&gt; 함수가 실행되면서 b 후속문 함수가 &lt;code&gt;fail-stack&lt;/code&gt;에 들어가고, 리스트에서 요소 하나를 빼와서 리턴한다. 그래서 &lt;code&gt;b&lt;/code&gt;는 1이 된다. &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;에서도 마찬가지로 c 후속문 함수가 스택에 들어가고, &lt;code&gt;c&lt;/code&gt;는 1이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그 다음으로 &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;의 &lt;code&gt;assert&lt;/code&gt; 함수가 처음 실행되는데, 이때 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;는 각각 1, 1, 1이다. &lt;code&gt;assert&lt;/code&gt; 함수는 조건이 참이 아니라서 &lt;code&gt;fail&lt;/code&gt; 함수를 실행하게 된다. 위에서 언급했다시피 &lt;code&gt;fail&lt;/code&gt; 함수는 제어를 관리한다. &lt;code&gt;fail&lt;/code&gt; 함수는 &lt;code&gt;fail-stack&lt;/code&gt;에 가장 마지막에 들어간 c 후속문 함수를 꺼내서 실행한다. 그래서 제어는 &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt; 로 이동한다. &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;의 &lt;code&gt;amb&lt;/code&gt; 함수가 수행되면서 인자로 전달된 c 후속문 함수는 다시 &lt;code&gt;fail-stack&lt;/code&gt;에 들어가고, c 리스트에서 2를 꺼내서 &lt;code&gt;c&lt;/code&gt;에 바인딩한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다시 &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;의 &lt;code&gt;assert&lt;/code&gt; 함수가 실행되는데, 이젠 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;가 각각 1, 1, 2이다. 이번에도 &lt;code&gt;assert&lt;/code&gt; 함수가 실패하면서 다시 &lt;code&gt;fail&lt;/code&gt; 함수가 실행된다. &lt;code&gt;fail&lt;/code&gt; 함수는 바로 위의 과정을 또 반복하면서 &lt;code&gt;c&lt;/code&gt;는 이제 3이 된다. 이런 과정은 c의 리스트가 소진될 때까지 반복 진행된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;c의 리스트가 소진되면 &lt;code&gt;amb&lt;/code&gt;는 &lt;code&gt;fail&lt;/code&gt; 함수를 호출한다. &lt;code&gt;fail&lt;/code&gt; 함수는 &lt;code&gt;fail-stack&lt;/code&gt;에서 마지막 요소를 꺼내 실행하는데, 그게 이번에는 b 후속문 함수이다. 제어는 이번에는 &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;로 이동하는 것이다. &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;의 &lt;code&gt;amb&lt;/code&gt; 함수가 수행되면서 b 후속문 함수는 다시 &lt;code&gt;fail-stack&lt;/code&gt;에 들어가고, b 리스트에서 2를 꺼내 &lt;code&gt;b&lt;/code&gt;에 바인딩한다. 다음으로 &lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;의 &lt;code&gt;amb&lt;/code&gt; 함수가 실행되면서 c 후속문 함수가 다시 생성되어 &lt;code&gt;fail-stack&lt;/code&gt;에 들어가고, c는 1이 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다시 &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;의 &lt;code&gt;assert&lt;/code&gt; 함수가 실행되는데, 이젠 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;가 각각 1, 2, 1이다. 역시 &lt;code&gt;assert&lt;/code&gt; 함수가 실패하면서 c의 리스트가 소진된 때까지의 과정이 반복된다. c의 리스트가 소진되어서 제어는 다시 &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;로 이동하고 &lt;code&gt;b&lt;/code&gt;는 이제 3이 되어 바로 위의 과정을 다시 반복하게 된다. &lt;code&gt;b&lt;/code&gt;가 소진될 때까지.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이런 과정은 b 리스트가 소진되어 제어가 &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;으로 이동하는 과정까지 반복된다. 이제 &lt;code&gt;a&lt;/code&gt;가 2가 된다. &lt;code&gt;assert&lt;/code&gt; 함수는 2, 1, 1에 대해 테스트한다. 그러다가&lt;code&gt;assert&lt;/code&gt;의 조건이 참이 되는 때에 중단하게 되는데 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 가 각각 3, 4, 5가 될 때이다. &lt;code&gt;assert&lt;/code&gt;가 참이 되어 제어는 바로 뒤의 &lt;code&gt;println&lt;/code&gt; 문으로 이동해서 &lt;code&gt;(3 4 5)&lt;/code&gt;를 찍고 종료된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 call/cc를 이용하여 amb 함수를 만들어서 비결정적 선택 방식으로 피타고라스 수를 찾는 예제를 살펴보았다. 위 예제에서 &lt;code&gt;(3 4 5)&lt;/code&gt; 이외의 다른 해를 찾고 싶다면 &lt;code&gt;fail&lt;/code&gt; 함수를 호출하면 된다. 맨 마지막 라인 &lt;code&gt;(println (list a b c)))&lt;/code&gt; 식 아래에 &lt;code&gt;(fail)&lt;/code&gt; 코드를 넣고, 다시 그 아래 &lt;code&gt;(println (list a b c)))&lt;/code&gt;를 넣고 실행해보자. 그러면 &lt;code&gt;(3 4 5)&lt;/code&gt;와 &lt;code&gt;(4 3 5)&lt;/code&gt;가 찍히는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 아마도 독자들은 for 문을 이용하면 같은 결과를 낼 수 있다는 것을 알 수 있을 것이다. 삼중 for 문을 하면 정확히 같은 결과가 나온다. 그런데 왜 굳이 amb를 만들었을까? 사실 amb는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Backtracking:&quot;&gt;Backtracking&lt;/a&gt;이라는 기법을 지원하기 위한 제어구조이다. Planner라는 프로그래밍 언어는 amb를 제어구조로서 언어 차원에서 지원한다. Backtracking 기능을 이용하면 논리 프로그래밍이 가능해진다. 실제로 논리 프로그래밍 언어인 Prolog가 이에 기반해 있다. amb에 대한 더 많은 정보를 얻고 싶다면 비결정성(Nondeterminism)을 다루는 &lt;a href=&quot;http://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3:&quot;&gt;SICP 4.3 절&lt;/a&gt;과 &lt;a href=&quot;http://www.paulgraham.com/onlisp.html:&quot;&gt;On Lisp&lt;/a&gt;의 22장을 보기 바란다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_코루틴&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_코루틴&quot;&gt;&lt;/a&gt;2.12. 코루틴&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코루틴은 서브루틴과 비교된다. 보통 코루틴을 일반화된 서브루틴이라고 한다. 반대로 서브루틴은 코루틴의 특수한 버전이라고 할 수 있다. 코루틴이 서브루틴보다 더 포괄적인 개념인 것이다. 어떤 점에서 그럴까? 서브루틴은 진입점이 서브루틴의 처음으로 고정되어 있지만, 코루틴은 진입점이 고정되어 있지 않아, 코루틴의 어느 곳이나 진입점이 될 수 있다는 점에서 그렇다. 진입점이란 호출자로부터 피호출자가 제어를 넘겨받는 곳을 말한다. 호출자가 서브루틴을 호출하면 제어는 서브루틴의 처음으로 넘어간다. 서브루틴의 진입점은 서브루틴의 처음이며, 그리고 바로 그것 하나뿐이다. 코루틴도 호출자가 호출하면 코루틴의 처음으로 제어가 이동한다. 하지만 코루틴은 코루틴의 처음이 아닌 코루틴의 어느 곳에서도 제어를 넘겨받을 수 있는 도구가 따로 있다. 이 도구를 사용하면 코루틴은 진입점이 여러 개가 될 수 있다. 바로 이런 점에서 코루틴이 서브루틴보다 더 포괄적이라고 하는 것이다. 반대로 서브루틴은 진입점이 함수의 처음에만 있는 특수한 코루틴이라고 할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그렇다면 코루틴의 진입점을 여러 개 만들 수 있게 하는 그 도구가 무엇일까? 그것은 yield 문이다. yield 문은 return 문과 비교되는데, 둘 다 제어를 호출자에게 넘긴다는 점에서 같다. 하지만 return 문과 달리 yield 문은 제어를 넘기는 그 자리를 진입점으로 만든다. 그래서 나중에 그 진입점으로 다시 제어가 돌아올 수 있다. 어떤 코루틴 A가 yield를 하면 제어가 다른 코루틴 B로 넘어가는데, 코루틴 B가 제어를 받아 처리하다가 yield를 하면, 이번에는 제어가 코루틴 A가 yield했던 자리로 넘어가는 것이다. 이런 식으로 코루틴 A와 B가 서로의 실행의 중간 지점들에서 제어를 주거니 받거니 할 수 있는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코루틴의 이런 특성 때문에 코루틴은 협력적 스레딩(Cooperative threading)에 사용될 수 있다. 코루틴끼리 서로 제어를 주거니 받거니 하면서 필요한 작업을 협력적으로 수행할 수 있기 때문이다. 서로 협력적으로 일하니 리소스 경쟁이 없고, 경쟁이 없으니 뮤텍스나 세마포어 같은 동기화 장치를 쓸 필요도 없다. 그래서 동시성 프로그래밍이 매우 단순해진다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;yield에 대해 가만히 생각해보자. yield에 의해 제어를 넘겨받은 코루틴에게는 그 yield 이후의 코드는 후속문이 된다. 왜냐하면 제어를 넘겨받은 코루틴이 실행된 이후에 실행될 코드가 yield 이후의 코드이기 때문이다. 그래서 코루틴을 후속문으로 구현하는 것이 가능해진다. 즉 yield 뒤에 있는 코드를 캡처해서 후속문 함수로 만들고, 나중에 그 후속문 함수를 호출하면서 제어를 넘길 수 있기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음은 코루틴을 후속문으로 구현한 예제이다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_17&quot; class=&quot;footnote&quot; href=&quot;#_footnote_17&quot; title=&quot;View footnote.&quot;&gt;17&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;coroutine&quot; class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;예제 27. 코루틴&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-racket&quot; data-lang=&quot;racket&quot;&gt;  (define thread-queue '())  &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

  (define (enqueue thread)
    (set! thread-queue (append thread-queue (list thread))))

  (define (dequeue)
    (let ((thread (car thread-queue)))
      (set! thread-queue (cdr thread-queue))
      thread))

  (define halt #f)  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;

  (define (cc)  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    (call/cc (lambda (k) k)))

  (define (spawn thunk)  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
    (let ((k (cc)))
      (if (procedure? k)
        (enqueue k)
        (begin (thunk)
  	     (quit)))))

  (define (yield)  &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
    (let ((k (cc)))
      (if (and (procedure? k) (not (empty? thread-queue)))
        (let ((next-thread (dequeue)))
  	(enqueue k)
  	(next-thread 'resume))
        (void))))

  (define (quit)  &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;
    (if (empty? thread-queue)
      (halt)
      (let ((next-thread (dequeue)))
        (next-thread 'resume))))

  (define (start-threads)  &lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;(7)&lt;/b&gt;
    (let ((k (cc)))
      (if k
        (begin
  	(set! halt (lambda () (k #f)))
  	(if (empty? thread-queue)
  	  (void)
  	  (begin
  	    (let ((next-thread (dequeue)))
  	      (next-thread 'resume)))))
        (void))))


  ;; 제어를 서로 주거니 받거니 하면서 협력하는 스레드 예제
  (define counter 10)

  (define (make-thread-thunk name)
    (letrec ((loop (lambda ()
  		   (if (&amp;lt; counter 0)
  		     (quit)
  		     (begin
  		       (printf &quot;in thread ~a; counter = ~a\n&quot; name counter)
  		       (set! counter (- counter 1))
  		       (yield)
  		       (loop))))))
  	   loop))

  (spawn (make-thread-thunk 'a))  &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;(9)&lt;/b&gt;
  (spawn (make-thread-thunk 'b))  &lt;i class=&quot;conum&quot; data-value=&quot;10&quot;&gt;&lt;/i&gt;&lt;b&gt;(10)&lt;/b&gt;
  (spawn (make-thread-thunk 'c))  &lt;i class=&quot;conum&quot; data-value=&quot;11&quot;&gt;&lt;/i&gt;&lt;b&gt;(11)&lt;/b&gt;
  (start-threads)  &lt;i class=&quot;conum&quot; data-value=&quot;12&quot;&gt;&lt;/i&gt;&lt;b&gt;(12)&lt;/b&gt;

  ;=&amp;gt; in thread a; counter = 10
  ;=&amp;gt; in thread b; counter = 9
  ;=&amp;gt; in thread c; counter = 8
  ;=&amp;gt; in thread a; counter = 7
  ;=&amp;gt; in thread b; counter = 6
  ;=&amp;gt; in thread c; counter = 5
  ;=&amp;gt; in thread a; counter = 4
  ;=&amp;gt; in thread b; counter = 3
  ;=&amp;gt; in thread c; counter = 2
  ;=&amp;gt; in thread a; counter = 1
  ;=&amp;gt; in thread b; counter = 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;스레드를 넣고 빼는 큐를 정의한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;halt&lt;/code&gt;는 모든 실행을 중단하는 함수로 설정될 것이다. 현재는 &lt;code&gt;#f&lt;/code&gt;이지만 나중에 할당된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cc&lt;/code&gt; 함수는 후속문 이디엄을 함수화한 것이다. 위에서 설명되었던 바이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;spawn&lt;/code&gt; 함수를 정의한다. 지역변수 &lt;code&gt;k&lt;/code&gt;가 함수이면 그것을 스레드 큐에 넣고, 아니면 &lt;code&gt;thunk&lt;/code&gt; 인수로 주어진 함수를 실행한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;yield&lt;/code&gt; 함수는 yield의 구현이다. 스레드 큐에서 스레드를 하나 꺼내서 제어를 넘기고, 현재 시점의 후속문을 캡처해서 스레드 큐에 넣는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;quit&lt;/code&gt; 함수를 정의한다. 스레드 큐가 비었으면 &lt;code&gt;halt&lt;/code&gt;를 해서 모든 실행을 중단한다. 아니면 큐에서 스레드 하나를 꺼내서 실행한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;7&quot;&gt;&lt;/i&gt;&lt;b&gt;7&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;start-threads&lt;/code&gt; 함수는 스레드들을 시작시킨다. 스레드 큐에서 하나씩 꺼내서 실행한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;8&quot;&gt;&lt;/i&gt;&lt;b&gt;8&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make-threads-thunk&lt;/code&gt; 함수는 스레드를 만드는 함수이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;&lt;b&gt;9&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;스레드 &lt;code&gt;a&lt;/code&gt;를 만들어서 스레드 큐에 넣는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;10&quot;&gt;&lt;/i&gt;&lt;b&gt;10&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;스레드 &lt;code&gt;b&lt;/code&gt;를 만들어서 스레드 큐에 넣는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;11&quot;&gt;&lt;/i&gt;&lt;b&gt;11&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;스레드 &lt;code&gt;c&lt;/code&gt;를 만들어서 스레드 큐에 넣는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;12&quot;&gt;&lt;/i&gt;&lt;b&gt;12&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;전체 스레드를 구동한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;start-threads&lt;/code&gt; 함수부터 보자. &lt;code&gt;cc&lt;/code&gt; 함수로 후속문 함수를 캡처해서 지역변수 &lt;code&gt;k&lt;/code&gt;에 바인딩한다. &lt;code&gt;if&lt;/code&gt; 문에서 &lt;code&gt;k&lt;/code&gt;가 참이 되므로 &lt;code&gt;begin&lt;/code&gt; 문이 실행된다. &lt;code&gt;halt&lt;/code&gt; 변수에 후속문 함수 &lt;code&gt;k&lt;/code&gt;를 인자 &lt;code&gt;#f&lt;/code&gt;로 호출하는 람다 함수로 설정한다. 그러고나서 스레드 큐를 검사하는데, 비었으면 &lt;code&gt;void&lt;/code&gt; 함수를 호출한다. &lt;code&gt;void&lt;/code&gt; 함수는 &lt;code&gt;#&amp;lt;void&amp;gt;&lt;/code&gt;를 리턴하는데 마치 아무것도 리턴하지 않는 효과를 갖는다. 그래서 &lt;code&gt;start-thread&lt;/code&gt; 함수는 리턴값없이 리턴한다. 스레드 큐가 비어있지 않으면 스레드 하나를 꺼내서 &lt;code&gt;'resume&lt;/code&gt;을 인자로 해서 실행한다. 현재는 &lt;code&gt;spawn&lt;/code&gt; 함수에 의해서 스레드 큐에 스레드가 들어가 있기 때문에 &lt;code&gt;start-thread&lt;/code&gt;는 바로 끝나지 않는다. 만약 &lt;code&gt;k&lt;/code&gt;를 검사하는 &lt;code&gt;if&lt;/code&gt; 문에서 &lt;code&gt;k&lt;/code&gt;가 거짓이면 역시 &lt;code&gt;void&lt;/code&gt; 함수를 호출해서 &lt;code&gt;start-thread&lt;/code&gt; 함수는 리턴없이 끝나게 된다. 방금 설정했던 &lt;code&gt;halt&lt;/code&gt; 함수가 &lt;code&gt;start-thread&lt;/code&gt; 함수에서 캡처했던 후속문 함수 &lt;code&gt;k&lt;/code&gt;를 &lt;code&gt;#f&lt;/code&gt;를 인자로 해서 호출하고 있다. 따라서 &lt;code&gt;halt&lt;/code&gt; 함수 호출하면 &lt;code&gt;start-tread&lt;/code&gt; 함수가 끝나게 된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음으로 &lt;code&gt;spawn&lt;/code&gt; 함수를 보자. &lt;code&gt;cc&lt;/code&gt; 함수로 후속문을 캡처해서 지역변수 &lt;code&gt;k&lt;/code&gt;에 바인딩한다. 지역변수 &lt;code&gt;k&lt;/code&gt;를 &lt;code&gt;procedure?&lt;/code&gt; 함수로 함수 여부를 검사한다. 후속문 함수는 프로시저이므로 스레드 큐에 들어가게 된다. &lt;code&gt;k&lt;/code&gt;가 &lt;code&gt;procedure?&lt;/code&gt; 검사에서 실패하는 경우는 &lt;code&gt;spawn&lt;/code&gt; 함수가 방금 캡처한 후속문 함수가 아닌 다른 인자로 호출될 때이다. 그때는 &lt;code&gt;thunk&lt;/code&gt; 함수를 실행한다. &lt;code&gt;thunk&lt;/code&gt; 함수는 &lt;code&gt;make-thread-thunk&lt;/code&gt; 함수에서 리턴된 &lt;code&gt;loop&lt;/code&gt;이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;make-thread-thunk&lt;/code&gt; 함수는 람다 함수를 만들어 지역변수 &lt;code&gt;loop&lt;/code&gt;에 할당하는데, 이 람다 함수 끝에서 &lt;code&gt;loop&lt;/code&gt;을 다시 호출하고 있기 때문에 이 람다 함수는 재귀호출함수가 된다. &lt;code&gt;make-thread-thunk&lt;/code&gt; 함수는 이 재귀호출함수 &lt;code&gt;loop&lt;/code&gt;을 리턴한다. &lt;code&gt;loop&lt;/code&gt; 함수가 실행되면 &lt;code&gt;display&lt;/code&gt; 함수를 호출해서 프린트한다. 그러고나서 다시 &lt;code&gt;loop&lt;/code&gt;을 호출해서 재귀하기 전에 &lt;code&gt;yield&lt;/code&gt; 함수를 호출한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;yield는 코루틴에서 제어를 넘길 때 쓰는 것이다. &lt;code&gt;yield&lt;/code&gt; 함수는 현시점에서의 후속문을 캡처해서 지역변수 &lt;code&gt;k&lt;/code&gt;에 넣는다. 지역변수 &lt;code&gt;k&lt;/code&gt;가 후속문 함수이고, 스레드 큐가 비어있지 않으면 지역변수 &lt;code&gt;k&lt;/code&gt;에 들어있는 후속문 함수를 큐에 넣고, 큐에서 스레드 하나를 꺼내서 실행한다. 만일 &lt;code&gt;yield&lt;/code&gt; 함수에서 캡처된 후속문 함수가 호출되면 지역변수 &lt;code&gt;k&lt;/code&gt;는 함수가 아니어서 &lt;code&gt;yield&lt;/code&gt; 함수는 리턴한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 이제 하나씩 실행 과정을 살펴보자. &lt;i class=&quot;conum&quot; data-value=&quot;9&quot;&gt;&lt;/i&gt;, &lt;i class=&quot;conum&quot; data-value=&quot;10&quot;&gt;&lt;/i&gt; &lt;i class=&quot;conum&quot; data-value=&quot;11&quot;&gt;&lt;/i&gt;에서 &lt;code&gt;spawn&lt;/code&gt; 함수에 의해 스레드가 만들어져서 스레드 큐에 차례대로 들어간다. 이 스레드 함수들이 호출되면 &lt;code&gt;loop&lt;/code&gt; 함수가 실행될 것이다. 이제 &lt;i class=&quot;conum&quot; data-value=&quot;12&quot;&gt;&lt;/i&gt;의 &lt;code&gt;start-threads&lt;/code&gt; 함수에 의해서 스레드 전체가 구동되기 시작한다. 스레드 큐에서 제일 먼저 스레드 &lt;code&gt;'a&lt;/code&gt;가 먼저 꺼내져서 실행된다. &lt;code&gt;loop&lt;/code&gt; 함수에서 &lt;code&gt;yield&lt;/code&gt;가 호출된다. &lt;code&gt;yield&lt;/code&gt; 호출에 의해 &lt;code&gt;yield&lt;/code&gt; 이후 후속문 함수가 스레드 큐에 들어가고, 기존에 있던 스레드가 스레드 큐에서 꺼내져서 실행된다. 이것은 스레드 &lt;code&gt;'b&lt;/code&gt;이다. 스레드 &lt;code&gt;'b&lt;/code&gt;에서도 &lt;code&gt;yield&lt;/code&gt;가 실행되고, 다음 스레드 &lt;code&gt;'&lt;/code&gt;c가 실행된다. 스레드 &lt;code&gt;'&lt;/code&gt;c도 &lt;code&gt;yield&lt;/code&gt;를 호출하고, 스레드 큐에서 스레드를 꺼내는데, 이 스레드는 &lt;code&gt;spawn&lt;/code&gt; 함수에 의해서 캡처된 것이 아니라 스레드 &lt;code&gt;'a&lt;/code&gt;의 &lt;code&gt;yield&lt;/code&gt;에 의해서 캡처된 후속문 함수이다. 그러면 결국 제어는 &lt;code&gt;loop&lt;/code&gt; 함수의 &lt;code&gt;yield&lt;/code&gt;으로 이동하는데, 거기서 다시 &lt;code&gt;loop&lt;/code&gt;을 호출하므로 재귀가 된다. 그러면서 또 같은 위치에서 제어를 양보하게 된다. 이런 식으로 계속해서 후속문 함수가 생성되어 큐에 들어가고 큐에서 후속문 함수를 꺼내서 실행하면서 스레드들끼리 서로 제어를 넘겨받게 된다. 그러면서 &lt;code&gt;count&lt;/code&gt;를 하나씩 감소시키는데, &lt;code&gt;count&lt;/code&gt;가 0보다 작아지면 &lt;code&gt;quit&lt;/code&gt; 함수를 호출한다. &lt;code&gt;quit&lt;/code&gt; 함수는 스레드 큐에 남아있는 스레드들을 다 실행시키다가 스레드 큐가 비면 &lt;code&gt;halt&lt;/code&gt; 함수를 호출해서 전체 실행을 끝낸다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이 예제에서 보여준 코루틴은 매우 초보적인 수준이다. 실제 프로그래밍 언어 차원에서 제공되는 코루틴의 구현을 위해서는 더 복잡한 기능들이 추가되어야 한다. 코루틴을 어떻게 구현할 것이냐에 따라 여러가지로 분류되기도 한다. 이에 대해 좋은 한글 자료로는 &lt;a href=&quot;https://medium.com/@jooyunghan/%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%B4%EB%B3%B4%EC%9E%90-98428c491ace&quot;&gt;한주영님의 블로그 글&lt;/a&gt;를 보면 좋을 듯 하다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코루틴과 구분되는 것으로 파이버(Fiber)가 있다. 파이버는 코루틴에 전용의 스케줄러를 추가한 개념이다. 실제로 자바에서 파이버를 구현하는 프로젝트인 Loom Project에서는 ForkJoinPool을 스케줄러로 사용해서 파이버를 구현하고 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;또 코루틴과 비교될 수 있는 것이 최근에 소개되고 있는 CSP 프로그래밍의  고루틴(go routine)이다. Go 언어에서 많이 사용되고 있는데, 사실 후속문이라는 점에서는 코루틴과 같다. 다만 코루틴은 단일 스레드 상에서만 동시성이 보장되지만, 고루틴은 멀티 스레드 상에서도 동시성을 보장할 수 있도록 채널이라는 동시성 지원 장치를 이용한다는 점이 다르다. 단일 스레드에서만 동시성이 보장되는 것은 파이버도 마찬가지다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_1부를_마치면서&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_1부를_마치면서&quot;&gt;&lt;/a&gt;3. 1부를 마치면서&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 후속문의 개념에 대한 정의와 후속문이 call/cc에 의해서 어떻게 다루어지는지, 그리고 call/cc 함수로 다양한 후속문 프로그래밍에 대해 알아보았다. yin-yang 예제는 call/cc를 통한 후속문 프로그래밍이 어떤 힘을 가질 수 있는지를 보여주었다. 비결정적 선택 예제는 프로그래머가 얼마든지 언어에서는 제공하지 않는 제어구조를 만들 수 있다는 점을 보았다. 코루틴 예제는 컴파일러들이 제공하는 대표적인 제어 흐름 구조를 후속문으로 구현해 보았다. 후속문은 이 밖에도 제너레이터(Generator)와 예외(Exception) 등을 구현할 때도 사용될 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;일반 프로그래밍과 후속문 프로그래밍를 비교해보면서 마무리하겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock center&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;../../img/continuation/cont-subs.png&quot; alt=&quot;후속문 교체&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;그림 6. 일반 프로그래밍과 후속문 프로그래밍의 개념&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 그림의 왼쪽 박스 A는 일반적인 프로그래밍을 나타낸다. 일반 프로그래밍에서 모든 프로그램은 현재 시점을 기준으로 그 이전은 전행문, 그 이후는 후속문으로 나눌 수 있다. 이때 후속문은 전행문과 스택 등의 실행 환경(위 그림에서는 evn 상자)을 공유한다. 일반 프로그래밍에서의 함수 호출도 사실은 스택을 공유하는 것이다. 다만 스택 프레임이 한 층 쌓일 뿐이다. 예외를 던지는 것은 같은 스택상의 스택 프레임을 벗어나는 것일 뿐이지, 결코 스택 자체를 벗어나는 것은 아니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;반면 위 그림의 오른쪽 박스 B는 후속문 프로그래밍을 나타낸다. 여기서는 무엇이 후속문이 될지 결정되지 않았다. 그것을 결정하는 것은 어떤 후속문 함수를 호출하는가에 달렸다. 만약 위 그림에서 후속문 함수1이 호출되었다면, 전행문의 실행 환경은 버려지고 후속문은 자신의 실행환경을 가지고 실행된다. 이때 스택도 완전히 후속문 함수1의 스택으로 교체되는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_2부_예고&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#_2부_예고&quot;&gt;&lt;/a&gt;3.1. 2부 예고&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;2부에서는 call/cc 외의 다른 후속문 API들과 한정 후속문(delimited continuation)들에 대해 알아볼 것이다. 또한 후속문의 발견의 역사에 대해서도 알아보겠다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_1&quot;&gt;
&lt;a href=&quot;#_footnoteref_1&quot;&gt;1&lt;/a&gt;. 동시성 문제를 해결하는데 있어 스레드라는 개념은 아마도 최악의 개념이 아니였을까? 스레드없는 얼랭(Erlang) 언어가 99.9999999%의 고가용성의 통신 시스템을 구축하는 걸 보면, 현대 프로그래밍 언어에서 스레드 프로그레밍 지원이 그토록 많다는 점은 확실히 미스터리가 아닐 수 없다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_2&quot;&gt;
&lt;a href=&quot;#_footnoteref_2&quot;&gt;2&lt;/a&gt;. &lt;a href=&quot;https://www.merriam-webster.com/dictionary/continuation&quot; class=&quot;bare&quot;&gt;https://www.merriam-webster.com/dictionary/continuation&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_3&quot;&gt;
&lt;a href=&quot;#_footnoteref_3&quot;&gt;3&lt;/a&gt;. &lt;a href=&quot;http://stdweb2.korean.go.kr/main.jsp&quot; class=&quot;bare&quot;&gt;http://stdweb2.korean.go.kr/main.jsp&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_4&quot;&gt;
&lt;a href=&quot;#_footnoteref_4&quot;&gt;4&lt;/a&gt;. &lt;a href=&quot;https://stackoverflow.com/questions/6868324/can-if-be-implemented-using-call-cc&quot; class=&quot;bare&quot;&gt;https://stackoverflow.com/questions/6868324/can-if-be-implemented-using-call-cc&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_5&quot;&gt;
&lt;a href=&quot;#_footnoteref_5&quot;&gt;5&lt;/a&gt;. 이 방법은 &lt;a href=&quot;http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf:&quot;&gt;Introduction to Programming with Shift and Reset&lt;/a&gt;이나 &lt;a href=&quot;https://www.youtube.com/watch?v=2GfFlfToBCo&amp;amp;t=2556s:&quot;&gt;Intro to continuations, call/cc, and CPS&lt;/a&gt;에서 소개된 방법인데, 이 방법에 v 표기법이라는 말을 붙여보았다. 이름을 붙이면 명확하게 되니까.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_6&quot;&gt;
&lt;a href=&quot;#_footnoteref_6&quot;&gt;6&lt;/a&gt;. 사실 예외가 후속문으로 구현된 것이다
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_7&quot;&gt;
&lt;a href=&quot;#_footnoteref_7&quot;&gt;7&lt;/a&gt;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Control_flow#Structured_non-local_control_flow&quot; class=&quot;bare&quot;&gt;https://en.wikipedia.org/wiki/Control_flow#Structured_non-local_control_flow&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_8&quot;&gt;
&lt;a href=&quot;#_footnoteref_8&quot;&gt;8&lt;/a&gt;. &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Non_002dLocal-Intro.html#Non_002dLocal-Intro&quot; class=&quot;bare&quot;&gt;https://www.gnu.org/software/libc/manual/html_node/Non_002dLocal-Intro.html#Non_002dLocal-Intro&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_9&quot;&gt;
&lt;a href=&quot;#_footnoteref_9&quot;&gt;9&lt;/a&gt;. call/cc 코드를 보면 일상적으로 하게 되는 것인데, 이것에 v 인자 대입법이라는 이름을 붙여보았다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_10&quot;&gt;
&lt;a href=&quot;#_footnoteref_10&quot;&gt;10&lt;/a&gt;. 코드는 &lt;a href=&quot;https://en.wikipedia.org/wiki/call-with-current-continuation&quot;&gt;위키피디아&lt;/a&gt;에서 가져왔다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_11&quot;&gt;
&lt;a href=&quot;#_footnoteref_11&quot;&gt;11&lt;/a&gt;. 어떤 값도 할당되지 않는 변수를 말한다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_variables_and_bound_variables&quot;&gt;참조&lt;/a&gt;
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_12&quot;&gt;
&lt;a href=&quot;#_footnoteref_12&quot;&gt;12&lt;/a&gt;. 이것을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Indeterminism&quot;&gt;비결정론(Indeterminism)&lt;/a&gt;과 혼동하지 말자. 철학에서의 비결정론이란 어떤 사건에는 반드시 원인이 있다라는 개념에 대한 반대이며, 인간의 자유의지 문제와 결부된 것이다. 비결정성은 원인이 없다거나 자유의지와는 전혀 상관이 없다. 이것은 차라리 양자역학적 확률론과 관련이 있다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_13&quot;&gt;
&lt;a href=&quot;#_footnoteref_13&quot;&gt;13&lt;/a&gt;. 나무꾼은 금도끼를 선택해도 된다. 맞는 도끼를 선택했는지는 비결정적 알고리즘의 역할이 아니니까.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_14&quot;&gt;
&lt;a href=&quot;#_footnoteref_14&quot;&gt;14&lt;/a&gt;. 비결정적 알고리즘을 설명하면서 산신령과 나무꾼에 비유하는 것이 좀 뜬금없을 수 있는데, 사실 Paul Graham도 On Lisp에서 비결정적 알고리즘을 설명할 때 다음과 같이 'supernatural' 이란 표현을 사용했다. &quot;A nondeterministic algorithm is one which relies on a certain sort of supernatural foresight.&quot; - 286p
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_15&quot;&gt;
&lt;a href=&quot;#_footnoteref_15&quot;&gt;15&lt;/a&gt;. 이 코드는 &lt;a href=&quot;http://matt.might.net/articles/programming-with-continuations&amp;#8212;&amp;#8203;exceptions-backtracking-search-threads-generators-coroutines/:&quot;&gt;Matt Might의 블로그 기사&lt;/a&gt;에서 가져왔다. 원래 Scheme 코드였는데 Racket 코드로 변경했다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_16&quot;&gt;
&lt;a href=&quot;#_footnoteref_16&quot;&gt;16&lt;/a&gt;. 'amb&amp;#8217;는 'ambiguous&amp;#8217;의 준말이다. 이 함수는 SICP의 4.3 Nondeterministic Computing에서 소개되었는데, John McCarthy의 아이디어였다고 한다.
&lt;/div&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_17&quot;&gt;
&lt;a href=&quot;#_footnoteref_17&quot;&gt;17&lt;/a&gt;. 이 코드 역시 &lt;a href=&quot;http://matt.might.net/articles/programming-with-continuations&amp;#8212;&amp;#8203;exceptions-backtracking-search-threads-generators-coroutines/:&quot;&gt;Matt Might의 블로그 기사&lt;/a&gt;에서 가져왔다. 원래는 Scheme 코드였는데 Racket 코드로 변경했다. 이 블로그 기사 페이지를 꼭 방문해 보기를 바란다. 이 글에서 소개한 것 이외에 Exception이나 Generator등을 call/cc로 구현한 다른 예제들이 있다. 꼭 방문해서 코드를 분석해보길 바란다.
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Sun, 18 Nov 2018 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://guruma.github.io/posts/2018-09-27-Project-Loom-Fiber-And-Continuation/
</guid>
<link>
http://guruma.github.io/posts/2018-09-27-Project-Loom-Fiber-And-Continuation/
</link>
<title>
Project Loom: Fiber와 Continuation
</title>
<description>
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_자바에_fiber와_continuation이_추가된다&quot;&gt;자바에 Fiber와 Continuation이 추가된다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;최근에 관심이 가는 &lt;a href=&quot;http://openjdk.java.net/&quot;&gt;OpenJDK&lt;/a&gt; 프로젝트 중에 &lt;a href=&quot;https://www.graalvm.org/&quot;&gt;GraalVM&lt;/a&gt; 외에 &lt;a href=&quot;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&quot;&gt;Project Loom&lt;/a&gt;이 추가되었다. 이유는 이 프로젝트의 목표가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;Fiber&lt;/a&gt;를 구현하는 것인데, 이를 위해서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;Continuation&lt;/a&gt;을 구현해야 하기 때문이다. 결국 자바에 Continuation이 추가되는 것이 되는데&amp;#8230;&amp;#8203; 오&amp;#8230;&amp;#8203;마이&amp;#8230;&amp;#8203;갓. 과연 이보다 Java를 프로그래밍 언어로서 강력하게 만들어주는 것이 있을까? 뭐 사람마다 견해의 차이가 있겠지만 나는 Continuation을 절대 반지로 본다. 왜냐하면 Continuation은 그동안 컴파일러 작성자들 사이에서 제어 구문을 만들 때 사용되던 프로그래밍 기법이었는데, 이것을 프로그래머들이 사용할 수 있게 되면 프로그래머들은 그 언어가 제공하는 제어 구문(if나 for 등)의 제약에서 벗어나서 자신의 필요에 맞는 제어구조를 스스로 만들어 낼 수 있게 되기 때문이다. 쉽게 말하자면, 좀 억지 비유이긴 하지만 Continuation은 &lt;a href=&quot;http://wiki.c2.com/?ContinuationsAreGotos&quot;&gt;세련된 GOTO&lt;/a&gt;라고 할 수 있다. 좀 더 구체적인 억지 비유라면 파라미터와 스택이 달린 GOTO라고 할까? 확실히 데익스트라의 &lt;a href=&quot;https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf&quot;&gt;해로운 GOTO&lt;/a&gt;와는 다르지만, GOTO 만큼 제어를 마음대로 옮겨다니게 만들 수 있는데(함수 중간에 다른 함수의 중간으로 점프했다가 다시 돌아온다든지, map으로 컬렉션을 이터레이션을 하다가 특정 조건의 요소(element)에서 중단하게 한다든지) 게다가 그게 세련된 방식이라는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 Continuation에 대한 본격적인 소개는 다음으로 미루기로 하고, 이글에서는 Project Loom의 목표인 Fiber와 그와 관련되는 수준에서의 Continuation에 대해 설명하고자 한다. 자바에서의 Fiber의 도입은 그 자체만으로도 프로그래밍 관점에서 매우 특기할 만한 일이어서 하나의 주제로 다루어지기에 충분히 가치가 있기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_왜_fiber인가&quot;&gt;왜 Fiber인가?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 자바의 Fiber 도입은 좀 늦은 감이 있다. 다른 언어들은 이미 Fiber 혹은 그와 비슷한 것들을 갖고 있다. C++은 Boost.Fiber 라이브러리를, Ruby는 Fiber 클래스를 공식적으로 지원하고 있다. Fiber는 아니지만, Fiber와 비슷한 것으로 Python은 Greenlet, Go는 goroutine, C#과 Javascript는 Async/Await를 지원하고 있으며, 이를 통해 Fiber로 해결할 문제를 나름의 방식으로 해결하고 있는 상황이다. 아니 Erlang의 Actor까지와 비교를 한다면 많이 늦었다고 해야 할지도 모르겠다. 자, 그렇다면 이건 하나의 경향이 있다고 볼 수 있지 않을까? 즉, 앞에서도 언급했듯이 현재 대부분의 주류 언어들이 Fiber 혹은 그 비슷한 것의 도입으로 풀려고 하는 그 어떤 고약한 문제들이 우리 프로그래밍 세계에서 지속적으로 발생하고 있고, 자바 역시 바로 그 고약한 문제를 풀기 위해 Fiber를 도입하려는 그런 경향 말이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 그럼, 그 고약한 문제는 과연 무엇일까?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_동시성_프로그래밍의_변화_중량_스레드에서_경량_스레드로&quot;&gt;동시성 프로그래밍의 변화 : 중량 스레드에서 경량 스레드로&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;동시성 프로그래밍은 어렵다. 하지만 동시성 프로그래밍은 멀티코어 시대와 클라우드의 시대에 더욱 중요해지고 있다. 점점 증가하는 동시성 프로그래밍의 요구사항을 충족시키는 데 있어 동시성 프로그래밍의 복잡성은 프로그래머들에게 최대의 적으로 부각되었다. (뭐 여기까지는 다들 아시는 내용이리라 짐작한다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 프로그래머들은 동시성 프로그래밍을 할 때 보통 운영체제에서 제공하는 스레드를 사용한다. 운영체제에서 제공하기 때문에 특히 커널 스레드라고 부른다. 그런데 문제는 이 커널 스레드가 상당히 무겁다는 것이다. 해서 중량 스레드라고 부르기도 한다. 동시성 프로그래밍이 복잡한 이유는 바로 이 커널 스레드가 중량 스레드이기 때문인데, 위에서 언급한 그 고약한 문제란 이 중량 스레드가 야기하는 문제이다. 즉 멀티코어와 클라우드의 시대에 중량 스레드가 야기하는 문제는 매우 심각했고, 결국 이를 해결하기 위해 나온 것이 Fiber, Greenlet, goroutine, Actor(혹은 재발견?) 등이었다. (이들은 중량 스레드와 비교해서 가벼워서 경량 스레드라고 부른다)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_중량_스레드의_문제점&quot;&gt;중량 스레드의 문제점&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;스레드, 즉 중량 스레드의 문제는 그 이름이 말해주듯이, 그것이 어플리케이션에서 사용하기에는 지나치게 무겁다는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;무겁다는 표현은 3가지 의미가 있는데, 이것이 중량 스레드의 특성이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;리소스 부하가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동시성 작업 단위가 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선점형 스케줄러&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하나씩 순서대로 좀 더 자세히 알아보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫째로 스레드는 리소스를 많이 차지하는데, 그래서 서버당 수천 개 정도만 생성할 수 있다. 반면 소켓은 수백만 개 생성할 수 있다. 이는 거의 몇 승수(order of magnitude)라는 매우 심각한 차이다. 실제로 웹서버는 하나의 스레드가 하나의 Request를 처리하기 때문에 동시에 처리할 수 있는 Request는 스레드 생성 개수에 제한받아서 수 천 개 정도이다. 또한 스레드 간 문맥 전환에 드는 비용도 만만치 않다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;둘째는, 사실 이는 첫째 때문에 생기는 것인데, 스레드가 리소스를 많이 차지하기(또 관리가 어렵기) 때문에, 작은 단위의 작업을 처리하기 위해 가볍게 쓰고 버리는 식으로 쓰기보다는, 큰 단위의 작업을 처리하고 Pooling 한 후 재사용하는 식으로 이용하게 된다는 것이다. 하지만 어플리케이션은 그 특성에 따라 동시성의 작업 단위가 각각 다르다. 비디오 레코딩 프로그램과 웹서버의 동시성 요구 사항의 수준이 같을 수 없다. 또한 어플리케이션 수준에서는 작은 단위의 동시성 작업이 많다. 유저 단위 작업, 트랜잭션 단위 작업, 심지어 단일 연산 작업이라도 동시성 처리가 필요한 경우가 많지만, 이때마다 스레드 만들어 처리하기에는 너무 비용이 크기 때문에, 꼭 필요한 경우를 제외하고는 대부분 세션같이 큰 단위의 작업에 스레드를 사용한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;셋째는, 정말 이것이야말로 개인적으로는 가장 치명적 요소라고 보는데, 스레드, 그러니까 OS가 제공하는 커널 스레드는 선점형 스케줄러에 의해 처리된다는 사실이다. 선점형이라는 말은 한 스레드에서 다른 스레드로 제어(CPU 할당)가 넘어가는 문맥전환(Context Switch)이 전적으로 OS 담당이라는 의미이다. 이로 인해, 어플리케이션 수준에서 작업하는 프로그래머는 스레드에 맡긴 작업이 어느 순간에 중단될지를 알 수가 없다. 더욱이 그 중단되는 분절이 프로그래머가 작성한 코드 레벨이 아니라 컴파일된 코드(바이트 코드나 기계어 코드) 레벨이기 때문에, 프로그래머에게는 비가시성 영역에서의 중단이라는 점에서, 프로그래머는 전혀 예측할 수 없는 암흑 상태에 빠지게 된다. 이 암흑 상태는 더욱 심각한 문제를 야기하는데, 이런 암흑 상태에서 실행되는 작업이 처리하는 데이터들이 엉망이 될 수 있다는 사실이다. 마치 컴컴한 한밤중에 여러 대의 드론을 운전하면서 골목길을 통과하고 피자를 배달하는 것과 마찬가지 상황이 되는 것이다. 그래서 드론들이 주변과 충돌하지 않도록 골목길에 칠 가드레일과 교차로에서 서로 충돌하지 않도록 하는(데드락) 신호등이 필요하게 되는데, 그게 바로 멀티 스레드 프로그래밍 시에 반드시 사용하게 되는 세마포어, 뮤텍스, 아톰, 크리티컬 섹션이다. 하지만 이들로 인해 바로 그만큼 멀티 스레드 프로그래밍의 복잡성이 더욱 증폭된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 스레드(커널 스레드)는 모든 어플리케이션의 동시성 요구에 맞추기 위한 일반 목적으로 만들어진 것이다. 즉 스레드는 가장 최악의 경우에도 대처할 수 있도록 만들어야 했는데, 예를 들어 하나의 스레드가 엄청난 계산으로 CPU를 독점하고 있는 상황에 대처할 필요가 있었다.  그러나 개개의 어플리케이션들은 각자 자신만의 특수한 동시성 수준이 갖고 있을 뿐이다. 프로그래머들은 자신이 만들고 있는 어플리케이션이 요구하는 동시성 수준에 대해 잘 알고 있으며, 사실 그 특수한(일반적이지 않은) 요구사항의 수준에 맞는 정도의 동시성 작업 자체만 할 수 있다면 매우 간단하게 해결할 수 있다. 프로그래머들은 결코 스레드와 같은 일반성 수준의 동시성 작업을 만나지 않는다. 웹 어플리케이션을 만들면서 동시에 비디오 레코딩의 동시성에 대해 고민하지 않는다. 그런데 스레드는 개개의 어플리케이션의 특수한 동시성을 해결하기에는 너무 일반적인 도구이며, 위의 3가지 이유로 인해서 매우 불편한 도구인 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_해결사_경량_스레드&quot;&gt;해결사 경량 스레드&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;해결책의 방향은 이것이다. 만일 프로그래머들이 해당 어플리케이션의 요구사항에 대응하는 동시성 수준의 특수성에 대해 잘 알고 있다면, 더 이상 커널이 강제한 일반적인 방식이 아닌, 해당 어플리케이션의 동시성 수준의 방식으로 스스로 동시성 작업을 관리할 수 있도록 자유를 주는 것이다. (한마디로 동시성 프로그래밍에 있어서 커널 독재 시대에서 어플리케이션의 자유 시대로 바뀌는 것인데, 이를 위해 때론 Callback이나 Promise 그리고 심지어 Monad까지 동원되는 다양한 시도들이 있었지만, 근본적인 변화를 위해서는 일급시민(First Class)이 된 Continuation이 필요했다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그래서 위에서 언급한 중량 스레드의 특성과는 반대되는 특성을 가진 경량 스레드가 주목받게 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;경량 스레드는 다음과 같은 특성이 있다:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;리소스 부하가 매우 적다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작은 수준의 동시성 작업 단위 처리가 매우 수월하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;유저 레벨 스케줄링.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자바는 경량 스레드 중에서 Fiber를 채택하게 되었다. 사실 Fiber와 Continuation이라면 다른 경량 스레드를 다 만들어낼 수 있다. 보다 근본적이기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_project_loom의_fiber&quot;&gt;Project Loom의 Fiber&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 언급한 바로 이러한 이유로 해서 자바에도 경량 스레드의 필요성이 오래전부터 대두되었다. 그래서 자바에서 경량 스레드를 도입하려는 프레임웍들이 나오게 되었는데, &lt;a href=&quot;https://vertx.io/&quot;&gt;Vert.x&lt;/a&gt;, &lt;a href=&quot;https://akka.io/&quot;&gt;akka&lt;/a&gt;, &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;, &lt;a href=&quot;http://docs.paralleluniverse.co/quasar/&quot;&gt;Quasar&lt;/a&gt; 등이 그것이다. 특히 개인적으로는 &lt;a href=&quot;https://github.com/oltolm/continuations&quot;&gt;Matthias Man의 Continuation&lt;/a&gt;으로 Fiber를 구현한 Quasar와 그의 Clojure 랩퍼인 &lt;a href=&quot;http://docs.paralleluniverse.co/pulsar/&quot;&gt;Pulsar&lt;/a&gt;에 관심을 두고 있었는데, Quasar 개발자인 Ron Pressler가 바로 Project Loom을 &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/discuss/2017-September/004390.html&quot;&gt;제안&lt;/a&gt;했고 &lt;a href=&quot;http://openjdk.java.net/census#rpressler&quot;&gt;프로젝트 리더&lt;/a&gt;로 활동하고 있음을 알게 되었다(Quasar의 개발이 왜 뜸한가 했더니 그가 Project Loom 활동하느라 바빠서 그랬던 모양이다). 즉 드디어 Java 언어 차원에서 경량 스레드가 본격 지원되게 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자바에 경량 스레드를 도입하려는 목적으로 출발한 Project Loom이 구현하는 것은 Fiber이다. &lt;a href=&quot;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&quot;&gt;제안서&lt;/a&gt;에 따르면 대략 다음과 같은 기능을 갖게 될 것이라고 한다:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매우 적은 리소스.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;수백 바이트 정도.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스위칭 오버헤드는 거의 제로 수준.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하나의 JVM에서 수백만 개 생성 및 원활한 동작 가능.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronous, blocking 콜 가능.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;성능때문에 비동기 코드 작성 필요 없음. (node의 콜백헬이 없다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동시성 프로그래밍이 단순해지며, 또한 손쉽게 규모 확장이 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fiber의 API들은 Thread 클래스와 거의 비슷.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다만, Fiber를 중단/재시작하는 park/unpark 관련 메소드가 추가됨.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unpark 메소드는 인수로 스케줄러를 받을 수 있어서 fiber의 스케줄링을 바꿀 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thread와 공통되는 부분은 부모 클래스 Strand로 추출.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serializable&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fiber는 스토리지 저장 및 네트웍을 통한 전송이 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 통해 데이터가 있는 곳에서 실행되는 함수(&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_as_a_service&quot;&gt;Function As Service&lt;/a&gt;)가 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Financial Transaction이나 실행 블록체인.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Continuation&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fiber = Continuation + Scheduler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scheduler는 훌륭하게 구현된 기존의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html&quot;&gt;ForkJoinPool&lt;/a&gt;을 그대로 사용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Continuation(정확히는 Delimited Continuation)의 구현이 서브 과제&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel, actor, dataflow 등을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UAI(Unwind And Invoke)&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tail call&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Project Loom의 목표는 기존 자바 코드의 수정 없이, 혹은 최소한의 변경만으로 사용 가능하게 하는 것이라고 한다. 하지만 JNI를 통한 native 코드는 Fiber에서 실행되지 못한다. 또한 기존 자바 API 중 java.io 는 Native blocking 코드가 있어서 Fiber 용으로 다시 변경되어야 하며, java.util.concurrent 도 커널 스레드 동기 때문에 역시 변경이 될 것이라고 한다. 기타 자바 디버거나 프로파일러 등도 Fiber에 맞게 수정이 필요하다고 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Thu, 27 Sep 2018 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</guid>
<link>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</link>
<title>
클로저스트립트에서 매크로 작성시 주의점
</title>
<description>
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_컴파일러는_크로스_컴파일러다&quot;&gt;클로저스크립트 컴파일러는 크로스 컴파일러다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트(ClojureScript) 컴파일러는 클로저스크립트 코드를 컴파일하여 브라우저나 Node.js에서 실행할 자바스크립트 코드를 만듭니다. 하지만 클로저스크립트 컴파일러 자체는 JVM상에서 실행되는 자바 프로그램이며, cljs.jar 파일로 배포됩니다. 즉 클로저스크립트 컴파일러는 컴파일러가 실행되는 환경은 JVM인데, 컴파일러의 실행 결과인 목적 코드가 실행되는 환경은 JS VM(브라우져나 Node.js처럼 자바스크립트를 실행시키는 VM)인 것입니다. 이처럼 컴파일러가 실행되는 환경과 그 컴파일러의 목적 코드가 실행되는 환경이 다른 컴파일러를 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC&quot;&gt;크로스 컴파일러&lt;/a&gt;(Cross Compiler)라고 합니다. 클로저스크립트 컴파일러는 크로스 컴파일러인 셈이죠. 이 때문에 발생하는 문제들이 있는데, 이 글에서는 특히 매크로와 관련된 문제들을 살펴보겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_매크로는_클로저_코드이다&quot;&gt;클로저스크립트 매크로는 클로저 코드이다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;모든 리습 언어의 매크로가 그렇듯이 클로저스크립트의 매크로도 컴파일시에 확장이 됩니다. 매크로는 컴파일러 시에 수행되는 일종의 함수입니다. 즉 매크로는 코드를 입력받아 코드를 리턴하는, 사용자가 작성하고, 사용자가 사용하지만, 그 호출은 컴파일러에 의해 수행되는 함수입니다. 컴파일러는 매크로 호출을 만나면 입력받은 코드를 인수로 해서, 정의된 매크로(함수)를 수행하고, 그 수행 결과로 나온 코드를 원래의 매크로 호출 코드와 교체합니다. 이처럼 매크로 호출 코드를 매크로 출력 코드로 바꾸는 것을 매크로 확장이라고 합니다. 그런데 이 매크로 확장이 컴파일시에 되어야 하기 때문에 클로저스크립트의 매크로 확장은 목적 코드의 실행 환경인 JS VM이 아닌 컴파일러의 실행 환경인 JVM 상에서 이루어집니다. 그래서 클로저스크립트의 매크로는 JVM 상에서 실행될 수 있는 클로저 코드로 작성되어야 합니다. 이러한 이유로 클로저스크립트 매크로는 클로저스크립트 파일(.cljs)이 아닌 클로저 파일(.clj)로 작성됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;크로스 컴파일러라는 클로저스크립트 컴파일러의 이러한 특성으로 인해 일반 코드와 매크로 코드가 분리되어서 작성되어야 한다는 것은 사실 조금 번거롭기는 하지만 그리 큰 문제는 아닙니다. 어짜피 매크로 코드는 다른 게 아니라 우리가 많이 익숙한 클로저 코드니까요. 문제는 매크로 도우미(Helper) 함수들입니다. 특히 .cljc 파일이 도입되면서는 숙련된 클로저 프로그래머조차 이와 관련해서 가끔 실수하기도 합니다. 사실 이러한 점은 원리를 알면 당연한 것이 되어서 쉽게 피할 수 있는 문제이기 때문에 이 글에서 차근차근 알아보도록 하겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
이 글에서는 컴파일러의 특성을 알아보는 것이 목적이므로 Leiningen보다는  clojure.jar와 cljs.jar를 통해서 Clojure와 ClojureScript 컴파일러를 직접 사용합니다.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저의_매크로_작성_방식&quot;&gt;클로저의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 클로저(Clojure)에서는 다음과 같이 매크로를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defmacro log [x]
  `(println &quot;[log: ]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer [log]]))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro.clj에서 &lt;code&gt;log&lt;/code&gt; 매크로를 정의합니다. 간단하게 로그를 프린트하는 형식(form)을 리턴합니다. 그리고 core.clj에서 macro.clj를 로드(&lt;code&gt;:require&lt;/code&gt;)하고 &lt;code&gt;log&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; 를 프린트합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코드를 실행하기 위해 다음과 같이 test 폴더 아래에 macro.clj와 core.clj를 만들고, 위의 소스와 같은 내용으로 각각 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ mkdir test; cd test
$ touch macro.clj core.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 clojure.jar를 다운로드합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ curl -o clojure.jar http://central.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 직접 소스를 컴파일하고 실행해 봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log: ] hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;java&lt;/code&gt; 를 실행하면서 클래스패스로 clojure.jar 와 현재 디렉토리(' &lt;code&gt;.&lt;/code&gt; ')를 주었습니다. clojure.main 함수를 실행하면서 core.clj 을 인자로 넘겼습니다. core.clj 파일이 컴파일되고 실행되어 명령창에 로그가 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서 눈여겨 볼 것은 사실 당연한 것이지만 clojure.jar의 컴파일러도 JVM에서 실행되었고, 컴파일된 core.clj도 같은 JVM 상에서 실행되고 있다는 사실입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_매크로_도우미_함수&quot;&gt;매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 매크로를 작성하다 보면 매크로에서 자체적으로 사용하는 도우미(Helper) 함수들을 만들어 사용하게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 작성한 &lt;code&gt;log&lt;/code&gt; 매크로에 로그의 시각을 프린트하는 기능을 넣기 위해 &lt;code&gt;now&lt;/code&gt; 도우미 함수를 추가합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro.clj 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now [] ; &amp;lt;== 도우미 함수
  (System/currentTimeMillis))

(defmacro log [x]
  `(println &quot;[log:&quot; (now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 했던 것과 같이 컴파일하고 실행해보고 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log: 1504281655322 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;로그에 시각이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;now&lt;/code&gt; 함수는 정확하게 &lt;code&gt;log&lt;/code&gt; 매크로가 실행되는 런타임에 실행되어 해당 시각을 나타내주고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트의_매크로_작성_방식&quot;&gt;클로저스크립트의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트에서 매크로 작성하는 방식도 클로저와 비슷합니다. 일단 매크로는 .cljs가 아닌 .clj파일에서 정의되어야 한다는 점에서.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그렇다면 위에서 작성한 매크로는 .clj로 작성했으니 당연히 ClojureScript에서도 사용할 수 있겠죠?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljs 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript에서는 매크로 파일(.clj)을 로딩하기 위해서는 &lt;code&gt;:require-macros&lt;/code&gt; 를 사용합니다. &lt;code&gt;:enable-console-print!&lt;/code&gt; 는 &lt;code&gt;:println&lt;/code&gt; 함수가 JS-VM상의 console에 프린트할 수 있도록 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljs 파일을 만들고, 위의 소스와 같은 내용으로 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ touch core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트_코드_컴파일하기&quot;&gt;클로저스크립트 코드 컴파일하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript 파일을 컴파일하기 위해서는 컴파일러의 build-api를 사용해야 합니다. 다음은 build-api를 사용하는 build.clj 파일입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(require 'cljs.build.api)

(cljs.build.api/build &quot;.&quot;
  {:main 'core
   :output-to &quot;out/main.js&quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;cljs.build.api&lt;/code&gt; 를 로딩하고, &lt;code&gt;build&lt;/code&gt; 함수를 사용합니다. &lt;code&gt;build&lt;/code&gt; 함수는 2개의 인자를 받습니다. 첫번째 인자는 컴파일할 소스 디렉토리이고, 두 번째 인자는 컴파일러 옵션입니다. 옵션은 출력 파일을 가리키는 &lt;code&gt;:output-to&lt;/code&gt; 와 주 이름 공간을 가리키는 &lt;code&gt;:main&lt;/code&gt; 만 주어졌습니다. &lt;code&gt;:output-to&lt;/code&gt; 는 컴파일한 결과인 JS 코드를 out/main.js 출력 파일에 쓰라는 설정입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 다운로드받습니다. 이 파일은 클로저스크립트를 컴파일하기 위한 build-api를 담고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ curl -LOk https://github.com/clojure/clojurescript/releases/download/r1.9.908/cljs.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 이용하여 build.clj를 실행시켜 core.cljs를 컴파일합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
WARNING: core is a single segment namespace at line 1 ./core.cljs
WARNING: Use of undeclared Var macro/now at line 6 ./core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저 컴파일러를 실행하던 것과 다른 것은 클패스 패스에 clojure.jar 대신 cljs.jar를 주고, 컴파일을 구동하기 위해 build.clj 파일을 주었다는 것입니다. 그리고 컴파일만 한다는 것입니다. 실행할 플랫폼은 JVM이 아니라 JS-VM입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트의_매크로_도우미_함수&quot;&gt;클로저스크립트의 매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 경고가 2개 나옵니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫번째 경고는 core.cljs의 이름 공간이 단일 이름 공간이라는 경고입니다. 예제 자체를 최대한 단순하게 하려고 일부러 단일 이름 공간을 사용한 것이니 현재로서는 무시해도 상관없습니다. (이후로 이 글에서는 이 경고는 표시하지 않겠습니다. 여러분들이 콘솔창에서 테스트할 때는 이 경고는 계속 보일 것이지만 그냥 무시하셔도 됩니다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;두번째 경고는 &lt;code&gt;macro/now&lt;/code&gt; 가 선언되어 있지 않다는 경고입니다. 당연합니다. &lt;code&gt;macro/now&lt;/code&gt; 함수는 .clj에서 정의된 함수이므로 JVM상에서 실행되어야 하는 클로저 코드입니다. 하지만 현재 macro.clj에서 &lt;code&gt;now&lt;/code&gt; 는 &lt;code&gt;log&lt;/code&gt; 매크로 확장시가 아니라 리턴값으로 반환하는 결과 코드에서 사용되고 있습니다. 그리고 이 결과 코드는 JS-VM에서 실행되는 자바스크립트 코드여야 합니다. 하지만 클로저스크립트 컴파일러는 클로저스크립트 코드로 정의된 &lt;code&gt;now&lt;/code&gt; 함수를 찾을 수가 없습니다. 정의된 적이 없으니까요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;해결책은 2가지입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫번째 방법은 클로저 코드 &lt;code&gt;now&lt;/code&gt; 함수를 매크로 확장 시에 호출되도록 하는 것이고, 두 번째 방법은 &lt;code&gt;now&lt;/code&gt; 함수를 클로저스크립트 코드로 정의해서 사용하는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;우선 첫 번째 방법을 해보겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 macro.clj 파일을 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (System/currentTimeMillis))

(defmacro log [x]
  (let [t# (now)] ; &amp;lt;== now는 매크로 확장시에 호출된다.
  `(println &quot;[log:&quot; ~t# &quot;]&quot; ~x)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제에서는 &lt;code&gt;now&lt;/code&gt; 함수가 매크로 안에서 직접 호출되고, 그 결과값을 매크로의 결과에 포함합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다시 컴파일하면 정상적으로 성공합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ ls -al
total 57184
drwxr-xr-x  10 guruma  staff       340  9  2 02:25 .
drwxr-xr-x   6 guruma  staff       204  9  2 00:37 ..
-rw-r--r--   1 guruma  staff        99  9  2 01:43 build.clj
-rw-r--r--@  1 guruma  staff  25629199  9  2 01:24 cljs.jar
-rw-r--r--   1 guruma  staff   3622815  9  2 00:36 clojure.jar
-rw-r--r--   1 guruma  staff        86  9  2 00:46 core.clj
-rw-r--r--   1 guruma  staff        98  9  2 01:37 core.cljs
-rw-r--r--   1 guruma  staff       137  9  2 02:25 macro.clj
drwxr-xr-x  11 guruma  staff       374  9  2 02:25 out&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;out 폴더가 생성되는 것을 확인할 수 있습니다. out 폴더에 main.js 파일이 생성되는데, 이 파일이 컴파일된 결과 파일입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스립트립트_코드_실행하기&quot;&gt;클로저스립트립트 코드 실행하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;main.js를 브라우저에서 실행해 보기 위해 index.html 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
         &amp;lt;script type=&quot;text/javascript&quot; src=&quot;out/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 index.html 파일을 브라우저로 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창을 열어 확인해 보면 로그가 다음과 같이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1504286749399 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;혹시 코드를 수정하게 되었는데, 수정한 코드가 브라우저에서 제대로 동작하지 않을 시에는 out 폴더를 삭제하신 후 다시 컴파일해 주세요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ rm -rf out
$ java -cp cljs.jar:. clojure.main build.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_공통_도우미_함수&quot;&gt;공통 도우미 함수&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 여기에 문제가 있습니다. &lt;code&gt;now&lt;/code&gt; 함수는 &lt;code&gt;log&lt;/code&gt; 매크로가 컴파일 시에 매크로 확장할 때 실행된다는 점입니다. 원래 의도는 &lt;code&gt;log&lt;/code&gt; 매크로를 사용하는 코드가 런타임 시에 실행될 때 &lt;code&gt;now&lt;/code&gt; 함수가 실행되어야 합니다. 이것이 사실 위에서 두 번째 해결책이었는데, 더 알맞는 것이었던 거죠.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이를 위해서는 &lt;code&gt;now&lt;/code&gt; 함수는 .clj가 아닌 .cljs 파일에서 클로저스크립트 함수로 정의되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 코드가 수정되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;util.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns util)

(defn now []
  (str &quot;js:&quot; (js/Date.now)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (System/currentTimeMillis))

(defmacro log [x]
  `(println &quot;[log:&quot; (util/now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [util :refer [now]])
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;새로운 파일 util.cljs를 만들어 클로저스크립트 코드로 &lt;code&gt;now&lt;/code&gt; 함수를 정의하였습니다. 현재 시각을 가져오기 위해서 이번엔 자바스크립트의 &lt;code&gt;Date&lt;/code&gt; 오브젝트를 이용했습니다. 자바 코드인 &lt;code&gt;(System/currentTimeMillis)&lt;/code&gt; 사용할 수 없기 때문입니다. 또한 콘솔 출력 시에 macro.clj의 &lt;code&gt;now&lt;/code&gt; 함수와 구분할 수 있도록 &lt;code&gt;&quot;js:&quot;&lt;/code&gt; 문자열을 앞에 덧붙였습니다. &lt;code&gt;log&lt;/code&gt; 매크로에서는 &lt;code&gt;(util/now)&lt;/code&gt; 형식(form)으로 수정했습니다. util 이라는 이름 공간을 지정해 주어서 매크로 확장 후 정확히 util 이름 공간의 &lt;code&gt;now&lt;/code&gt; 를 호출할 수 있도록 한 것입니다. core.cljs에서는 &lt;code&gt;:require&lt;/code&gt; 를 이용해서 util.cljs를 로딩해 줍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 실행해봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창에서 로그가 프린트되는 것을 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: js:1504286749399 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;js:&quot;&lt;/code&gt; 문자열이 나오는 것을 보고 확실히 이제 &lt;code&gt;now&lt;/code&gt; 함수가 브라우저상에서 호출되어 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_조건부_컴파일&quot;&gt;조건부 컴파일&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;일단 &lt;code&gt;now&lt;/code&gt; 함수의 실행 시간 문제는 해결되었지만, 다른 문제가 있습니다. 같은 이름과 기능을 하는 2개가 함수가 하나는 macro.clj에 다른 하나는 util.cljs 파일에 각각 따로 정의되어 있다는 문제입니다. 이렇게 되면 관리가 어려워지게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 매크로를 작성하다 보면 대부분은 공통으로 사용될 수 있지만, 일부만 플랫폼에 따라 달라져야 하는 코드들이 분명 있습니다. 극히 일부 플랫폼 의존 코드만 다르고 대부분 코드들은 같은, 매크로나 매크로 도우미 함수를 각각 서로 다른 파일에서 관리해야 한다는 것는 클로저스크립트 매크로 작성 시에 큰 문제였습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;만약 이러한 코드들을 한 파일에서 정의하고 단지 일부 플랫폼 의존 코드만 따로 지정해서 조건부로 플랫폼에 따라 해당 플랫폼 코드만 컴파일할 수 있다면 정말 좋을 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 목적을 위해 처음에는 .cljx를 사용했습니다. 이것은 라이닝언(Leiningen)이라는 빌드툴에서 사용되는 것이었는데, 플랫폼 의존 코드를 지정하면 라이닝언의 cljx 플러그인이 해당 플랫폼 코드만의 파일들로, 즉 .clj와 .cljs 파일로 나누어서 자동으로 생성해 주었습니다. 그 후 클로저스크립트 컴파일러로 이후 컴파일 과정이 이어지는 방식이었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 이것은 cljx라는 특정 도구를 사용해야 한다는 점에서 모두가 만족할 만한 해결책은 아니었습니다. 왜냐면 라이닝언 등의 해당 툴을 사용하지 못하는 경우도 있기 때문이었습니다. 결국, 조건부 컴파일은 컴파일러 자체 내에 포함되어야 했고, 실제로 Clojure 1.7과 ClojureScript 0.0-3196부터 .cljc 파일에 대해 &lt;a href=&quot;https://clojure.org/guides/reader_conditionals&quot;&gt;Reader Conditionals&lt;/a&gt;라는 기능으로 추가되었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_cljc와_reader_conditionals&quot;&gt;.cljc와 Reader Conditionals&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 조건부 컴파일이 가능한 매크로를 .cljc 파일에 아래와 같이 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  #?(:clj (System/currentTimeMillis)
     :cljs (js/Date.now)))

(defmacro log [x]
  `(println &quot;[log:&quot; (now) &quot; &quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 이 Reader Conditionals라는 리더 매크로입니다. 컴파일러가 .clj, .cljs, .cljc 파일을 읽어들이면 제일 먼저 여러 가지 리더 매크로의 처리를 하는데, .cljc인 경우에는 추가로 Reader Conditionals 처리가 더해집니다. 리더 매크로의 이러한 처리들로 만들어진 form들을 컴파일러가 그 이후 단계로 처리하게 되는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 리더 매크로 안에서 &lt;code&gt;:clj&lt;/code&gt;로 지정된 형식(form)은 클로저 컴파일러가, &lt;code&gt;:cljs&lt;/code&gt;로 지정된 형식(form)은 클로저스크립트 컴파일러가 사용할 수 있도록 처리됩니다. (이외에 :clr와 :default 등도 있습니다. 이들을 플랫폼 tag라고 합니다.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 core.cljs에서 util.cljs을 로딩할 필요가 없습니다. core.cljs파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 macro.cljc를 만들고, 위의 소스 코드대로 작성합니다.
그리고 이제 기존 macro.clj과 util.cljs는 은 필요 없으니 삭제합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ touch macro.cljc
$ rm macro.clj util.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일은 성공합니다. 아무 경고도 없습니다.&lt;br&gt;
(물론 'single segment namespace' 경고는 계속 나옵니다만, 위에서 말한 것처럼 이 경고는 무시합니다.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창에서 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같은 에러가 발생합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;Uncaught ReferenceError: macro is not defined&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;에러 메시지를 보면 macro 라는 심볼이 정의되어 있지 않아서 발생한 에러입니다. 무슨 의미일까요?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일러는 &lt;code&gt;log&lt;/code&gt; 매크로를 확장한 후, 그 결과 코드인 &lt;code&gt;(println &quot;[log:&quot; (now) &quot;] &quot; &quot;hello, world&quot;)&lt;/code&gt; 를 자바스크립트 코드로 변환하게 됩니다. 이를 위해서는 일단 &lt;code&gt;println&lt;/code&gt; 과 &lt;code&gt;now&lt;/code&gt; 심볼을 resolve 해야 합니다. &lt;code&gt;println&lt;/code&gt; 은 cljs.core 이름 공간에서 찾을 수 있습니다. &lt;code&gt;now&lt;/code&gt; 는 macro 이름 공간에서 찾습니다. 그래서 &lt;code&gt;macro/now&lt;/code&gt; 함수가 됩니다.&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_1&quot; class=&quot;footnote&quot; href=&quot;#_footnote_1&quot; title=&quot;View footnote.&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 문제는 core.cljs 에서입니다. &lt;code&gt;log&lt;/code&gt; 매크로가 확장된 후 &lt;code&gt;macro/now&lt;/code&gt; 를 참조하게 되는데, core.cljs는 macro 이름 공간을 로딩한 적이 없기 때문에 &lt;code&gt;macro&lt;/code&gt; 라는 심볼 자체를 참조할 수 없게 된 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 이유때문에 컴파일러가 &lt;code&gt;macro/now&lt;/code&gt; 라는 심볼이 정의되지 않았다는 에러(Uncaught ReferenceError: macro is not defined)를 내는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro 이름 공간을 참조할 수 있도록 core.cljs를 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro]) ; &amp;lt;== macro 참조
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;:require&lt;/code&gt; 로 macro 이름 공간을 참조합니다. 이렇게 하면 macro 이름 공간에서 정의된 심볼을 참조할 수 있게 되어서 &lt;code&gt;macro/now&lt;/code&gt; 함수 호출이 가능하게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 브라우저를 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창에 다음과 같이 정상적으로 로그가 나오는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1506263117138 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 위의 예제는 설명을 하다 보니 좀 복잡해 진거지만,&lt;br&gt;
실제로는 아래와 같이 더 간단하게 &lt;code&gt;:refer-macros&lt;/code&gt; 를 사용합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer-macros [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_cljc_파일에서_매크로를_참조할_때&quot;&gt;.cljc 파일에서 매크로를 참조할 때&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 .clj와 .cljs 파일에서 공통으로 사용할 매크로를 .cljc 파일에 정의해서 사용하는 내용이었습니다. 반대로 .cljc 파일에서 매크로를 사용할 수도 있습니다. 당연히 .cljc 파일로 클로저와 클로저스크립트 코드를 같이 작성할 수 있으니, 매크로를 사용하는 것도 가능한 거죠.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;현재 core.clj와 core.cljs 파일이 있는데, 사실 같은 기능을 합니다. log를 찍는거죠. 다만 core.clj는 JVM상에서, core.cljs는 JS-VM상에서.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;기능이 같다면 .cljc로 다음과 같이 작성하는 것이 가능합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require #?(:clj  [macro :refer [log]]
               :cljs [macro :refer-macros [log]])))

#?(:cljs (enable-console-print!))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 core.clj 와 core.cljs는 필요없으니 삭제합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ rm core.clj core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljc 파일을 클로저로 컴파일하고 실행해 봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.cljc
[log: 1506263238473] hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일되는 파일인 core.cljc 의  확장자가 .clj 가 아닌 것을 눈여겨 보십시요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이번엔 다음과 같이 core.cljc 파일을 클로저스크립트로 컴파일하고, index.html로 브라우저를 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창을 열고 로그를 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1506266364171 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;같은 효과를 갖지만 &lt;code&gt;#?@&lt;/code&gt;(Reader Conditional Splicing)을 이용하면 &lt;code&gt;macro&lt;/code&gt; 심볼을 한 번만 사용할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro #?@(:clj  [:refer [log]]
                       :cljs [:refer-macros [log]])] ))

#?(:cljs (enable-console-print!))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;faaf&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_1&quot;&gt;
&lt;a href=&quot;#_footnoteref_1&quot;&gt;1&lt;/a&gt;. 지금 설명을 이렇게 하고 있지만 사실 저도 여기서 이상한 점이 있습니다. 제 생각에는 브라우저 콘솔창에서 에러가 나기 전에 컴파일할 때 경고가 나는 것이 맞지 않을까 해서입니다. 왜냐하면 core.cljs에서 :require-macros로 macro.cljc를 로딩하면 클로저 코드로 로딩할 것이므로 now 함수는 클로저 함수일 것이고, 그렇다면 매크로 확장 결과에서의 now 심볼은 클로저스크립트일 것이므로, 컴파일러는 now 심볼을 resolve 하는데 실패하여야 하기 때문입니다. 실제로 우리가 위에서 macro.clj 를 core.cljs에서 처음 로딩할 때 정확히 그랬습니다. 그런데 macro.cljc를 로딩할 때는 경고가 나지 않는 이유는 결국 클로저스크립트 컴파일러가 macro.cljc를 클로저스크립트로도 로딩했다는 이야기가 됩니다. 실제로 이런 질문을 &lt;a href=&quot;https://groups.google.com/forum/#!topic/clojurescript/Wi3xP8KVzzo&quot;&gt;클로저스크립트 구글 그룹스&lt;/a&gt;에 올렸는데 아직 답을 얻지 못하고 있네요. 답을 알게 되면 알려드리도록 하겠습니다.(혹시 답을 아시는 분이 계시다면 알려주시면 감사하겠습니다)
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Wed, 20 Sep 2017 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
