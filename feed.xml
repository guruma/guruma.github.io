<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://guruma.github.io/' rel='self' type='application/rss+xml'/>
<title>
Computat ergo est
</title>
<link>
http://guruma.github.io/
</link>
<description>
guruma's Blog
</description>
<lastBuildDate>
Sun, 24 Sep 2017 15:35:16 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://guruma.github.io/posts/2017-09-21-ReadMe/
</guid>
<link>
http://guruma.github.io/posts/2017-09-21-ReadMe/
</link>
<title>
ReadMe
</title>
<description>
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/asciidoctor/asciidoctorj&quot;&gt;AsciidoctorJ&lt;/a&gt; is the official library for running &lt;a href=&quot;http://asciidoctor.org/docs/what-is-asciidoctor&quot;&gt;Asciidoctor&lt;/a&gt; on the JVM.
Using AsciidoctorJ, you can convert AsciiDoc content or analyze the structure of a parsed AsciiDoc document from Java and other JVM languages.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_distributionnnnn&quot;&gt;Distributionnnnn&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The version of AsciidoctorJ matches the version of Asciidoctor RubyGem it bundles.
AsciidoctorJ is published to Maven Central and Bintray.
The artifact information can be found in the tables below.&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 1. Artifact information for AsciidoctorJ in jCenter (Bintray)&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 40%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Group Id&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Artifact Id&lt;/th&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;Version&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Download&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;https://bintray.com/asciidoctor/maven/asciidoctorj/view/general&quot;&gt;asciidoctorj&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;https://bintray.com/asciidoctor/maven/asciidoctorj/1.5.4/view&quot;&gt;1.5.4&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;http://dl.bintray.com/asciidoctor/maven/org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4.pom&quot;&gt;pom&lt;/a&gt; &lt;a href=&quot;http://dl.bintray.com/asciidoctor/maven/org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4.jar&quot;&gt;jar&lt;/a&gt; &lt;a href=&quot;http://dl.bintray.com/asciidoctor/maven/org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4-javadoc.jar&quot;&gt;javadoc (jar)&lt;/a&gt; &lt;a href=&quot;http://dl.bintray.com/asciidoctor/maven/org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4-sources.jar&quot;&gt;sources (jar)&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;asciidoctorj-epub3&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1.5.0-alpha.6&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;asciidoctorj-pdf&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1.5.0-alpha.11&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 2. Artifact information for AsciidoctorJ in Maven Central&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 40%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Group Id&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Artifact Id&lt;/th&gt;
&lt;th class=&quot;tableblock halign-center valign-top&quot;&gt;Version&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Download&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.asciidoctor%22%20AND%20a%3A%22asciidoctorj%22%20AND%20v%3A%221.5.4%22&quot;&gt;asciidoctorj&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;http://search.maven.org/#artifactdetails%7Corg.asciidoctor%7Casciidoctorj%7C1.5.4%7Cjar&quot;&gt;1.5.4&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;http://search.maven.org/remotecontent?filepath=org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4.pom&quot;&gt;pom&lt;/a&gt; &lt;a href=&quot;http://search.maven.org/remotecontent?filepath=org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4.jar&quot;&gt;jar&lt;/a&gt; &lt;a href=&quot;http://search.maven.org/remotecontent?filepath=org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4-javadoc.jar&quot;&gt;javadoc (jar)&lt;/a&gt; &lt;a href=&quot;http://search.maven.org/remotecontent?filepath=org/asciidoctor/asciidoctorj/1.5.4/asciidoctorj-1.5.4-sources.jar&quot;&gt;sources (jar)&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;asciidoctorj-epub3&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1.5.0-alpha.6&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;asciidoctorj-pdf&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1.5.0-alpha.11&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The artifactId changed to &lt;code&gt;asciidoctorj&lt;/code&gt; starting in 1.5.0.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_installation&quot;&gt;Installation&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;AsciidoctorJ is a standard &lt;code&gt;.jar&lt;/code&gt; file.
To start using it, you need to add the library to your project&amp;#8217;s classpath.
To start using it under WildFly AS, you can&amp;#8217;t just use it, you also have to &lt;em&gt;modify your WildFly installation&lt;/em&gt;
due to classpath loading issues; see &lt;a href=&quot;#wildfly-kludge&quot;&gt;Running AsciidoctorJ on WildFly AS&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Declaring the dependency in a Maven build file (i.e., pom.xml)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;asciidoctorj&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.4&amp;lt;/version&amp;gt; &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Declaring the dependency in a Gradle build file (e.g., build.gradle)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;dependencies {
  compile 'org.asciidoctor:asciidoctorj:1.5.4'
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Declaring the dependency in an SBT build file (e.g., build.sbt)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;libraryDependencies += &quot;org.asciidoctor&quot; % &quot;asciidoctorj&quot; % &quot;1.5.4&quot; &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Specifying the version of AsciidoctorJ implicitly selects the version of Asciidoctor&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Declaring the dependency in a Leiningen build file (e.g., project.clj)&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;:dependencies [[org.asciidoctor/asciidoctorj &quot;1.5.4&quot;]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Tip&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In addition to using AsciidoctorJ directly, you can invoke it as part of your build using the Maven or Gradle plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://asciidoctor.org/docs/install-and-use-asciidoctor-maven-plugin&quot;&gt;How to Install and Use the Asciidoctor Maven Plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://asciidoctor.org/docs/install-and-use-asciidoctor-gradle-plugin&quot;&gt;How to Install and Use the Asciidoctor Gradle Plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_converting_documents&quot;&gt;Converting documents&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The main entry point for AsciidoctorJ is the &lt;code&gt;Asciidoctor&lt;/code&gt; Java interface.
This interface provides four methods for converting AsciiDoc content.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;convertFile&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;convertFiles&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;convertDirectory&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You&amp;#8217;ll learn about these methods in the &lt;a href=&quot;#converting-documents&quot;&gt;converting documents section&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock important&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Important&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Prior to Asciidoctor 1.5.0, the term &lt;code&gt;render&lt;/code&gt; was used in these method names instead of &lt;code&gt;convert&lt;/code&gt; (i.e., &lt;code&gt;render&lt;/code&gt;, &lt;code&gt;renderFile&lt;/code&gt;, &lt;code&gt;renderFiles&lt;/code&gt; and &lt;code&gt;renderDirectory&lt;/code&gt;).
AsciidoctorJ continues to support the old method names for backwards compatibility.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 3. Convert methods on the &lt;code&gt;Asciidoctor&lt;/code&gt; interface&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Method Name&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Return Type&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Parses AsciiDoc content read from a string or stream and converts it to the format specified by the &lt;code&gt;backend&lt;/code&gt; option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;convertFile&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Parses AsciiDoc content read from a file and converts it to the format specified by the &lt;code&gt;backend&lt;/code&gt; option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;convertFiles&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Parses a collection of AsciiDoc files and converts them to the format specified by the &lt;code&gt;backend&lt;/code&gt; option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;convertDirectory&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Parses all AsciiDoc files found in the specified directory (using the provided strategy) and converts them to the format specified by the &lt;code&gt;backend&lt;/code&gt; option.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
All the methods listed in Table 3 are overloaded to accommodate various input types and options.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You retrieve an instance of the &lt;code&gt;Asciidoctor&lt;/code&gt; interface from the factory method provided.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Creating an Asciidoctor instance from Asciidoctor.Factory&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.Asciidoctor.Factory.create;
import org.asciidoctor.Asciidoctor;

Asciidoctor asciidoctor = create();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Once you retrieve an instance of the &lt;code&gt;Asciidoctor&lt;/code&gt; interface, you can use it to convert AsciiDoc content.
Here&amp;#8217;s an example of using AsciidoctorJ to convert an AsciiDoc string.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The following &lt;code&gt;convertFile&lt;/code&gt; or &lt;code&gt;convertFiles&lt;/code&gt; methods will only return a converted &lt;code&gt;String&lt;/code&gt; object or array if you disable writing to a file, which is enabled by default.
To disable writing to a file, create a new &lt;code&gt;Options&lt;/code&gt; object, disable the option to create a new file with &lt;code&gt;option.setToFile(false)&lt;/code&gt;, and then pass the object as a parameter to &lt;code&gt;convertFile&lt;/code&gt; or &lt;code&gt;convertFiles&lt;/code&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Converting an AsciiDoc string&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import java.util.HashMap;
//...

String html = asciidoctor.convert(
    &quot;Writing AsciiDoc is _easy_!&quot;,
    new HashMap&amp;lt;String, Object&amp;gt;());
System.out.println(html);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;convertFile&lt;/code&gt; method will convert the contents of an AsciiDoc file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Converting an AsciiDoc file&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import java.util.HashMap;
//...

String html = asciidoctor.convertFile(
    new File(&quot;sample.adoc&quot;),
    new HashMap&amp;lt;String, Object&amp;gt;());
System.out.println(html);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;convertFiles&lt;/code&gt; method will convert a collection of AsciiDoc files:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Converting a collection of AsciiDoc files&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import java.util.Arrays;
//...

String[] result = asciidoctor.convertFiles(
    Arrays.asList(new File(&quot;sample.adoc&quot;)),
    new HashMap&amp;lt;String, Object&amp;gt;());

for (String html : result) {
    System.out.println(html);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock warning&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Warning&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
If the converted content is written to files, the &lt;code&gt;convertFiles&lt;/code&gt; method will return a String Array (i.e., &lt;code&gt;String[]&lt;/code&gt;) with the names of all the converted documents.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another method provided by the &lt;code&gt;Asciidoctor&lt;/code&gt; interface is &lt;code&gt;convertDirectory&lt;/code&gt;.
This method converts all of the files with AsciiDoc extensions (&lt;code&gt;.adoc&lt;/code&gt; &lt;em&gt;(preferred)&lt;/em&gt;, &lt;code&gt;.ad&lt;/code&gt;, &lt;code&gt;.asciidoc&lt;/code&gt;, &lt;code&gt;.asc&lt;/code&gt;) that are present within a specified folder and following given strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;An instance of the &lt;code&gt;DirectoryWalker&lt;/code&gt; interface, which provides a strategy for locating files to process, must be passed as the first parameter of the &lt;code&gt;convertDirectory&lt;/code&gt; method.
Currently &lt;code&gt;Asciidoctor&lt;/code&gt; provides two built-in implementations of the &lt;code&gt;DirectoryWalker&lt;/code&gt; interface:&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 4. Built-in &lt;code&gt;DirectoryWalker&lt;/code&gt; implementations&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%;&quot;&gt;
&lt;col style=&quot;width: 66%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Class&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;AsciiDocDirectoryWalker&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Converts all files of given folder and all its subfolders. Ignores files starting with underscore (_).&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;GlobDirectoryWalker&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;Converts all files of given folder following a glob expression.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If the converted content is not written into files, &lt;code&gt;convertDirectory&lt;/code&gt; will return an array listing all the documents converted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Converting all AsciiDoc files in a directory&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import org.asciidoctor.AsciiDocDirectoryWalker;
//...

String[] result = asciidoctor.convertDirectory(
    new AsciiDocDirectoryWalker(&quot;src/asciidoc&quot;),
    new HashMap&amp;lt;String, Object&amp;gt;());

for (String html : result) {
    System.out.println(html);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another way to convert AsciiDoc content is by calling the &lt;code&gt;convert&lt;/code&gt; method and providing a standard Java &lt;code&gt;java.io.Reader&lt;/code&gt; and &lt;code&gt;java.io.Writer&lt;/code&gt;.
The &lt;code&gt;Reader&lt;/code&gt; interface is used as the source, and the converted content is written to the &lt;code&gt;Writer&lt;/code&gt; interface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Converting content read from a java.io.Reader to a java.io.Writer&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import java.io.FileReader;
import java.io.StringWriter;
//...

FileReader reader = new FileReader(new File(&quot;sample.adoc&quot;));
StringWriter writer = new StringWriter();

asciidoctor.convert(reader, writer, options().asMap());

StringBuffer htmlBuffer = writer.getBuffer();
System.out.println(htmlBuffer.toString());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_safe_mode_and_file_system_access&quot;&gt;Safe mode and file system access&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Asciidoctor provides security levels that control the read and write access of attributes, the include directive, macros, and scripts while a document is processing. Each level includes the restrictions enabled in the prior security level.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When Asciidoctor (and AsciidoctorJ) is used as &lt;em&gt;API&lt;/em&gt;, it uses &lt;code&gt;SECURE&lt;/code&gt; safe mode by default.
This mode is the most restrictive one and in summary it disallows the document from attempting to read files from the file system and including their contents into the document.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We recommend you to set &lt;code&gt;SAFE&lt;/code&gt; safe mode when rendering AsciiDoc documents using AsciidoctorJ to have almost all Asciidoctor features such as &lt;em&gt;icons&lt;/em&gt;, &lt;em&gt;include directive&lt;/em&gt; or retrieving content from &lt;em&gt;URIs&lt;/em&gt; enabled.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Safe mode is set as option when a document is rendered.
For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.OptionsBuilder.options;

Map&amp;lt;String, Object&amp;gt; options = options().safe(SafeMode.SAFE)
                                       .asMap();

String outfile = asciidoctor.convertFile(new File(&quot;sample.adoc&quot;), options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We are going to explain in more detail options in &lt;a href=&quot;#conversion-options&quot;&gt;next section&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can read more about safe modes in &lt;a href=&quot;http://asciidoctor.org/docs/user-manual/#running-asciidoctor-securely&quot; class=&quot;bare&quot;&gt;http://asciidoctor.org/docs/user-manual/#running-asciidoctor-securely&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_conversion_options&quot;&gt;Conversion options&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Asciidoctor supports numerous options, such as:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;in_place&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Converts the output to a file adjacent to the input file.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;template_dirs&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Specifies a directory of &lt;a href=&quot;https://github.com/rtomayko/tilt&quot;&gt;Tilt&lt;/a&gt;-compatible templates to be used instead of the default built-in templates&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;A Hash (key-value pairs) of attributes to configure various aspects of the AsciiDoc processor&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The second parameter of the &lt;code&gt;convert&lt;/code&gt; method is &lt;code&gt;java.util.Map&lt;/code&gt;.
The options listed above can be set in &lt;code&gt;java.util.Map&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Using the &lt;code&gt;in_place&lt;/code&gt; option and the &lt;code&gt;backend&lt;/code&gt; attribute&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Map&amp;lt;String, Object&amp;gt; attributes = new HashMap&amp;lt;String, Object&amp;gt;();
attributes.put(&quot;backend&quot;, &quot;docbook&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

Map&amp;lt;String, Object&amp;gt; options = new HashMap&amp;lt;String, Object&amp;gt;();
options.put(&quot;attributes&quot;, attributes); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
options.put(&quot;in_place&quot;, true); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

String outfile = asciidoctor.convertFile(new File(&quot;sample.adoc&quot;), options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines the &lt;code&gt;backend&lt;/code&gt; attribute as &lt;code&gt;docbook&lt;/code&gt; in the attributes map&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registers the attributes map as the &lt;code&gt;attributes&lt;/code&gt; option in the options map&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines the &lt;code&gt;in_place&lt;/code&gt; option in the options map&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another way for setting options is by using &lt;code&gt;org.asciidoctor.Options&lt;/code&gt; class.
&lt;code&gt;Options&lt;/code&gt; is a simple Java class which contains methods for setting required options.
Note that related with &lt;code&gt;org.asciidoctor.Options&lt;/code&gt; class, there is &lt;code&gt;org.asciidoctor.Attributes&lt;/code&gt; class, which can be used for setting attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;convert&lt;/code&gt; method is overloaded so &lt;code&gt;org.asciidoctor.Options&lt;/code&gt; can be passed instead of a &lt;code&gt;java.util.Map&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Using the in_place option and the backend attribute&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Attributes attributes = new Attributes();
attributes.setBackend(&quot;docbook&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

Options options = new Options();
options.setAttributes(attributes); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
options.setInPlace(true); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

String outfile = asciidoctor.convertFile(new File(&quot;sample.adoc&quot;), options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines the &lt;code&gt;backend&lt;/code&gt; attribute as &lt;code&gt;docbook&lt;/code&gt; in the attributes class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registers the attributes class as the &lt;code&gt;attributes&lt;/code&gt; option in the options class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines the &lt;code&gt;in_place&lt;/code&gt; option in the options class&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;AsciidoctorJ also provides two builder classes to create these maps and classes in a more readable form.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;AttributesBuilder&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Used to define attributes with a fluent API&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;OptionsBuilder&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Used to define options with a fluent API&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code below results in the same output as the previous example but uses the builder classes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Setting attributes and options with the builder classes&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.AttributesBuilder.attributes;
import static org.asciidoctor.OptionsBuilder.options;

//...
Map&amp;lt;String, Object&amp;gt; attributes = attributes().backend(&quot;docbook&quot;) &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
                                             .asMap();

Map&amp;lt;String, Object&amp;gt; options = options().inPlace(true)
                                       .attributes(attributes) &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
                                       .asMap(); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

String outfile = asciidoctor.convertFile(new File(&quot;sample.adoc&quot;), options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines the &lt;code&gt;backend&lt;/code&gt; attribute as &lt;code&gt;docbook&lt;/code&gt; using fluent API.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registers the attributes map as &lt;code&gt;attributes&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Converts options to &lt;code&gt;java.util.Map&lt;/code&gt; instance.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Setting attributes and options with the builder classes&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.AttributesBuilder.attributes;
import static org.asciidoctor.OptionsBuilder.options;

//...
Attributes attributes = attributes().backend(&quot;docbook&quot;).get(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
Options options = options().inPlace(true).attributes(attributes).get(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String outfile = asciidoctor.convertFile(new File(&quot;sample.adoc&quot;), options); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines and returns an &lt;code&gt;Attributes&lt;/code&gt; class instead of &lt;code&gt;java.util.Map&lt;/code&gt; by calling &lt;code&gt;get()&lt;/code&gt; method instead of &lt;code&gt;asMap()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defines and returns an &lt;code&gt;Options&lt;/code&gt; class instead of &lt;code&gt;java.util.Map&lt;/code&gt; by calling &lt;code&gt;get()&lt;/code&gt; method instead of &lt;code&gt;asMap()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Converts the document passing &lt;code&gt;Options&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Tip&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
All methods used to convert content are overloaded with &lt;code&gt;OptionsBuilder&lt;/code&gt; parameter, so it is no longer required to call &lt;code&gt;get&lt;/code&gt; nor &lt;code&gt;asMap&lt;/code&gt; methods.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock warning&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Warning&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The &lt;code&gt;icons&lt;/code&gt; attribute requires a &lt;code&gt;String&lt;/code&gt; to set the value used to “draw” icons.
At this time, you can use two constants &lt;code&gt;org.asciidoctor.Attributes.IMAGE_ICONS&lt;/code&gt; for using the same approach as AsciiDoc, that is using &lt;code&gt;img&lt;/code&gt; tags, or &lt;code&gt;org.asciidoctor.Attributes.FONT_ICONS&lt;/code&gt; for using icons from &lt;a href=&quot;http://fortawesome.github.io/Font-Awesome&quot; target=&quot;_blank&quot;&gt;Font Awesome&lt;/a&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Attributes can be specified as &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; instead of pair key/value by using &lt;code&gt;org.asciidoctor.Attributes.setAttributes(String)&lt;/code&gt; or &lt;code&gt;org.asciidoctor.Attributes.setAttributes(String...)&lt;/code&gt; and &lt;code&gt;AttributesBuilder&lt;/code&gt; methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Passing attributes as a string&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
Attributes attributes = attributes().attributes(&quot;toc numbered&quot;).get();
Options options = options().attributes(attributes).get();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Passing attributes as a string is equivalent to passing individual attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Passing individual attributes&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
Attributes attributes = attributes().tableOfContents(true).sectionNumbers(true).get();
Options options = options().attributes(attributes).get();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can also use an array.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Passing attributes as an array&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
String[] attributesArray = new String[]{&quot;toc&quot;, &quot;source-highlighter=coderay&quot;};
Attributes attributes = attributes().attributes(attributesArray).sectionNumbers(true).get();
Options options = options().attributes(attributes).get();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Passing attributes as an array is equivalent to passing individual attribute.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Passing individual attributes&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
Attributes attributes = attributes().tableOfContents(true).sectionNumbers(true).sourceHighlighter(&quot;coderay&quot;).get();
Options options = options().attributes(attributes).get();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_locating_files&quot;&gt;Locating files&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A utility class &lt;code&gt;AsciiDocDirectoryWalker&lt;/code&gt; is available for searching the AsciiDoc files present in a root folder and its subfolders.
&lt;code&gt;AsciiDocDirectoryWalker&lt;/code&gt; locates all files that end with &lt;code&gt;.adoc&lt;/code&gt;, &lt;code&gt;.ad&lt;/code&gt;, &lt;code&gt;.asciidoc&lt;/code&gt; or &lt;code&gt;.asc&lt;/code&gt;.
Also it ignores all files starting with underscore (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Locating AsciiDoc files with &lt;code&gt;AsciiDocDirectoryWalker&lt;/code&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.util.List;
import org.asciidoctor.AsciiDocDirectoryWalker;

DirectoryWalker directoryWalker = new AsciiDocDirectoryWalker(&quot;docs&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
List&amp;lt;File&amp;gt; asciidocFiles = directoryWalker.scan(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines which parent directory is used for searching.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Returns a list of all AsciiDoc files found in root folder and its subfolders.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A utility class &lt;code&gt;GlobDirectoryWalker&lt;/code&gt; is available for searching the AsciiDoc files present in a root folder and scanning using a &lt;code&gt;Glob&lt;/code&gt; expression.
&lt;code&gt;GlobDirectoryWalker&lt;/code&gt; locates all files that end with &lt;code&gt;.adoc&lt;/code&gt;, &lt;code&gt;.ad&lt;/code&gt;, &lt;code&gt;.asciidoc&lt;/code&gt; or &lt;code&gt;.asc&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Locating AsciiDoc files with &lt;code&gt;GlobDirectoryWalker&lt;/code&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.util.List;
import org.asciidoctor.GlobDirectoryWalker;

DirectoryWalker directoryWalker = new GlobDirectoryWalker(&quot;docs&quot;, &quot;**/*.adoc&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
List&amp;lt;File&amp;gt; asciidocFiles = directoryWalker.scan(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defines which parent directory is used for searching and the glob expression.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Returns a list of all AsciiDoc files matching given glob expression.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_reading_the_document_tree&quot;&gt;Reading the document tree&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Instead of converting an AsciiDoc document, you may want to parse the document to read information it contains or navigate the document&amp;#8217;s structure.
AsciidoctorJ let&amp;#8217;s you do this!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are two approaches you can take to read the structure of an AsciiDoc document with AsciidoctorJ.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Using wrapper classes not connected with Ruby internal model&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;The structure is copied in Java non-proxied classes so any change does not modify the original document.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Using JRuby Java wrapper classes&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;The Java classes are linked to Ruby internal classes.
Any modifications done here are reflected to the original document.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_wrapping_classes&quot;&gt;Wrapping classes&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example AsciiDoc document with header information&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Sample Document
Doc Writer &amp;lt;doc.writer@asciidoc.org&amp;gt;; John Smith &amp;lt;john.smith@asciidoc.org&amp;gt;
v1.0, 2013-05-20: First draft
:title: Sample Document
:tags: [document, example]

Preamble...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;readDocumentHeader&lt;/code&gt; method on the &lt;code&gt;Asciidoctor&lt;/code&gt; interface retrieves information from the header of an AsciiDoc document without parsing or converting the entire document.
This method returns an instance of &lt;code&gt;org.asciidoctor.ast.DocumentHeader&lt;/code&gt; with all information from the header filled.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Reading header information from the AsciiDoc document&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//...
import org.asciidoctor.ast.DocumentHeader;

//...
DocumentHeader header = asciidoctor.readDocumentHeader(
    new File(&quot;header-sample.adoc&quot;));

System.out.println(header.getDocumentTitle().getMain()); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

Author author = header.getAuthor(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
System.out.println(author.getEmail()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
System.out.println(author.getFullName()); &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;

RevisionInfo revisionInfo = header.getRevisionInfo();

System.out.println(revisionInfo.getDate()); &lt;b class=&quot;conum&quot;&gt;(5)&lt;/b&gt;
System.out.println(revisionInfo.getNumber()); &lt;b class=&quot;conum&quot;&gt;(6)&lt;/b&gt;
System.out.println(revisionInfo.getRemark()); &lt;b class=&quot;conum&quot;&gt;(7)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;Sample Document&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;Doc Writer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;doc.writer@asciidoc.org&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;Doc Writer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;2013-05-20&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;1.0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prints &lt;code&gt;First draft&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;readDocumentHeader&lt;/code&gt; method can be extremely useful for building an index of documents.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.io.File;
import java.util.HashSet;
import java.util.Set;
import org.asciidoctor.Asciidoctor;
import org.asciidoctor.AsciiDocDirectoryWalker;
import org.asciidoctor.DirectoryWalker;
import org.asciidoctor.DocumentHeader;

//...

Asciidoctor asciidoctor = Asciidoctor.Factory.create();
Set&amp;lt;DocumentHeader&amp;gt; documentIndex = new HashSet&amp;lt;DocumentHeader&amp;gt;();
DirectoryWalker directoryWalker = new AsciiDocDirectoryWalker(&quot;docs&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

for (File file : directoryWalker.scan()) {
  documentIndex.add(asciidoctor.readDocumentHeader(file));
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Converts all files in the &lt;code&gt;docs&lt;/code&gt; folder and its subfolders.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can also load the document inside a &lt;code&gt;Document&lt;/code&gt; object.
This object represents the whole document, including its headers.
You can use it to navigate through the internals of a parsed document.
To load a document, use the &lt;code&gt;load&lt;/code&gt; or &lt;code&gt;loadFile&lt;/code&gt; methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;readDocumentStructure&lt;/code&gt; method provides a useful way of parsing an AsciiDoc file into the structured object.
First, it gathers the same information as &lt;code&gt;readDocumentHeader&lt;/code&gt; and puts it in the &lt;code&gt;header&lt;/code&gt; field of the &lt;code&gt;StructuredDocument&lt;/code&gt; object.
The actual content of the file is split into separate ContentParts based on blocks of the content.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This feature provides several use cases.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AsciiDoc document with two blocks defined by section titles&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Sample Document

== Section one
This is content of section one

== Section two
And content of section two

...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Each section defines new content part.
List of all parts can be get by &lt;code&gt;getParts&lt;/code&gt; method on &lt;code&gt;StructuredDocument&lt;/code&gt;.
Each part will than contain of title (i.e. &quot;Section one&quot;) and converted text content as html.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Print content of each part&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;for (ContentPart part : document.getParts()){
  System.out.println(part.getTitle());
  System.out.println(&quot;----&quot;);
  System.out.println(part.getContent);
  System.out.println(&quot;----&quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AsciiDoc document with two blocks defined by styles&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;= Sample Document

[style one]
This is content of first content part

[[partId]]
[style two,role=partRole]
--
And content of second content part

This block can be as long as you want.
--&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This way you can then use methods like &lt;code&gt;getPartByStyle&lt;/code&gt; to retrieve particular content parts.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Retrieve content part by style&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;ContentPart style_two = document.getPartByStyle(&quot;style two&quot;);
// other possible way of retrieving parts:
ContentPart style_two = document.getPartById(&quot;partId&quot;)
ContentPart style_two = document.getPartByRole(&quot;partRole&quot;)

//and also for lists
List&amp;lt;ContentPart&amp;gt; parts = document.getPartsByStyle(&quot;style two&quot;);
List&amp;lt;ContentPart&amp;gt; parts = document.getPartsByRole(&quot;partRole&quot;);
List&amp;lt;ContentPart&amp;gt; parts = document.getPartsByContext(&quot;open&quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Really nice thing about it is possibility to parse images to &lt;code&gt;Image&lt;/code&gt; object that you can use
later to embed in html page directly from your java code or manipulate in any other way.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Define images&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;[Images]
image::src/some{sp}image{sp}1.JPG[TODO title1,link=&quot;link1.html&quot;]
image::src/some{sp}image{sp}2.JPG[TODO title2,link=&quot;link2.html&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to get a list of images defined in the document and then to process images:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Retrieve image information&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;List&amp;lt;ContentPart&amp;gt; images = document.getPartsByContext(&quot;image&quot;);
for (ContentPart image : images){
  String src = (String) image.getAttributes().get(&quot;target&quot;);
  String alt = (String) image.getAttributes().get(&quot;alt&quot;);
  String link = (String) image.getAttributes().get(&quot;link&quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As of final example consider following complete use case:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;AsciiDoc document with product definition&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Sample product
v1.0, 2013-10-12
:hardbreaks:

:price: 70 pln
:smallImage: photos/small/small_image.jpg

[Description]
short product description

[Images]
image::photos/image1.jpg[title]
image::photos/image2.jpg[title]


[Detail]
--
Detail information about product. Note that you can use all asciidoc features here like:
.simple list
* lists
* images
* titles
* further blocks

[role=text-center]
also you can also add css style by assigning role to the text.
--&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and the way it can be than transformed to java object:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Java method for getting product&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Product product = new Product();
product.setTitle(document.getHeader().getDocumentTitle());
product.setPrice(new Price((String) document.getHeader().getAttributes().get(&quot;price&quot;)));
product.setSmallImage(new Image((String)document.getHeader().getAttributes().get(&quot;smallImage&quot;),product.getTitle()));

product.setDescription(document.getPartByStyle(&quot;description&quot;).getContent());

List&amp;lt;ContentPart&amp;gt; images = document.getPartsByContext(&quot;image&quot;);
for (ContentPart image : images) {
  Image image = new Image();
  image.setSrc((String) image.getAttributes().get(&quot;target&quot;));
  image.setAlt((String) image.getAttributes().get(&quot;alt&quot;));
  product.getImages().add(image);
}

product.setDetail(document.getPartByStyle(&quot;detail&quot;).getContent());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last feature of structure document is possibility to configure how deeply should blocks be processed.
Default is one level only so if you want to have more nested structure add &lt;code&gt;STRUCTURE_MAX_LEVEL&lt;/code&gt; parameter to processing options.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Configuration of the structure document processing&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Map&amp;lt;String,Object&amp;gt; parameters = new HashMap&amp;lt;String, Object&amp;gt;();
parameters.put(Asciidoctor.STRUCTURE_MAX_LEVEL, 2);
StructuredDocument document = asciidoctor.readDocumentStructure(
    new File(&quot;target/test-classes/documentblocks.asciidoc&quot;),
    parameters);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jruby_wrapping_classes&quot;&gt;JRuby wrapping classes&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import org.asciidoctor.ast.Document;

//...

Document document = asciidoctor.load(DOCUMENT, new HashMap&amp;lt;String, Object&amp;gt;()); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
assertThat(document.doctitle(), is(&quot;Document Title&quot;)); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Document from an String is loaded into &lt;code&gt;Document&lt;/code&gt; object.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Title of the document is retrieved.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But also all blocks that conforms the document can be retrieved.
Currently there are support for three kinds of blocks.
&lt;code&gt;Blocks&lt;/code&gt; itself, &lt;code&gt;Section&lt;/code&gt; for sections of the document and &lt;code&gt;AbstractBlock&lt;/code&gt; which is the base type where all kind of blocks (including those not mapped as Java class) are mapped.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import org.asciidoctor.ast.Document;
import org.asciidoctor.ast.Section;

//...

Document document = asciidoctor.load(DOCUMENT, new HashMap&amp;lt;String, Object&amp;gt;()); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
Section section = (Section) document.blocks().get(1); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

assertThat(section.index(), is(0)); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
assertThat(section.sectname(), is(&quot;sect1&quot;));
assertThat(section.special(), is(false));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Document from an String is loaded into &lt;code&gt;Document&lt;/code&gt; object.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All blocks are get and because in this example the first block is a Section block, we cast it directly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Concrete methods for sections can be called.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Blocks can also be retrieved from query using &lt;code&gt;findBy&lt;/code&gt; method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Document document = asciidoctor.load(DOCUMENT, new HashMap&amp;lt;String, Object&amp;gt;());
Map&amp;lt;Object, Object&amp;gt; selector = new HashMap&amp;lt;Object, Object&amp;gt;(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
selector.put(&quot;context&quot;, &quot;:image&quot;); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

List&amp;lt;AbstractBlock&amp;gt; findBy = document.findBy(selector);
assertThat(findBy, hasSize(2)); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To make queries you need to use a &lt;code&gt;map&lt;/code&gt; approach. Currently this is because of the Asciidoctor API but it will change in near future.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In this example all blocks with context as image is returned. Notice that the colon (&lt;code&gt;:&lt;/code&gt;) must be added in the value part.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Document used as example contains two images.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_extension_api&quot;&gt;Extension API&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the major improvements to Asciidoctor recently is the extensions API.
AsciidoctorJ brings this extension API to the JVM environment.
&lt;a href=&quot;https://github.com/asciidoctor/asciidoctorj&quot;&gt;AsciidoctorJ&lt;/a&gt; allows us to write extensions in Java instead of Ruby.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Asciidoctor provides seven types of extension points.
Each extension point has an abstract class in Java that maps to the extension API in Ruby.&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 5. AsciidoctorJ extension APIs&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%;&quot;&gt;
&lt;col style=&quot;width: 66%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Preprocessor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.Preprocessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Treeprocessor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.Treeprocessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Postprocessor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.Postprocessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Block processor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.BlockProcessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Block macro processor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.BlockMacroProcessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Inline macro processor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.InlineMacroProcessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Include processor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.IncludeProcessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;Docinfo processor&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;org.asciidoctor.extension.DocinfoProcessor&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To create an extension two things are required:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Create a class implementing an extension class (this will depend on the kind of interface being developed)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Register your class using the &lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;An extension can be registered by:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Passing as String a fully qualified class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Passing a Class object of the extension.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Passing an instance of the extension object.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
In the first two cases, the lifecycle of the instance is managed by JRuby.
In the last case, the caller is the owner of the lifecycle of the object.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Tip&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Using an already created instance as an extension is useful when using CDI.
For example, you can inject any extension inside the code and then register that instance as an extension.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_preprocessor&quot;&gt;Preprocessor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension updates an attribute value defined in a document.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Preprocessor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ChangeAttributeValuePreprocessor extends Preprocessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

	public ChangeAttributeValuePreprocessor(Map&amp;lt;String, Object&amp;gt; config) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
		super(config);
	}

	@Override
	public PreprocessorReader process(Document document, PreprocessorReader reader) { &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
		document.getAttributes().put(&quot;content&quot;, &quot;Alex&quot;);
		return reader;
	}

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;Preprocessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A constructor receiving a &lt;code&gt;Map&lt;/code&gt; must be provided in case you want to send options to the preprocessor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;process&lt;/code&gt; method receives a &lt;code&gt;Document&lt;/code&gt; and &lt;code&gt;PreprocessorReader&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Preprocessor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.preprocessor(ChangeAttributeValuePreprocessor.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/changeattribute.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Preprocessor&lt;/code&gt; extension is registered by using &lt;code&gt;Class&lt;/code&gt; approach.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usual; no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_treeprocessor&quot;&gt;Treeprocessor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension detects literal blocks that contain terminal commands.
It strips the prompt character and styles the command.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Treeprocessor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class TerminalCommandTreeprocessor extends Treeprocessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  private Document document;

  public TerminalCommandTreeprocessor(Map&amp;lt;String, Object&amp;gt; config) {
      super(config);
  }

  @Override
  public Document process(Document document) {

    this.document = document;

    final List&amp;lt;AbstractBlock&amp;gt; blocks = this.document.getBlocks(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

    for (int i = 0; i &amp;lt; blocks.size(); i++) {
        final AbstractBlock currentBlock = blocks.get(i);
        if(currentBlock instanceof Block) {
            Block block = (Block)currentBlock;
            List&amp;lt;String&amp;gt; lines = block.lines(); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
            if (lines.size() &amp;gt; 0 &amp;amp;&amp;amp; lines.get(0).startsWith(&quot;$&quot;)) {
                blocks.set(i, convertToTerminalListing(block));
            }
        }
    }

    return this.document;
  }

  public Block convertToTerminalListing(Block block) {

    Map&amp;lt;String, Object&amp;gt; attributes = block.getAttributes();
    attributes.put(&quot;role&quot;, &quot;terminal&quot;);
    StringBuilder resultLines = new StringBuilder();

    List&amp;lt;String&amp;gt; lines = block.lines();

    for (String line : lines) {
        if (line.startsWith(&quot;$&quot;)) {
            resultLines.append(&quot;&amp;lt;span class=\&quot;command\&quot;&amp;gt;&quot;)
                       .append(line.substring(2, line.length()))
                       .append(&quot;&amp;lt;/span&amp;gt;&quot;);
        }
        else {
            resultLines.append(line);
        }
    }

    return createBlock(this.document, &quot;listing&quot;, Arrays.asList(resultLines.toString()), attributes,
              new HashMap&amp;lt;Object, Object&amp;gt;()); &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;Treeprocessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;document&lt;/code&gt; instance can be used to retrieve all blocks of the current document.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All of the select block&amp;#8217;s lines are retrieved.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To create a new block, you must use the &lt;code&gt;createBlock&lt;/code&gt; method. Set the parent document, the context (&lt;em&gt;listing&lt;/em&gt;), the text content, attributes and options.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Treeprocessor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.treeprocessor(&quot;org.asciidoctor.extension.TerminalCommandTreeprocessor&quot;); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-terminal-command.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Treeprocessor&lt;/code&gt; extension is registered using fully qualified class name as &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually, no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_postprocessor&quot;&gt;Postprocessor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension inserts custom footer text.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Postprocessor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class CustomFooterPostProcessor extends Postprocessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  public CustomFooterPostProcessor(Map&amp;lt;String, Object&amp;gt; config) {
      super(config);
  }

  @Override
  public String process(Document document, String output) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

      String copyright  = &quot;Copyright Acme, Inc.&quot;;

      if(document.basebackend(&quot;html&quot;)) {
          org.jsoup.nodes.Document doc = Jsoup.parse(output, &quot;UTF-8&quot;);

          Element contentElement = doc.getElementById(&quot;footer-text&quot;);
          contentElement.append(copyright);

          output = doc.html();

      }
      return output; &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;Postprocessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;process&lt;/code&gt; method receives the &lt;code&gt;Document&lt;/code&gt; instance and the document converted as &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The content that will be written in document is returned.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Postprocessor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.postprocessor(new CustomFooterPostProcessor(
				                        new HashMap&amp;lt;String, Object&amp;gt;())); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
              &quot;sample.adoc&quot;),
              options); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Postprocessor&lt;/code&gt; extension is registered using an already created instance approach.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually, no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_docinfoprocessor&quot;&gt;DocinfoProcessor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension inserts custom content on header or footer of the document.
For example can be used for adding &lt;code&gt;meta&lt;/code&gt; tags on &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;DocinfoProcessor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class MetaRobotsDocinfoProcessor extends DocinfoProcessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

    public MetaRobotsDocinfoProcessor() {
        super();
    }

    public MetaRobotsDocinfoProcessor(Map&amp;lt;String, Object&amp;gt; config) {
        super(config);
    }

    @Override
    public String process(Document document) {
        return &quot;&amp;lt;meta name=\&quot;robots\&quot; content=\&quot;index,follow\&quot;&amp;gt;&quot;; &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;DocinfoProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In this case a meta tag is returned. By default &lt;em&gt;docinfo&lt;/em&gt; is placed on header.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To register the DocinfoProcessor extension just use the &lt;code&gt;JavaExtensionRegistry&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a DocinfoProcessor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry javaExtensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

javaExtensionRegistry.docinfoProcessor(MetaRobotsDocinfoProcessor.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.renderFile(
                classpath.getResource(&quot;simple.adoc&quot;),
                options().headerFooter(true).safe(SafeMode.SERVER).toFile(false).get());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DocinfoProcessor&lt;/code&gt; extension is registered using an already created instance approach.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to place &lt;em&gt;docinfo&lt;/em&gt; on footer you need to set &lt;code&gt;location&lt;/code&gt; option to &lt;code&gt;footer&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a DocinfoProcessor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry javaExtensionRegistry = this.asciidoctor.javaExtensionRegistry();

Map&amp;lt;String, Object&amp;gt; options = new HashMap&amp;lt;String, Object&amp;gt;();
options.put(&quot;location&quot;, &quot;:footer&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
MetaRobotsDocinfoProcessor metaRobotsDocinfoProcessor = new MetaRobotsDocinfoProcessor(options);

javaExtensionRegistry.docinfoProcessor(metaRobotsDocinfoProcessor);

String content = asciidoctor.renderFile(
                classpath.getResource(&quot;simple.adoc&quot;),
                options().headerFooter(true).safe(SafeMode.SERVER).toFile(false).get());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Sets the location option to footer. Note that a colon (:) is placed before &lt;em&gt;footer&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_block_processor&quot;&gt;Block processor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension registers a custom block style named &lt;em&gt;yell&lt;/em&gt; that uppercases all the words.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Block processor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class YellBlock extends BlockProcessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  public YellBlock(String name, Map&amp;lt;String, Object&amp;gt; config) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
      super(name, config);
  }

  @Override
  public Object process(AbstractBlock parent, Reader reader, Map&amp;lt;String, Object&amp;gt; attributes) { &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
      List&amp;lt;String&amp;gt; lines = reader.readLines();
      String upperLines = null;
      for (String line : lines) {
          if (upperLines == null) {
              upperLines = line.toUpperCase();
          }
          else {
              upperLines = upperLines + &quot;\n&quot; + line.toUpperCase();
          }
      }

		  return createBlock(parent, &quot;paragraph&quot;, Arrays.asList(upperLines), attributes, new HashMap&amp;lt;Object, Object&amp;gt;()); &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;BlockProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Constructor must receive the name of the block and a &lt;code&gt;Map&lt;/code&gt; for sending options to block.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;process&lt;/code&gt; method receives the parent block, a reader, and attributes defined in block.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To create a new block we must use &lt;code&gt;createBlock&lt;/code&gt; method. We must set the parent document, the context (listing), the text content, attributes and options.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Block processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.block(&quot;yell&quot;, YellBlock.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-yell-block.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BlockProcessor&lt;/code&gt; extension is registered with the context of block.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually, no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example of Block processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;[yell] &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
The time is now. Get a move on.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Note that &lt;em&gt;yell&lt;/em&gt; is the context where block lives and is the same as the first parameter of &lt;code&gt;block&lt;/code&gt; method of &lt;code&gt;ExtensionRegistry&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_block_macro_processor&quot;&gt;Block macro processor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension creates a block macro named gist for embedding a gist.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Block macro processor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class GistMacro extends BlockMacroProcessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  public GistMacro(String macroName, Map&amp;lt;String, Object&amp;gt; config) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
      super(macroName, config);
  }

  @Override
  public Block process(AbstractBlock parent, String target,
                        Map&amp;lt;String, Object&amp;gt; attributes) { &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

    String content = &quot;&amp;lt;div class=\&quot;content\&quot;&amp;gt;\n&quot; +
       		&quot;&amp;lt;script src=\&quot;https://gist.github.com/&quot;+target+&quot;.js\&quot;&amp;gt;&amp;lt;/script&amp;gt;\n&quot; +
       		&quot;&amp;lt;/div&amp;gt;&quot;;

    return createBlock(parent, &quot;pass&quot;, Arrays.asList(content), attributes,
                        this.getConfig()); &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;BlockMacroProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Constructor must receive the macro name, and a &lt;code&gt;Map&lt;/code&gt; for sending options to block..&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;process&lt;/code&gt; method receives the parent document, the content of the macro, and attributes defined in macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To create a new block we must use &lt;code&gt;createBlock&lt;/code&gt; method. We must set the parent document, the context (listing), the text content, attributes and options.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Block macro processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.blockMacro(&quot;gist&quot;, GistMacro.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-gist-macro.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JavaExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BlockMacroProcessor&lt;/code&gt; extension is registered with the name of the macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually, no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example of Block macro processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;.My Gist
gist::123456[] &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Note that &lt;em&gt;gist&lt;/em&gt; is the name of the macro and is the same as the first parameter of &lt;code&gt;blockMacro&lt;/code&gt; method of &lt;code&gt;ExtensionRegistry&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_inline_macro_processor&quot;&gt;Inline macro processor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This extension creates an inline macro named man that links to a manpage.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Inline macro processor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ManpageMacro extends InlineMacroProcessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  public ManpageMacro(String macroName, Map&amp;lt;String, Object&amp;gt; config) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
      super(macroName, config);
  }

  @Override
  protected String process(AbstractBlock parent, String target, Map&amp;lt;String, Object&amp;gt; attributes) { &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

      Map&amp;lt;String, Object&amp;gt; options = new HashMap&amp;lt;String, Object&amp;gt;();
      options.put(&quot;type&quot;, &quot;:link&quot;);
      options.put(&quot;target&quot;, target + &quot;.html&quot;);
      return createInline(parent, &quot;anchor&quot;, target, attributes, options).convert(); &lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;InlineMacroProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Constructor must receive the macro name, and a &lt;code&gt;Map&lt;/code&gt; for passing options to extension.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;process&lt;/code&gt; method receives the parent document, the content of the macro, and attributes defined in macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because it is an inline macro, only a replacement string must be returned.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register an Inline macro processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.inlineMacro(&quot;man&quot;, ManpageMacro.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-man-link.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InlineMacroProcessor&lt;/code&gt; extension is registered with the name of the macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually, no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example of Inline macro processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;See man:gittutorial[7] to get started. &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Note that &lt;em&gt;man&lt;/em&gt; is the name of the macro and is the same as the first parameter of &lt;code&gt;inlineMacro&lt;/code&gt; method of &lt;code&gt;ExtensionRegistry&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_include_processor&quot;&gt;Include processor&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Include a file from a URI.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Include processor example&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class UriIncludeProcessor extends IncludeProcessor { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  public UriIncludeProcessor(Map&amp;lt;String, Object&amp;gt; config) {
    super(config);
  }

  @Override
  public boolean handles(String target) {
    return target.startsWith(&quot;http://&quot;) || target.startsWith(&quot;https://&quot;); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
  }

  @Override
  public void process(DocumentRuby document, PreprocessorReader reader, String target,
            Map&amp;lt;String, Object&amp;gt; attributes) {

    StringBuilder content = readContent(target);
    reader.push_include(content.toString(), target, target, 1, attributes); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;

  }

  private StringBuilder readContent(String target) {

    StringBuilder content = new StringBuilder();

    try {

      URL url = new URL(target);
      InputStream openStream = url.openStream();

      BufferedReader bufferedReader = new BufferedReader(
                    new InputStreamReader(openStream));

      String line = null;
      while ((line = bufferedReader.readLine()) != null) {
        content.append(line);
      }

      bufferedReader.close();

      } catch (MalformedURLException e) {
          throw new IllegalArgumentException(e);
      } catch (IOException e) {
          throw new IllegalArgumentException(e);
      }
      return content;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Class must extend from &lt;code&gt;IncludeProcessor&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;handles&lt;/code&gt; method is used by processor to decide if included element should be converted by this processor or not. &lt;code&gt;target&lt;/code&gt; attribute is the value of &lt;code&gt;include&lt;/code&gt; macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;push_include&lt;/code&gt; method inserts new content (retrieved from the url) in current position of document.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register an Inline macro processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;JavaExtensionRegistry extensionRegistry = this.asciidoctor.javaExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionRegistry.includeProcessor(UriIncludeProcessor.class); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-uri-include.adoc&quot;),
                new Options()); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ExtensionRegistry&lt;/code&gt; class is created.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IncludeProcessor&lt;/code&gt; extension is registered.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can call any &lt;code&gt;convert&lt;/code&gt; method as usually; no extra parameters are required.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example of include processor&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Example of URI

.Gemfile
[source,ruby]
----
include::https://raw.githubusercontent.com/asciidoctor/asciidoctor/master/Gemfile[]
----&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_unregistering_extensions&quot;&gt;Unregistering extensions&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can unregister all extensions by calling the &lt;code&gt;org.asciidoctor.Asciidoctor.unregisterAllExtensions()&lt;/code&gt; method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Additionally, since AsciidoctorJ 1.5.6.1 it is possible to unregister specific extensions when using the ExtensionGroup API.
This allows to register and unregister a group of extensions as a whole:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BlockProcessor extension1 = ...
Treeprocessor extension2 = ...
ExtensionGroup extensionGroup =
  asciidoctor.createGroup()
    .block(extension1)
    .treeprocessor(extension2);

asciidoctor.convert(...) &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

extensionGroup.register();
asciidoctor.convert(); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

extensionGroup.register();
asciidoctor.convert(); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Convert a document without the extensions active because they were not registered yet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Convert with extensions active after registration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Convert without extensions active after the extensions were unregistered.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_ruby_extensions&quot;&gt;Ruby extensions&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can even register extensions written in Ruby using AsciidoctorJ.
To register a &lt;em&gt;Ruby&lt;/em&gt; extension you must get a &lt;code&gt;RubyExtensionRegistry&lt;/code&gt; class instead of &lt;code&gt;JavaExtensionRegistry&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Register a Ruby extension in Java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;RubyExtensionRegistry rubyExtensionRegistry = this.asciidoctor.rubyExtensionRegistry(); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
rubyExtensionRegistry.loadClass(Class.class.getResourceAsStream(&quot;/YellRubyBlock.rb&quot;)).block(&quot;rubyyell&quot;, &quot;YellRubyBlock&quot;); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

String content = asciidoctor.convertFile(new File(
                &quot;target/test-classes/sample-with-ruby-yell-block.ad&quot;),
                options().toFile(false).get());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rubyExtensionRegistry&lt;/code&gt; method is called to get a rubyExtensionRegistry instance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ruby file containing a class implementing a Block extension is loaded inside the Ruby runtime. Then the block is registered with a name (rubyyell), and we pass the name of the class to be instantiated.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;YellBlock.rb&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;require 'asciidoctor'
require 'asciidoctor/extensions'

class YellRubyBlock &amp;lt; Asciidoctor::Extensions::BlockProcessor
  option :contexts, [:paragraph]
  option :content_model, :simple

  def process parent, reader, attributes
    lines = reader.lines.map {|line| line.upcase.gsub(/\.( |$)/, '!\\1') }
    Asciidoctor::Block.new parent, :paragraph, :source =&amp;gt; lines, :attributes =&amp;gt; attributes
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_extension_spi&quot;&gt;Extension SPI&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In previous examples, the extensions were registered manually.
However, AsciidoctorJ provides another way to register extensions.
If any implementation of the SPI interface is present on the classpath, it will be executed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To create an autoloadable extension you should do next steps.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Create a class that implements &lt;code&gt;org.asciidoctor.extension.spi.ExtensionRegistry&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;org.asciidoctor.extension.ArrowsAndBoxesExtension.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class ArrowsAndBoxesExtension implements ExtensionRegistry { &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

  @Override
  public void register(Asciidoctor asciidoctor) { &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

    JavaExtensionRegistry javaExtensionRegistry = asciidoctor.javaExtensionRegistry();
    javaExtensionRegistry.postprocessor(ArrowsAndBoxesIncludesPostProcessor.class); &lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;
    javaExtensionRegistry.block(&quot;arrowsAndBoxes&quot;, ArrowsAndBoxesBlock.class);

  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To autoload extensions you need to implement &lt;code&gt;ExtensionRegistry&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AsciidoctorJ will automatically run the &lt;code&gt;register&lt;/code&gt; method. The method is responsible for registering all extensions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All required Java extensions are registered.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, you need to create a file called &lt;code&gt;org.asciidoctor.extension.spi.ExtensionRegistry&lt;/code&gt; inside &lt;code&gt;META-INF/services&lt;/code&gt; with the implementation&amp;#8217;s full qualified name.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;META-INF/services/org.asciidoctor.extension.spi.ExtensionRegistry&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;org.asciidoctor.extension.ArrowsAndBoxesExtension&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And that&amp;#8217;s all.
Now when a &lt;code&gt;.jar&lt;/code&gt; file containing the previous structure is dropped inside classpath of AsciidoctorJ, the &lt;code&gt;register&lt;/code&gt; method will be executed automatically and the extensions will be registered.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_converting_to_epub3&quot;&gt;Converting to EPUB3&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Asciidoctor EPUB3 gem (asciidoctor-epub3) is bundled inside the AsciidoctorJ EPUB3 jar (asciidoctorj-epub3).
To use it, simply add the asciidoctorj-epub3 jar to your dependencies.
The version of the AsciidoctorJ EPUB3 jar aligns with the version of the Asciidoctor EPUB3 gem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here&amp;#8217;s how you can add the AsciidoctorJ EPUB3 jar to your Maven dependencies:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;asciidoctorj-epub3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.0-alpha.4&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Once you&amp;#8217;ve added the AsciidoctorJ EPUB3 jar to your classpath, you can set the &lt;code&gt;backend&lt;/code&gt; attribute to &lt;code&gt;epub3&lt;/code&gt;.
The document will be converted to the &lt;a href=&quot;http://idpf.org/epub/30&quot; target=&quot;_blank&quot;&gt;EPUB3&lt;/a&gt; format.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The &lt;em class=&quot;app&quot;&gt;asciidoctor-epub3&lt;/em&gt; gem is alpha.
While it can be used successfully, there may be bugs and its functionality may change in incompatible ways before the first stable release.
In other words, by using it, you are also testing it ;)
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s see an example of how to use AsciidoctorJ with the EPUB3 converter.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;spine.adoc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Book Title
Author Name
:imagesdir: images &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

include::content-document.adoc[] &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The EPUB3 converter requires the value of the &lt;code&gt;imagesdir&lt;/code&gt; attribute to be &lt;code&gt;images&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The EPUB3 converter must be run on a &lt;em&gt;spine&lt;/em&gt; document that has at least one include directive (and no other body content) in order to function properly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;content-document.adoc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-asciidoc&quot; data-lang=&quot;asciidoc&quot;&gt;= Content Title
Author Name

[abstract]
This is the actual content.

== First Section

And off we go.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And finally we can convert the document to EPUB3 using AsciidoctorJ.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;asciidoctor.convertFile(new File(&quot;spine.adoc&quot;),
                options().safe(SafeMode.SAFE).backend(&quot;epub3&quot;).get()); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt; &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;

assertThat(new File(&quot;target/test-classes/index.epub&quot;).exists(), is(true));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Currently, the EPUB3 converter must be run in &lt;code&gt;SAFE&lt;/code&gt; or &lt;code&gt;UNSAFE&lt;/code&gt; mode due to a bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;epub3&lt;/code&gt; is the name of the backend that must be set to convert to EPUB3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_loading_ruby_libraries&quot;&gt;Loading Ruby libraries&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Simple extensions may be fully implemented in Java, but if you want to create complex extensions you can mix Ruby and Java code.
This means that you may need to execute a Ruby file or a RubyGem (i.e., gem) inside your extension.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To load a Ruby file inside the Ruby runtime, you can use &lt;code&gt;org.asciidoctor.internal.RubyUtils.loadRubyClass(Ruby, InputStream)&lt;/code&gt;.
You can also load a gem using an API that wraps Ruby&amp;#8217;s &lt;code&gt;require&lt;/code&gt; command.
The gem must be available inside the classpath.
Next run &lt;code&gt;org.asciidoctor.internal.RubyUtils.requireLibrary(Ruby, String)&lt;/code&gt;, passing the name of the gem as the second argument.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_jruby_instance&quot;&gt;JRuby instance&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sometimes you may need the Ruby runtime used inside AsciidoctorJ.
One reason is because you are using JRuby outside AsciidoctorJ and you want to reuse the same instance.
Another reason is that you need to instantiate by yourself an Asciidoctor Ruby object.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To get this instance you can use &lt;code&gt;org.asciidoctor.internal.JRubyRuntimeContext.get()&lt;/code&gt; to get it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_gem_path&quot;&gt;GEM_PATH&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By default, AsciidoctorJ comes with all required gems bundled within the jar.
In certain circumstances, you may want to load gems from an external folder.
To accomplish this scenario, &lt;code&gt;create&lt;/code&gt; method provides a parameter to set folder where gems are present.
Internally, AsciidoctorJ will set &lt;code&gt;GEM_PATH&lt;/code&gt; environment variable to given path.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Example of setting GEM_PATH&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.Asciidoctor.Factory.create;
import org.asciidoctor.Asciidoctor;

Asciidoctor asciidoctor = create(&quot;/my/gem/path&quot;); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Creates an &lt;code&gt;Asciidoctor&lt;/code&gt; instance with given &lt;code&gt;GEM_PATH&lt;/code&gt; location.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_using_asciidoctorj_in_an_osgi_environment&quot;&gt;Using AsciidoctorJ in an OSGi environment&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a non OSGi context, the following snippet will successfully create an Asciidoctor object:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.Asciidoctor.Factory.create;
import org.asciidoctor.Asciidoctor;

Asciidoctor asciidoctor = create();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In an OSGi context it will not work because JRuby needs some paths to find the gems (the Asciidoctor ones and the Ruby themselves ones). In order to make it work, you will need two more classes (RubyInstanceConfig and JavaEmbedUtils) and a small modification of the previous snippet of code. The modifications take care of the class loaders because in OSGi, which are a key point in OSGi:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import static org.asciidoctor.Asciidoctor.Factory.create;
import org.asciidoctor.Asciidoctor;

RubyInstanceConfig config = new RubyInstanceConfig();
config.setLoader(this.getClass().getClassLoader()); &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;

JavaEmbedUtils.initialize(Arrays.asList(&quot;META-INF/jruby.home/lib/ruby/2.0&quot;, &quot;gems/asciidoctor-1.5.4/lib&quot;), config); &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;&lt;b class=&quot;conum&quot;&gt;(3)&lt;/b&gt;&lt;b class=&quot;conum&quot;&gt;(4)&lt;/b&gt;

Asciidoctor asciidoctor = create(this.getClass().getClassLoader()); &lt;b class=&quot;conum&quot;&gt;(5)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The RubyInstanceConfig will use the class loader of the OSGi bundle ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The JavaEmbedUtils will specify the load paths of the required gems. If they are not specified, you will get JRuby exceptions ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;META-INF/jruby.home/lib/ruby/2.0&lt;/code&gt; specifies where the Ruby gems are located. Actually this path is located inside the &lt;code&gt;jruby-complete-&amp;lt;version&amp;gt;.jar&lt;/code&gt; file. Without having this path specified you may get an &lt;code&gt;org.jruby.exceptions.RaiseException: (LoadError) no such file to load&amp;#8201;&amp;#8212;&amp;#8201;set&lt;/code&gt; error ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gems/asciidoctor-&amp;lt;version&amp;gt;/lib&lt;/code&gt; specifies where the gems for Asciidoctor are located. Actually this path is located inside the &lt;code&gt;asciidoctorj-&amp;lt;version&amp;gt;.jar&lt;/code&gt; file ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The factory for the Asciidoctor object also specify the class loader to use.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
We consider this code to be placed inside an OSGi bundle
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This solution has pros and cons:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Pros:&lt;/em&gt; you don&amp;#8217;t need to extract the gems located in the asciidoctorj binary ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Cons:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the version of asciidoctor is hard coded ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the version of ruby is hard coded.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_optimization&quot;&gt;Optimization&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JRuby may start slower than expected versus the C-based Ruby implementation (MRI).
Fortunately, JRuby offers flags that can improve the start time and tune applications.
Several Java flags can also be used in conjunction with or apart from the JRuby flags in order to improve the start time even more.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For small tasks such as converting an AsciiDoc document, two JRuby flags can drastically improve the start time:&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all&quot; style=&quot;width: 50%;&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 6. JRuby flags&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%;&quot;&gt;
&lt;col style=&quot;width: 66%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;jruby.compat.version&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;RUBY1_9&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;jruby.compile.mode&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;OFF&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Both flags are set by default inside AsciidoctorJ.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Java flags available for improving start time depend on whether your working on a 32- or 64-bit processor and your JDK version.
These flags are set by using the &lt;code&gt;JRUBY_OPTS&lt;/code&gt; environment variable.
Let&amp;#8217;s see a summary of these flags and in which environments they can be used.&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all&quot; style=&quot;width: 75%;&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 7. Java flags&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%;&quot;&gt;
&lt;col style=&quot;width: 66%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Name&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;JDK&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;-client&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;32 bit Java&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;-Xverify:none&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;32/64 bit Java&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;-XX:+TieredCompilation&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;32/64 bit Java SE 7&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;-XX:TieredStopAtLevel=1&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;32/64 bit Java SE 7&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Setting flags for Java SE 6&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;export JRUBY_OPTS=&quot;-J-Xverify:none -J-client&quot; &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Note that you should add &lt;code&gt;-J&lt;/code&gt; before the flag.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can find a full explanation on how to improve the start time of JRuby applications in &lt;a href=&quot;#_optimization&quot;&gt;Optimization&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;wildfly-kludge&quot;&gt;Running AsciidoctorJ on WildFly AS&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to use AsciidoctorJ in an application deployed on &lt;em class=&quot;app&quot;&gt;WildFly AS&lt;/em&gt;, you have to install AsciidoctorJ as a JBoss Module.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Follow the steps below:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Create an &lt;strong&gt;Asciidoctor module&lt;/strong&gt; for &lt;em class=&quot;app&quot;&gt;WildFly AS&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create the following folder tree: &lt;em class=&quot;path&quot;&gt;$JBOSS_HOME/modules/org/asciidoctor/main&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create the module descriptor file &lt;em class=&quot;path&quot;&gt;module.xml&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Asciidoctor module descriptor for WildFly AS&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;module xmlns=&quot;urn:jboss:module:1.0&quot; name=&quot;org.asciidoctor&quot;&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource-root path=&quot;asciidoctorj-1.5.4.jar&quot;/&amp;gt;
        &amp;lt;resource-root path=&quot;jcommander-1.35.jar&quot;/&amp;gt;
        &amp;lt;resource-root path=&quot;jruby-complete-1.7.21.jar&quot;/&amp;gt;
    &amp;lt;/resources&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;module name=&quot;sun.jdk&quot; export=&quot;true&quot;&amp;gt;
            &amp;lt;imports&amp;gt;
                &amp;lt;include path=&quot;sun/misc/Unsafe&quot; /&amp;gt;
            &amp;lt;/imports&amp;gt;
        &amp;lt;/module&amp;gt;
        &amp;lt;module name=&quot;javax.management.j2ee.api&quot;/&amp;gt;
        &amp;lt;module name=&quot;javax.api&quot;/&amp;gt;
        &amp;lt;module name=&quot;org.slf4j&quot;/&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/module&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy the jar files into the same folder as the &lt;em&gt;module.xml&lt;/em&gt; file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make sure the version numbers of the jar files agree with what&amp;#8217;s in the current set.
Restart WildFly for the new module to take effect.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a dependency on your Java archive to this WildFly module using one of the following options:&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;Add the dependency just into the &lt;em class=&quot;path&quot;&gt;MANIFEST.MF&lt;/em&gt; file.&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;MANIFEST.MF file example with dependency to Asciidoctor module&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Manifest-Version: 1.0
Dependencies: org.asciidoctor
...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Or&lt;/em&gt;, configure the dependency into the &lt;em class=&quot;path&quot;&gt;pom.xml&lt;/em&gt; with the &lt;em class=&quot;app&quot;&gt;Maven JAR/WAR plugin&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;pom.xml file example with Maven WAR plugin configuration to add a dependency&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;...
&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;asciidoctorj&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.4&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &lt;b class=&quot;conum&quot;&gt;(1)&lt;/b&gt;
    ...
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
...
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
      &amp;lt;archive&amp;gt;
        &amp;lt;manifestEntries&amp;gt;
          &amp;lt;Dependencies&amp;gt;org.asciidoctor&amp;lt;/Dependencies&amp;gt; &lt;b class=&quot;conum&quot;&gt;(2)&lt;/b&gt;
        &amp;lt;/manifestEntries&amp;gt;
      &amp;lt;/archive&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The AsciidoctorJ dependency and the transitives dependencies don&amp;#8217;t need to be added to the final WAR since all JARs are available through the module.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The module dependency will be added to the &lt;em class=&quot;path&quot;&gt;MANIFEST.MF&lt;/em&gt; file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_using_a_pre_release_version&quot;&gt;Using a pre-release version&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Pre-release versions of &lt;code&gt;AsciidoctorJ&lt;/code&gt; are published to Bintray.
You can find them in &lt;a href=&quot;https://bintray.com/asciidoctor/maven/asciidoctorj/view&quot; class=&quot;bare&quot;&gt;https://bintray.com/asciidoctor/maven/asciidoctorj/view&lt;/a&gt;.
Final releases are released to both Maven Central and Bintray.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here&amp;#8217;s how to use a pre-release version in Maven:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;repositories&amp;gt;
  &amp;lt;repository&amp;gt;
    &amp;lt;id&amp;gt;central&amp;lt;/id&amp;gt;
    &amp;lt;name&amp;gt;bintray&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://dl.bintray.com/asciidoctor/maven&amp;lt;/url&amp;gt;
    &amp;lt;snapshots&amp;gt;
      &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
    &amp;lt;/snapshots&amp;gt;
  &amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_development&quot;&gt;Development&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;AsciidoctorJ is built using &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;.
The project is structured as a multi-module build.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_project_layout&quot;&gt;Project layout&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The root folder is the root project and there are several subproject folders, each prefixed with &lt;em&gt;asciidoctorj-&lt;/em&gt;.
Each subproject produces a primary artifact (e.g., jar or zip) and its supporting artifacts (e.g., javadoc, sources, etc).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The subprojects are as follows:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;asciidoctorj&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;The main Java bindings for the Asciidoctor RubyGem (asciidoctor).
Also bundles optional RubyGems needed at runtime, such as coderay, tilt, haml and slim.
Produces the asciidoctorj jar.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;asciidoctorj-distribution&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Produces the distribution zip that provides the standalone &lt;code&gt;asciidoctorj&lt;/code&gt; command.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;asciidoctorj-epub3&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Bundles the Asciidoctor EPUB3 RubyGem (asciidoctor-pdf) and its dependencies as the asciidoctorj-epub3 jar.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;asciidoctorj-pdf&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Bundles the Asciidoctor PDF RubyGem (asciidoctor-pdf) and its dependencies as the asciidoctorj-pdf jar.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Gradle build is partitioned into the following files:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;build.gradle
gradle.properties
settings.gradle
gradle/
  wrapper/
    ...
  deploy.gradle
  eclipse.gradle
  idea.gradle
  publish.gradle
  sign.gradle
asciidoctorj-core/
  build.gradle
asciidoctorj-distribution/
  build.gradle
asciidoctorj-epub3/
  build.gradle
asciidoctorj-pdf/
  build.gradle&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_build_the_project&quot;&gt;Build the project&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You invoke Gradle on this project using the &lt;code&gt;gradlew&lt;/code&gt; command (i.e., the Gradle Wrapper).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Tip&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
We strongly recommend that you use Gradle via the &lt;a href=&quot;https://www.timroes.de/2013/09/12/speed-up-gradle&quot;&gt;Gradle daemon&lt;/a&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To clone the project, compile the source and build the artifacts (i.e., jars) locally, run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ git clone https://github.com/asciidoctor/asciidoctorj
  cd asciidoctorj
  ./gradlew assemble&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can find the built artifacts in the &lt;em class=&quot;path&quot;&gt;asciidoctorj-*/build/libs&lt;/em&gt; folders.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To execute tests when running the build, use:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew build&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To only execute the tests, run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew check&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can also run tests for a single module:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ cd asciidoctorj-core
  ../gradlew check&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To run a single test in the asciidoctorj-core subproject, use:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ../gradlew -Dsingle.test=NameOfTestClass test&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To create the distribution, run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew distZip&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can find the distribution in the &lt;em class=&quot;path&quot;&gt;asciidoctorj-distribution/build/distributions&lt;/em&gt; folder.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_develop_in_an_ide&quot;&gt;Develop in an IDE&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_intellij_idea&quot;&gt;IntelliJ IDEA&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To import the project into IntelliJ IDEA 14, simply import the project using the import wizard.
For more information, see the &lt;a href=&quot;https://www.jetbrains.com/idea/help/gradle.html&quot;&gt;Gradle page&lt;/a&gt; in the IntelliJ IDEA Web Help.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_eclipse&quot;&gt;Eclipse&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To open the project in Eclipse, first generate the Eclipse project files:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ cd asciidoctorj-core
  ./gradlew eclipse&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then, import the project into Eclipse using &lt;span class=&quot;menuseq&quot;&gt;&lt;span class=&quot;menu&quot;&gt;File&lt;/span&gt;&amp;#160;&amp;#9656; &lt;span class=&quot;submenu&quot;&gt;Import&lt;/span&gt;&amp;#160;&amp;#9656; &lt;span class=&quot;submenu&quot;&gt;General&lt;/span&gt;&amp;#160;&amp;#9656; &lt;span class=&quot;menuitem&quot;&gt;Existing Project into Workspace&lt;/span&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_continuous_integration&quot;&gt;Continuous integration&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Continuous integration for the AsciidoctorJ project is performed by Travis CI.
You can find recent build results, including the build status of pull requests, on the &lt;a href=&quot;https://travis-ci.org/asciidoctor/asciidoctorj&quot;&gt;asciidoctor/asciidoctorj&lt;/a&gt; page.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_publish_the_artifacts&quot;&gt;Publish the artifacts&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Artifacts are published to Maven Central and jCenter by way of Bintray&amp;#8217;s &lt;em&gt;Distribution as a Service&lt;/em&gt; platform.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Before publishing, you need to configure your gpg signing and Bintray credentials.
Create the file &lt;em class=&quot;path&quot;&gt;$HOME/.gradle/gradle.properties&lt;/em&gt; and populate the following properties.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;signing.keyId=
signing.password=
signing.secretKeyRingFile=/home/YOUR_USERNAME/.gnupg/secring.gpg
bintrayUsername=
bintrayApiKey=&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To build, assemble and sign the archives (jars and distribution zip), run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew -PpublishRelease=true signJars&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Tip&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The &lt;code&gt;publishRelease=true&lt;/code&gt; property is technically only required if the version is a snapshot.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To build, assemble (but not sign) and install the archives (jars and distribution zip) into the local Maven repository, run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew -PpublishRelease=true install&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To build, assemble, sign and publish the archives (jars and distribution zip) to Bintray, run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew clean
  ./gradlew -i -x pMNPTML bintrayUpload&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Don&amp;#8217;t run the &lt;code&gt;clean&lt;/code&gt; task in the same execution as the &lt;code&gt;bintrayUpload&lt;/code&gt; because it will not upload one of the signatures.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to first perform a dry run of the upload, add the &lt;code&gt;dryRun=true&lt;/code&gt; property.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ ./gradlew -i -PdryRun=true -x pMNPTML bintrayUpload&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
The &lt;code&gt;-x pMNPTML&lt;/code&gt; is necessary to work around a bug in the publishing plugin that prevents it from signing the archives.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock important&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Important&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Bintray does not allow you to publish snapshots.
You have to first update the version in &lt;em class=&quot;path&quot;&gt;gradle.properties&lt;/em&gt; to a release (or pre-release) version number.
Currently, Gradle is not configured to automatically tag a release, so &lt;strong&gt;you have to create the git tag manually&lt;/strong&gt;.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_resources&quot;&gt;Resources&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The source code for AsciidoctorJ, including the latest developments and issues, can be found in the project&amp;#8217;s &lt;a href=&quot;https://github.com/asciidoctor/asciidoctorj&quot;&gt;repository&lt;/a&gt; on GitHub.
If you identify an issue while using AsciidoctorJ, please don&amp;#8217;t hesitate to &lt;a href=&quot;https://github.com/asciidoctor/asciidoctorj/issues&quot;&gt;file a bug report&lt;/a&gt;.
Also, don&amp;#8217;t forget to join the &lt;a href=&quot;http://discuss.asciidoctor.org&quot;&gt;Asciidoctor discussion list&lt;/a&gt;, where you can ask questions and leave comments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Thu, 21 Sep 2017 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</guid>
<link>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</link>
<title>
클로저스트립트에서 매크로 작성시 주의점
</title>
<description>
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_컴파일러는_크로스_컴파일러다&quot;&gt;클로저스크립트 컴파일러는 크로스 컴파일러다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트(ClojureScript) 컴파일러는 클로저스크립트 코드를 컴파일하여 브라우저나 Node.js에서 실행할 자바스크립트 코드를 만듭니다. 하지만 클로저스크립트 컴파일러 자체는 JVM상에서 실행되는 자바 프로그램이며, cljs.jar 파일로 배포됩니다. 즉 클로저스크립트 컴파일러는 컴파일러가 실행되는 환경은 JVM인데, 컴파일러의 실행 결과인 목적 코드가 실행되는 환경은 JS VM(브라우져나 Node.js처럼 자바스크립트를 실행시키는 VM)인 것입니다. 이처럼 컴파일러가 실행되는 환경과 그 컴파일러의 목적 코드가 실행되는 환경이 다른 컴파일러를 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC&quot;&gt;크로스 컴파일러&lt;/a&gt;(Cross Compiler)라고 합니다. 클로저스크립트 컴파일러는 크로스 컴파일러인 셈이죠. 이 때문에 발생하는 문제들이 있는데, 이 글에서는 특히 매크로와 관련된 문제들을 살펴보겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_매크로는_클로저_코드이다&quot;&gt;클로저스크립트 매크로는 클로저 코드이다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;아시다시피 모든 리습 언어의 매크로가 그렇듯이 클로저스크립트의 매크로도 컴파일시에 확장이 됩니다. 매크로는 컴파일러시에 수행되는 일종의 함수입니다. 즉 매크로는 코드를 입력받아 코드를 리턴하는, 사용자가 작성하고, 사용자가 사용하지만, 그 호출은 컴파일러에 의해 수행되는 함수입니다. 컴파일러는 매크로 호출을 만나면 입력받은 코드를 인수로 해서, 정의된 매크로(함수)를 수행하고, 그 수행 결과로 나온 코드를 원래의 매크로 호출 코드와 교체합니다. 이처럼 매크로 호출 코드를 매크로 출력 코드로 바꾸는 것을 매크로 확장이라고 합니다. 그런데 이 매크로 확장이 컴파일시에 되어야 하기 때문에 클로저스크립트의 매크로 확장은 목적 코드의 실행 환경인 JS VM이 아닌 컴파일러의 실행 환경인 JVM상에서 이루어집니다. 그래서 클로저스크립트의 매크로는 JVM상에서 실행될 수 있는 클로저 코드로 작성되어야 합니다. 이러한 이유로 클로저스크립트 매크로는 클로저스크립트 파일(.cljs)이 아닌 클로저 파일(.clj)로 작성됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;크로스 컴파일러라는 클로저스크립트 컴파일러의 이러한 특성으로 인해 일반 코드와 매크로 코드가 분리되어서 작성되어야 한다는 것은 사실 조금 번거롭기는 하지만 그리 큰 문제는 아닙니다. 어짜피 매크로 코드는 다른게 아니라 우리가 많이 익숙한 클로저 코드니까요. 문제는 매크로 도우미(Helper) 함수들입니다. 특히 .cljc 파일이 도입되면서는 숙련된 클로저 프로그래머조차 가끔 실수를 하기도 합니다. 사실 이러한 점은 원리를 알면 당연한 것이 되어서 쉽게 피할 수 있는 문제이기 때문에 이 글에서 차근차근 알아보도록 하겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
이 글에서는 컴파일러의 특성을 알아보는 것이 목적이므로 Leiningen보다는  clojure.jar와 cljs.jar를 통해서 Clojure/ClojureScript 컴파일러를 직접 사용합니다.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저의_매크로_작성_방식&quot;&gt;클로저의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 클로저(Clojure)에서는 다음과 같이 매크로를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defmacro log [x]
  `(println &quot;[log: ]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer [log]]))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro.clj에서 &lt;code&gt;log&lt;/code&gt; 매크로를 정의합니다. 간단하게 로그를 프린트하는 형식(form)을 리턴합니다. 그리고 core.clj에서 macro.clj를 로드(require)하고 &lt;code&gt;log&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;hello world&lt;/code&gt; 를 프린트합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코드를 실행하기 위해 다음과 같이 macro.clj와 core.clj를 만들고, 위의 소스와 같은 내용으로 각각 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mkdir test; cd test
$ touch macro.clj core.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 clojure.jar를 다운로드합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl -o clojure.jar http://central.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 직접 소스를 컴파일하고 실행해 봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log: ] hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;java를 실행하면서 클래스패스로 clojure.jar와 현재 디렉토리를 주었습니다. clojure.main 함수를 실행하면서 core.clj 을 인자로 넘겼습니다. core.clj 파일일 컴파일되고 실행되어 명령창에 로그가 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서 눈여겨 볼 것은 사실 당연한 것이지만 clojure.jar의 컴파일러도 JVM에서 실행되었고, 컴파일된 core.clj도 같은 JVM 상에서 실행되고 있다는 사실입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_매크로_도우미_함수&quot;&gt;매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 매크로를 작성하다 보면 매크로에서 자체적으로 사용하는 도우미(Helper) 함수들을 만들어 사용하게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 작성한 &lt;code&gt;log&lt;/code&gt; 매크로에 로그의 시각을 프린트하는 기능을 넣기 위해 &lt;code&gt;now&lt;/code&gt; 도우미 함수를 추가합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;macro.clj&lt;/code&gt; 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now [] ; &amp;lt;== 도우미 함수
  (System/currentTimeMillis))

(defmacro log [x]
  `(println &quot;[log&quot; (now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 했던 것과 같이 컴파일하고 실행해보고 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log 1504281655322 ]:  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;로그에 시각이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;now&lt;/code&gt; 함수는 정확하게 &lt;code&gt;log&lt;/code&gt; 매크로가 실행되는 런타임에 실행되어 해당 시각을 나타내주고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트의_매크로_작성_방식&quot;&gt;클로저스크립트의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트에서 매크로 작성하는 방식도 클로저와 비슷합니다. 일단 매크로는 .cljs가 아닌 .clj파일에서 정의되어야 한다는 점에서.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그렇다면 위에서 작성한 매크로는 .clj로 작성했으니 당연히 ClojureScript에서도 사용할 수 있겠죠?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 &lt;code&gt;core.cljs&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript에서는 매크로 파일(.clj)을 로딩하기 위해서는 `require-macros`를 사용합니다. `enable-console-print`는 `println`함수가 JS-VM상의 console에 프린트할 수 있도록 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljs 파일을 만들고, 위와 소스와 같은 내용으로 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ touch core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트_코드_컴파일하기&quot;&gt;클로저스크립트 코드 컴파일하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript 파일을 컴파일하기 위해서는 컴파일러의 build-api를 사용해야 합니다. 다음은 build-api를 사용하는 build.clj 파일입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(require 'cljs.build.api')

(cljs.build.api/build &quot;.&quot;
  {:main 'core'
   :output-to &quot;out/main.js&quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;cljs.build.api&lt;/code&gt; 를 로딩하고, &lt;code&gt;build&lt;/code&gt; 함수를 사용합니다. &lt;code&gt;build&lt;/code&gt; 함수는 2개의 인자를 받습니다. 첫 인자는 컴파일할 소스 디렉토리이고, 두번째 인자는 컴파일러 옵션입니다. 옵션은 출력 파일을 가리키는 &lt;code&gt;:output-to&lt;/code&gt; 와 주 이름공간을 가리키는 &lt;code&gt;:main&lt;/code&gt; 만 주어졌습니다. &lt;code&gt;:output-to&lt;/code&gt; 는 컴파일한 결과인 JS 코드를 out/main.js 출력 파일에 쓰라는 설정입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 다운로드받습니다. 이 파일은 클로저스크립트를 컴파일하기 위한 build-api를 담고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ curl -LOk https://github.com/clojure/clojurescript/releases/download/r1.9.908/cljs.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 이용하여 build.clj를 실행시켜 core.cljs를 컴파일합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
WARNING: Use of undeclared Var macro/now at line 6 ./core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저 컴파일러를 실행하던 것과 다른 것은 클패스패스에 clojure.jar 대신 cljs.jar를 주고, 컴파일을 구동하기 위해 build.clj 파일을 주었다는 것입니다. 그리고 컴파일만 한다는 것입니다. 실행할 플랫폼은 JVM이 아니라 JS-VM입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트의_매크로_도우미_함수&quot;&gt;클로저스크립트의 매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 경고가 나옵니다. &lt;code&gt;macro/now&lt;/code&gt; 가 선언되어 있지 않다는 경고입니다. 당연합니다. &lt;code&gt;now&lt;/code&gt; 는 .clj 파일에 정의된 매크로 도우미 함수라서, 컴파일러는 매크로 확장시에는 &lt;code&gt;now&lt;/code&gt; 함수를 볼 수 있지만, 매크로 확장의 결과를 사용할 때에는 &lt;code&gt;now&lt;/code&gt; 함수를 볼 수가 없습니다. .clj에서 정의된 함수인 &lt;code&gt;now&lt;/code&gt; 는 JVM상에서 실행되는 것입니다. JS-VM상에서 구동하는 .cljs의 코드들의 런타임시에는 &lt;code&gt;now&lt;/code&gt; 와 같은 .clj의 함수들을 당연히 사용할 수 없습니다. 단지 .clj 파일의 매크로만 사용할 수 있는데, 왜냐하면 매크로의 확장은 컴파일시에 되는데, .cljs 파일이 컴파일되는 JVM 상에서 .clj에서 정의된 함수들(매크로 포함)을 구동시킬 수 있기 때문입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;원래 매크로는 컴파일시에 컴퍼일러에 의해 호출되는, 형식(form)을 입력받아 확장된 형식(form)을 출력하는 특수 함수이죠. 뭐&amp;#8230;&amp;#8203;사용자에게 코드 형성의 자유를 주기 위해 컴파일러에 의해 호출되는 콜백 함수라고 할까요?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;결국 도우미 함수 &lt;code&gt;now&lt;/code&gt; 는 JVM상에서 실행되어야 합니다. 즉 도우미 함수는 매크로 확장시에 호출되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 macro.clj 파일을 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (System/currentTimeMillis))

(defmacro log [x]
  (let [t# (now)] ; &amp;lt;== now는 매크로 확장시에 호출된다.
  `(println &quot;[log&quot; ~t# &quot;]&quot; ~x)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 소스에서는 &lt;code&gt;now&lt;/code&gt; 함수가 매크로 안에서 직접 호출되고, 그 결과값을 매크로의 결과에 포함합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다시 컴파일하면 정상적으로 성공합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ ls -al
total 57184
drwxr-xr-x  10 guruma  staff       340  9  2 02:25 .
drwxr-xr-x   6 guruma  staff       204  9  2 00:37 ..
-rw-r--r--   1 guruma  staff        99  9  2 01:43 build.clj
-rw-r--r--@  1 guruma  staff  25629199  9  2 01:24 cljs.jar
-rw-r--r--   1 guruma  staff   3622815  9  2 00:36 clojure.jar
-rw-r--r--   1 guruma  staff        86  9  2 00:46 core.clj
-rw-r--r--   1 guruma  staff        98  9  2 01:37 core.cljs
-rw-r--r--   1 guruma  staff       137  9  2 02:25 macro.clj
drwxr-xr-x  11 guruma  staff       374  9  2 02:25 out&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;out 폴더가 생성되는 것을 확인할 수 있습니다. out 폴더에 main.js 파일이 있으며 다음과 같이 내용입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스립트립트_코드_실행하기&quot;&gt;클로저스립트립트 코드 실행하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;main.js를 브라우저에서 실행해 보기 위해 index.html 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
         &amp;lt;script type=&quot;text/javascript&quot; src=&quot;out/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 index.html 파일을 브라우저로 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창을 열어 확인해 보면 로그가 다음과 같이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;[log 1504286749399 ]:  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_공통_도우미_함수&quot;&gt;공통 도우미 함수&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 여기에 문제가 있습니다. &lt;code&gt;now&lt;/code&gt; 함수는 log 매크로가 컴파일시에 매크로 확장할 때 실행된다는 점입니다. 원래 의도는 log 매크로를 사용하는 코드가 런타임시에 실행될 때 &lt;code&gt;now&lt;/code&gt; 함수가 실행되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이를 위해서는 &lt;code&gt;now&lt;/code&gt; 함수는 .clj가 아닌 .cljs 파일에서 정의되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 코드가 수정되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;util.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns util)

(defn now []
  (js/Date.now))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (str &quot;js:&quot; (System/currentTimeMillis)))

(defmacro log [x]
  `(println &quot;[log&quot; (util/now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [util :refer [now]])
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;새로운 파일 util.cljs를 만들어 &lt;code&gt;now&lt;/code&gt; 함수를 클로저스크립트용으로 만들었습니다. 즉 자바스크립트의 &lt;code&gt;Date&lt;/code&gt; 오브젝트를 이용했습니다. 또한 macro.clj의 &lt;code&gt;now&lt;/code&gt; 함수와 구분할 수 있도록 &quot;js:&quot; 문자열을 앞에 덧붙였습니다. &lt;code&gt;log&lt;/code&gt; 매크로에서는 &lt;code&gt;(util/now)&lt;/code&gt; 형식(form)으로 수정했습니다. &lt;code&gt;util&lt;/code&gt; 이라는 이름공간을 지정해서 주어서 매크로 확장후 정확히 &lt;code&gt;util&lt;/code&gt; 이름공간의 &lt;code&gt;now&lt;/code&gt; 를 호출할 수 있도록 변경하였습니다. core.cljs에서는 &lt;code&gt;require&lt;/code&gt; 를 이용해서 util.cljs를 로딩합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 실행해봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창에서 로그가 프린트되는 것을 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;[log js:1504286749399 ]:  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;확실히 이제 &lt;code&gt;now&lt;/code&gt; 함수가 브라우저상에서 호출되어 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_조건부_컴파일&quot;&gt;조건부 컴파일&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;일단 &lt;code&gt;now&lt;/code&gt; 함수의 실행 시간 문제는 해결되었지만, 다른 문제가 있습니다. 같은 이름과 기능을 하는 2개가 함수가 하나는 macro.clj에 다른 하나는 util.cljs 파일에 각각 따로 정의되어 있다는 문제입니다. 이렇게 되면 관리가 어려워지게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 매크로를 작성하다보면 대부분은 공통으로 사용될 수 있지만 일부만 플랫폼에 따라 달라져야 하는 코드들이 분명 있습니다. 극히 일부만 플랫폼 의존 코드만 다르고 대부분의 코드들은 같은 매크로나 매크로 도우미 함수를 각각 서로 다른 파일에 관리해야 한다는 문제는 클로저스크립트 매크로 작성시에 큰 문제였습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;만약 이러한 코드들을 한 파일에서 정의하고 단지 일부 플랫폼 의존 코드만 따로 지정해서 조건부로 플랫폼에 따라 해당 플랫폼 코드만 컴파일할 수 있다면 정말 좋을 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 목적을 위해 처음에는 .cljx를 사용했습니다. 이것은 라이닝언(Leiningen)이라는 빌드툴에서 사용되는 것이었는데, 플랫폼 의존 코드를 지정하면 라이닝언의 cljx 플러그인이 해당 플랫폼 코드만의 파일들로, 즉 .clj와 .cljs 파일로 나누어서 자동으로 생성해 주었습니다. 그 후 클로저스크립트 컴파일러로 이후 컴파일 과정이 이어나가는 방식이었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 이것은 cljx라는 특정 도구를 사용해야 한다는 점에서 모두가 만족할 만한 해결책은 아니었습니다. 왜냐면 라이닝언 등의 해당 툴을 사용하지 못하는 경우도 있기 때문이었습니다. 결국 조건부 컴파일은 컴파일러 자체 내에 포함되어야 했고, 실제로 Clojure 1.7과 ClojureScript 0.0-3196부터 .cljc 파일에 대해 &lt;a href=&quot;https://clojure.org/guides/reader_conditionals&quot;&gt;Reader Conditionals&lt;/a&gt;이라는 기능으로 추가되었습니다. 자세한 내용은 링크를 참고하시기 바랍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;__cljc와_reader_conditionals&quot;&gt;.cljc와 Reader Conditionals&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 조건부 컴파일이 가능한 매크로를 .cljc 파일에 아래와 같이 다시 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  #?(:clj (System.currentTimeMillis)
     :cljs (js/Date.now)))

(defmacro log [x]
  `(println &quot;log[&quot; (now) &quot;]: &quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 이 Reader Conditionals이라는 리더 매크로입니다. 컴파일러가 .clj, .cljs, .cljc 파일을 읽어들이면 제일 먼저 여러가지 리더 매크로의 처리를 하는데, .cljc인 경우에는 추가적으로 Reader Conditionals 처리가 더해집니다. 리더 매크로의 이러한 처리들로 만들어진 form들을 컴파일러가 그 이후 단계로 처리하게 되는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 리더 매크로 안에서 :clj로 지정된 형식(form)은 클로저 컴파일러가, :cljs로 지정된 형식(form)은 클로저스크립트 컴파일러가 사용할 수 있도록 처리됩니다.(이외에 :clr와 :default등도 있습니다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 core.cljs에서 util.cljs을 로딩할 필요가 없습니다. core.cljs파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하기 전에 기존 macro.clj를 macro.clj.bak을 바꿔줍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mv macro.clj macro.clj.bak&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 브라우저 콘솔창에서 확인합니다&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같은 에러가 발생합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Uncaught ReferenceError: macro is not defined&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 에러는 왜 발생하는 걸까요? 그것은 컴파일러가 매크로를 처리하는 방식때문입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;아시다시피 클로저는 코드들을 이름공간(NameSpace)라는 모듈 형태로 관리합니다. 모든 심볼들은 이름공간에 속해 있습니다. 이름공간은 런타임뿐 만 아니라 컴파일시에도 중요한 역할을 하는데 컴파일러는 매크로 이름공간과 일반 이름공간을 구분해서 관리합니다. 심볼들도 그에 따라 다르게 관리됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 점을 염두에 두면서 클로저스크립트 컴파일러의 경우에 대해 생각해 봅시다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;core.cljs를 클로저스크립트가 컴파일할 때 처음 만나는 형식(form)이 ns 형식입니다. 여기서 require-macros를 만나서 macro.cljc를 로드합니다. 여기서 짚어야 할 것이 있는데, 컴파일러가 컴파일시에 로딩한다는 것입니다. 런타임에 로딩하는 코드로 번역되어서 런타임에 로딩하는 것이 아닙니다. 컴파일러가 컴파일을 위해 사용하려고 macro.cljc를 로딩하는 것입니다. 그런데 클로저스크립트 컴파일러는 JVM상에서 실행되고 있으므로 macro.cljc는 Reader Conditionals에 의해서 :clj 코드만 처리됩니다. 그리고 macro 이름공간은 매크로 이름공간으로 처리되면, &lt;code&gt;now&lt;/code&gt; 함수는 매크로 이름공간의 심볼이 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그 다음으로 클로저스크립트 컴파일러가 &lt;code&gt;log&lt;/code&gt; 매크로 형식을 만나는 경우를 보겠습니다. 컴파일러는 매크로를 만났으므로 매크로 확장을 하게 됩니다. 매크로를 확장하면서 now 심볼을 심볼 테이블에서 찾는데, 매크로 확장시이므로 매크로 이름공간에서 찾습니다. 거기에는 당연히 macro/now라는 심볼이 있으니, macro/now 심볼이 가리키는 Var, 즉 now 함수로 resolve합니다. 여기까지가 매크로 확장의 결과입니다. 매크로 확장을 끝난 후에 컴파일러는 그 결과 형식(form)을 다시 처리하려고 합니다. 그런데 macro/now는 찾을 수가 없습니다. 지금은 매크로 확장이 아니기 때문에 심볼을 일반 이름공간에서 찾아야 하는데, 일반 이름공간으로 macro.cljc를 로딩한 적이 없기 때문에, 컴파일러는 now를 찾을 수가 없는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 이유때문에 컴파일러가 macro/now라는 심볼은 선언되지 않았다는 경고(Use of undeclared Var macro/now)를 내는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;결국 이 문제를 해결하려면 macro.cljc를 일반 이름공간으로 로딩해 주어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer [log]])
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;require-macros가 클로저스크립트시에 매크로 파일을 로딩하는데&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 이 도우미 함수는 .clj에서 정의된 것이기 때문에 .cljs에서 사용할 수는 없습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;require-macros&lt;/code&gt; 는 컴파일할 때 실행됩니다. 컴파일러가 JVM상에서 실행되면서 &lt;code&gt;require-macros&lt;/code&gt; 함수를 실행하고, 이때 foo/macro.clj 파일을 로딩해서 파싱하면서, &lt;code&gt;foo.macro&lt;/code&gt; 이름공간(NameSpace)가 생성되고, 이 이름공간에 매크로 &lt;code&gt;log&lt;/code&gt; 와 도우미 함수 &lt;code&gt;now&lt;/code&gt; 가 등록됩니다. 컴파일러는 foo/core.cljs 에서 매크로 log 심볼을 만나게 되면, 매크로 확장을 하기위해, &lt;code&gt;foo.macro&lt;/code&gt; 이름공간에서 &lt;code&gt;log&lt;/code&gt; 매크로를 찾아서 확장을 하게 됩니다. 매크로 확장을 하면서 &lt;code&gt;now&lt;/code&gt; 함수도 &lt;code&gt;foo.macro&lt;/code&gt; 이름공간에서 찾아 실행하게 됩니다. 그러고나서  컴파일러는 &lt;code&gt;log&lt;/code&gt; 매크로가 리턴한 &lt;code&gt;(println &quot;log[&quot; (now) &quot;]: &quot; ~x)&lt;/code&gt; 를 본래 &lt;code&gt;log&lt;/code&gt; 매크로가 호출되던 자리에 넣게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 컴파일러가 도우미 함수의 심볼인 &lt;code&gt;now&lt;/code&gt; 를 만나게 되면, 매크로가 아니기 때문에, 보통의 일반적인 이름공간에서 심볼을 찾게 됩니다. 컴파일러는 일반 이름공간과 매크로 이름공간을 구분합니다. 컴파일러가 이미 &lt;code&gt;foo.core&lt;/code&gt; 와 &lt;code&gt;foo.macro&lt;/code&gt; 이름공간을 둘 다 로딩한 상태이긴 하지만, &lt;code&gt;now&lt;/code&gt; 는 매크로 이름공간에 있기 때문에, 컴파일러는 매크로가 아닌 &lt;code&gt;now&lt;/code&gt; 는 일반 이름공간인 &lt;code&gt;foo.core&lt;/code&gt; 에서만 찾습니다. 하지만 &lt;code&gt;foo.core&lt;/code&gt; 에는 &lt;code&gt;now&lt;/code&gt; 가 선언된 바가 없기 때문에 경고가 발생합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns foo.macro)

(defn now []
  #?(:clj (System.currentTimeMillis())
     :cljs (js/Date.now)))

(defmacro log [x]
  `(println &quot;log[&quot; (now) &quot;]: &quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; foo/core.clj[]s

(ns foo.core
  (:require-macros [foo.macro :as [log]]))

(log x)

(now) ;; =&amp;gt; WARNING: Use of undeclared var&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Wed, 20 Sep 2017 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
