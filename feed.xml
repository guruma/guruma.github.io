<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://guruma.github.io/' rel='self' type='application/rss+xml'/>
<title>
Computat ergo est
</title>
<link>
http://guruma.github.io/
</link>
<description>
guruma's Blog
</description>
<lastBuildDate>
Mon, 01 Oct 2018 01:05:42 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://guruma.github.io/posts/2018-09-27-Project-Loom-Fiber-And-Continuation/
</guid>
<link>
http://guruma.github.io/posts/2018-09-27-Project-Loom-Fiber-And-Continuation/
</link>
<title>
Project Loom: Fiber와 Continuation
</title>
<description>
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_자바에_fiber와_continuation이_추가된다&quot;&gt;자바에 Fiber와 Continuation이 추가된다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;최근에 관심이 가는 &lt;a href=&quot;http://openjdk.java.net/&quot;&gt;OpenJDK&lt;/a&gt; 프로젝트 중에 &lt;a href=&quot;https://www.graalvm.org/&quot;&gt;GraalVM&lt;/a&gt; 외에 &lt;a href=&quot;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&quot;&gt;Project Loom&lt;/a&gt;이 추가되었다. 이유는 이 프로젝트의 목표가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fiber_(computer_science)&quot;&gt;Fiber&lt;/a&gt;를 구현하는 것인데, 이를 위해서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;Continuation&lt;/a&gt;을 구현해야 하기 때문이다. 결국 자바에 Continuation이 추가되는 것이 되는데&amp;#8230;&amp;#8203; 오&amp;#8230;&amp;#8203;마이&amp;#8230;&amp;#8203;갓. 과연 이보다 Java를 프로그래밍 언어로서 강력하게 만들어주는 것이 있을까? 뭐 사람마다 견해의 차이가 있겠지만 나는 Continuation을 절대 반지로 본다. 왜냐하면 Continuation은 그동안 컴파일러 작성자들 사이에서 제어 구문을 만들 때 사용되던 프로그래밍 기법이었는데, 이것을 프로그래머들이 사용할 수 있게 되면 프로그래머들은 그 언어가 제공하는 제어 구문(if나 for 등)의 제약에서 벗어나서 자신의 필요에 맞는 제어구조를 스스로 만들어 낼 수 있게 되기 때문이다. 쉽게 말하자면, 좀 억지 비유이긴 하지만 Continuation은 &lt;a href=&quot;http://wiki.c2.com/?ContinuationsAreGotos&quot;&gt;세련된 GOTO&lt;/a&gt;라고 할 수 있다. 좀 더 구체적인 억지 비유라면 파라미터와 스택이 달린 GOTO라고 할까? 확실히 데익스트라의 &lt;a href=&quot;https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf&quot;&gt;해로운 GOTO&lt;/a&gt;와는 다르지만, GOTO 만큼 제어를 마음대로 옮겨다니게 만들 수 있는데(함수 중간에 다른 함수의 중간으로 점프했다가 다시 돌아온다든지, map으로 컬렉션을 이터레이션을 하다가 특정 조건의 요소(element)에서 중단하게 한다든지) 게다가 그게 세련된 방식이라는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 Continuation에 대한 본격적인 소개는 다음으로 미루기로 하고, 이글에서는 Project Loom의 목표인 Fiber와 그와 관련되는 수준에서의 Continuation에 대해 설명하고자 한다. 자바에서의 Fiber의 도입은 그 자체만으로도 프로그래밍 관점에서 매우 특기할 만한 일이이서 하나의 주제로 다루어지기에 충분히 가치가 있기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_왜_fiber인가&quot;&gt;왜 Fiber인가?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 자바의 Fiber 도입은 좀 늦은 감이 있다. 다른 언어들은 이미 Fiber 혹은 그와 비슷한 것들을 갖고 있다. C++은 Boost.Fiber 라이브러리를, Ruby는 Fiber 클래스를 공식적으로 지원하고 있다. Fiber는 아니지만, Fiber와 비슷한 것으로 Python은 Greenlet, Go는 goroutine, C#과 Javascript는 Async/Await를 지원하고 있으며, 이를 통해 Fiber로 해결할 문제를 나름의 방식으로 해결하고 있는 상황이다. 아니 Erlang의 Actor까지와 비교를 한다면 많이 늦었다고 해야 할지도 모르겠다. 자, 그렇다면 이건 하나의 경향이 있다고 볼 수 있지 않을까? 즉, 앞에서도 언급했듯이 현재 대부분의 주류 언어들이 Fiber 혹은 그 비슷한 것의 도입으로 풀려고 하는 그 어떤 고약한 문제들이 우리 프로그래밍 세계에서 지속적으로 발생하고 있고, 자바 역시 바로 그 고약한 문제를 풀기 위해 Fiber를 도입하려는 그런 경향 말이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자 그럼, 그 고약한 문제는 과연 무엇일까?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_동시성_프로그래밍의_변화_중량_스레드에서_경량_스레드로&quot;&gt;동시성 프로그래밍의 변화 : 중량 스레드에서 경량 스레드로&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;동시성 프로그래밍은 어렵다. 하지만 동시성 프로그래밍은 멀티코어 시대와 클라우드의 시대에 더욱 중요해지고 있다. 점점 증가하는 동시성 프로그래밍의 요구사항을 충족시키는 데 있어 동시성 프로그래밍의 복잡성은 프로그래머들에게 최대의 적으로 부각되었다. 뭐 여기까지는 다들 아시는 내용이리라 짐작한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 프로그래머들은 동시성 프로그래밍을 할 때 보통 운영체제에서 제공하는 스레드를 사용한다. 운영체제에서 제공하기 때문에 특히 커널 스레드라고 부른다. 그런데 문제는 이 커널 스레드가 상당히 무겁다는 것이다. 해서 중량 스레드라고 부르기도 한다. 동시성 프로그래밍이 복잡한 이유는 바로 이 커널 스레드가 중량 스레드이기 때문인데, 위에서 언급한 그 고약한 문제란 이 중량 스레드가 야기하는 문제이다. 즉 멀티코어와 클라우드의 시대에 중량 스레드가 야기하는 문제는 매우 심각했고, 결국 이를 해결하기 위해 나온 것이 Fiber, Greenlet, goroutine, Actor(혹은 재발견?) 등이었다. (이들은 중량 스레드와 비교해서 가벼워서 경량 스레드라고 부른다)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_중량_스레드의_문제점&quot;&gt;중량 스레드의 문제점&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;스레드, 즉 중량 스레드의 문제는 그 이름이 말해주듯이, 그것이 어플리케이션에서 사용하기에는 지나치게 무겁다는 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;무겁다는 표현은 3가지 의미가 있는데, 이것이 중량 스레드의 특성이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;리소스 부하가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동시성 작업 단위가 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선점형 스케줄러&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하나씩 순서대로 좀 더 자세히 알아보자.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫째로 스레드는 리소스를 많이 차지하는데, 그래서 서버당 수천 개 정도만 생성할 수 있다. 반면 소켓은 수백만 개 생성할 수 있다. 이는 거의 몇 승수(order of magnitude)라는 매우 심각한 차이다. 실제로 웹서버는 하나의 스레드가 하나의 Request를 처리하기 때문에 동시에 처리할 수 있는 Request는 스레드 생성 개수에 제한받아서 수 천 개 정도이다. 또한 스레드 간 문맥 전환에 드는 비용도 만만치 않다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;둘째는, 사실 이는 첫째 때문에 생기는 것인데, 스레드가 리소스를 많이 차지하기(또 관리가 어렵기) 때문에, 작은 단위의 작업을 처리하기 위해 가볍게 쓰고 버리는 식으로 쓰기보다는, 큰 단위의 작업을 처리하고 Pooling 한 후 재사용하는 식으로 이용하게 된다는 것이다. 하지만 어플리케이션은 그 특성에 따라 동시성의 작업 단위가 각각 다르다. 비디오 레코딩 프로그램과 웹서버의 동시성 요구 사항의 수준이 같을 수 없다. 또한 어플리케이션 수준에서는 작은 단위의 동시성 작업이 많다. 유저 단위 작업, 트랜잭션 단위 작업, 심지어 단일 연산 작업이라도 동시성 처리가 필요한 경우가 많지만, 이때마다 스레드 만들어 처리하기에는 너무 비용이 크기 때문에, 꼭 필요한 경우를 제외하고는 대부분 세션같이 큰 단위의 작업에 스레드를 사용한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;셋째는, 정말 이것이야말로 개인적으로는 가장 치명적 요소라고 보는데, 스레드, 그러니까 OS가 제공하는 커널 스레드는 선점형 스케줄러에 의해 처리된다는 사실이다. 선점형이라는 말은 한 스레드에서 다른 스레드로 제어(CPU 할당)가 넘어가는 문맥전환(Context Switch)이 전적으로 OS 담당이라는 의미이다. 이로 인해, 어플리케이션 수준에서 작업하는 프로그래머는 스레드에 맡긴 작업이 어느 순간에 중단될지를 알 수가 없다. 더욱이 그 중단되는 분절이 프로그래머가 작성한 코드 레벨이 아니라 컴파일된 코드(바이트 코드나 기계어 코드) 레벨이기 때문에, 프로그래머에게는 비가시성 영역에서의 중단이라는 점에서, 프로그래머는 전혀 예측할 수 없는 암흑 상태에 빠지게 된다. 이 암흑 상태는 더욱 심각한 문제를 야기하는데, 이런 암흑 상태에서 실행되는 작업이 처리하는 데이터들이 엉망이 될 수 있다는 사실이다. 마치 컴컴한 한밤중에 여러 대의 드론을 운전하면서 골목길을 통과하고 피자를 배달하는 것과 마찬가지 상황이 되는 것이다. 그래서 드론들이 주변과 충돌하지 않도록 골목길에 칠 가드레일과 교차로에서 서로 충돌하지 않도록 하는(데드락) 신호등이 필요하게 되는데, 그게 바로 멀티 스레드 프로그래밍 시에 반드시 사용하게 되는 세마포어, 뮤텍스, 아톰, 크리티컬 섹션이다. 하지만 이들로 인해 바로 그만큼 멀티 스레드 프로그래밍의 복잡성을 더욱 증폭된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 스레드(커널 스레드)는 모든 어플리케이션의 동시성 요구에 맞추기 위한 일반 목적으로 만들어진 것이다. 즉 스레드는 가장 최악의 경우에도 대처할 수 있도록 만들어야 했는데, 예를 들어 하나의 스레드가 엄청난 계산으로 CPU를 독점하고 있는 상황에 대처할 필요가 있었다.  그러나 개개의 어플리케이션들은 각자 자신만의 특수한 동시성 수준이 갖고 있을 뿐이다. 프로그래머들은 자신이 만들고 있는 어플리케이션이 요구하는 동시성 수준에 대해 잘 알고 있으며, 사실 그 특수한(일반적이지 않은) 요구사항의 수준에 맞는 정도의 동시성 작업 자체만 할 수 있다면 매우 간단하게 해결할 수 있다. 프로그래머들은 결코 스레드와 같은 일반성 수준의 동시성 작업을 만나지 않는다. 웹 어플리케이션을 만들면서 동시에 비디오 레코딩의 동시성에 대해 고민하지 않는다. 그런데 스레드는 개개의 어플리케이션의 특수한 동시성을 해결하기에는 너무 일반적인 도구이며, 위의 3가지 이유로 인해서 매우 불편한 도구인 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_해결사_경량_스레드&quot;&gt;해결사 경량 스레드&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;해결책의 방향은 이것이다. 만일 프로그래머들이 해당 어플리케이션의 요구사항에 대응하는 동시성 수준의 특수성에 대해 잘 알고 있다면, 더 이상 커널이 강제한 일반적인 방식이 아닌, 해당 어플리케이션의 동시성 수준의 방식으로 스스로 동시성 작업을 관리할 수 있도록 자유를 주는 것이다. (한마디로 동시성 프로그래밍에 있어서 커널 독재 시대에서 어플리케이션의 자유 시대로 바뀌는 것인데, 이를 위해 때론 Callback이나 Promise 그리고 심지어 Monad까지 동원되는 다양한 시도들이 있었지만, 근본적인 변화를 위해서는 일급시민(First Class)이 된 Continuation이 필요했다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그래서 위에서 언급한 중량 스레드의 특성과는 반대되는 특성이 가진 경량 스레드가 주목받게 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;경량 스레드는 다음과 같은 특성이 있다:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;리소스 부하가 매우 적다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작은 수준의 동시성 작업 단위 처리가 매우 수월하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;유저 레벨 스케줄링.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자바는 경량 스레드 중에서 Fiber를 채택하게 되었다. 사실 Fiber와 Continuation이라면 다른 경량 스레드를 다 만들어낼 수 있다. 보다 근본적이기 때문이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_project_loom의_fiber&quot;&gt;Project Loom의 Fiber&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 언급한 바로 이러한 이유로 해서 자바에도 경량 스레드의 필요성이 오래전부터 대두되었다. 그래서 자바에서 경량 스레드를 도입하려는 프레임웍들이 나오게 되었는데, &lt;a href=&quot;https://vertx.io/&quot;&gt;Vert.x&lt;/a&gt;, &lt;a href=&quot;https://akka.io/&quot;&gt;akka&lt;/a&gt;, &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;, &lt;a href=&quot;http://docs.paralleluniverse.co/quasar/&quot;&gt;Quasar&lt;/a&gt; 등이 그것이다. 특히 개인적으로는 &lt;a href=&quot;https://github.com/oltolm/continuations&quot;&gt;Matthias Man의 Continuation&lt;/a&gt;으로 Fiber를 구현한 Quasar와 그의 Clojure 랩퍼인 &lt;a href=&quot;http://docs.paralleluniverse.co/pulsar/&quot;&gt;Pulsar&lt;/a&gt;에 관심을 두고 있었는데, Quasar 개발자인 Ron Pressler가 바로 Project Loom을 &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/discuss/2017-September/004390.html&quot;&gt;제안&lt;/a&gt;했고 &lt;a href=&quot;http://openjdk.java.net/census#rpressler&quot;&gt;프로젝트 리더&lt;/a&gt;로 활동하고 있음을 알게 되었다(Quasar의 개발이 왜 뜸한가 했더니 그가 Project Loom 활동하느라 바빠서 그랬던 모양이다). 즉 드디어 Java 언어 차원에서 경량 스레드가 본격 지원되게 된 것이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;자바에 경량 스레드를 도입하려는 목적으로 출발한 Project Loom이 구현하는 Fiber를 구현한다. &lt;a href=&quot;http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html&quot;&gt;제안서&lt;/a&gt;에 따르면 대략 다음과 같은 기능을 갖게 될 것이라고 한다:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매우 적은 리소스만 갖는다.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;수백 바이트 정도.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스위칭 오버헤드는 거의 제로 수준.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하나의 JVM에서 수백만 개 생성 및 원활한 동작 가능.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronous, blocking 콜 가능.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;성능때문에 비동기 코드 작성 필요 없음. (node의 콜백헬이 없다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동시성 프로그래밍이 단순해지며, 또한 손쉽게 규모 확장이 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fiber의 API들은 Thread 클래스와 거의 비슷.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다만, Fiber를 중단/재시작하는 park/unpark 관련 메소드가 추가됨.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unpark 메소드는 인수로 스케줄러를 받을 수 있어서 fiber의 스케줄링을 바꿀 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thread와 공통되는 부분은 부모 클래스 Strand로 추출.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serializable&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fiber는 스토리지 저장 및 네트웍을 통한 전송이 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 통해 데이터가 있는 곳에서 실행되는 함수(&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_as_a_service&quot;&gt;Function As Service&lt;/a&gt;)가 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Financial Transaction이나 실행 블록체인.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Continuation&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fiber = Continuation + Scheduler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scheduler는 훌륭하게 구현된 기존의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html&quot;&gt;ForkJoinPool&lt;/a&gt;을 그대로 사용&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Continuation(정확히는 Delimited Continuation)의 구현이 서브 과제&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel, actor, dataflow 등을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UAI(Unwind And Invoke)&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tail call&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Project Loom의 목표는 기존 자바 코드의 수정 없이, 혹은 최소한의 변경만으로 사용 가능하게 하는 것이라고 한다. 하지만 JNI를 통한 native 코드는 Fiber에서 실행되지 못한다. 또한 기존 자바 API 중 java.io 는 Native blocking 코드는 Fiber 용으로 다시 변경되어야 하며, java.util.concurrent 도 커널 스레드 동기 때문에 역시 변경이 될 것이라고 한다. 기타 자바 디버거나 프로파일러 등도 Fiber에 맞게 수정이 필요하다고 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Thu, 27 Sep 2018 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</guid>
<link>
http://guruma.github.io/posts/2017-09-20-ClojureScript-Macro/
</link>
<title>
클로저스트립트에서 매크로 작성시 주의점
</title>
<description>
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_컴파일러는_크로스_컴파일러다&quot;&gt;클로저스크립트 컴파일러는 크로스 컴파일러다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트(ClojureScript) 컴파일러는 클로저스크립트 코드를 컴파일하여 브라우저나 Node.js에서 실행할 자바스크립트 코드를 만듭니다. 하지만 클로저스크립트 컴파일러 자체는 JVM상에서 실행되는 자바 프로그램이며, cljs.jar 파일로 배포됩니다. 즉 클로저스크립트 컴파일러는 컴파일러가 실행되는 환경은 JVM인데, 컴파일러의 실행 결과인 목적 코드가 실행되는 환경은 JS VM(브라우져나 Node.js처럼 자바스크립트를 실행시키는 VM)인 것입니다. 이처럼 컴파일러가 실행되는 환경과 그 컴파일러의 목적 코드가 실행되는 환경이 다른 컴파일러를 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC&quot;&gt;크로스 컴파일러&lt;/a&gt;(Cross Compiler)라고 합니다. 클로저스크립트 컴파일러는 크로스 컴파일러인 셈이죠. 이 때문에 발생하는 문제들이 있는데, 이 글에서는 특히 매크로와 관련된 문제들을 살펴보겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트_매크로는_클로저_코드이다&quot;&gt;클로저스크립트 매크로는 클로저 코드이다&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;모든 리습 언어의 매크로가 그렇듯이 클로저스크립트의 매크로도 컴파일시에 확장이 됩니다. 매크로는 컴파일러 시에 수행되는 일종의 함수입니다. 즉 매크로는 코드를 입력받아 코드를 리턴하는, 사용자가 작성하고, 사용자가 사용하지만, 그 호출은 컴파일러에 의해 수행되는 함수입니다. 컴파일러는 매크로 호출을 만나면 입력받은 코드를 인수로 해서, 정의된 매크로(함수)를 수행하고, 그 수행 결과로 나온 코드를 원래의 매크로 호출 코드와 교체합니다. 이처럼 매크로 호출 코드를 매크로 출력 코드로 바꾸는 것을 매크로 확장이라고 합니다. 그런데 이 매크로 확장이 컴파일시에 되어야 하기 때문에 클로저스크립트의 매크로 확장은 목적 코드의 실행 환경인 JS VM이 아닌 컴파일러의 실행 환경인 JVM 상에서 이루어집니다. 그래서 클로저스크립트의 매크로는 JVM 상에서 실행될 수 있는 클로저 코드로 작성되어야 합니다. 이러한 이유로 클로저스크립트 매크로는 클로저스크립트 파일(.cljs)이 아닌 클로저 파일(.clj)로 작성됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;크로스 컴파일러라는 클로저스크립트 컴파일러의 이러한 특성으로 인해 일반 코드와 매크로 코드가 분리되어서 작성되어야 한다는 것은 사실 조금 번거롭기는 하지만 그리 큰 문제는 아닙니다. 어짜피 매크로 코드는 다른 게 아니라 우리가 많이 익숙한 클로저 코드니까요. 문제는 매크로 도우미(Helper) 함수들입니다. 특히 .cljc 파일이 도입되면서는 숙련된 클로저 프로그래머조차 이와 관련해서 가끔 실수하기도 합니다. 사실 이러한 점은 원리를 알면 당연한 것이 되어서 쉽게 피할 수 있는 문제이기 때문에 이 글에서 차근차근 알아보도록 하겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
이 글에서는 컴파일러의 특성을 알아보는 것이 목적이므로 Leiningen보다는  clojure.jar와 cljs.jar를 통해서 Clojure와 ClojureScript 컴파일러를 직접 사용합니다.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저의_매크로_작성_방식&quot;&gt;클로저의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 클로저(Clojure)에서는 다음과 같이 매크로를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defmacro log [x]
  `(println &quot;[log: ]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer [log]]))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro.clj에서 &lt;code&gt;log&lt;/code&gt; 매크로를 정의합니다. 간단하게 로그를 프린트하는 형식(form)을 리턴합니다. 그리고 core.clj에서 macro.clj를 로드(&lt;code&gt;:require&lt;/code&gt;)하고 &lt;code&gt;log&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; 를 프린트합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;코드를 실행하기 위해 다음과 같이 test 폴더 아래에 macro.clj와 core.clj를 만들고, 위의 소스와 같은 내용으로 각각 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ mkdir test; cd test
$ touch macro.clj core.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 clojure.jar를 다운로드합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ curl -o clojure.jar http://central.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음 명령으로 직접 소스를 컴파일하고 실행해 봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log: ] hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;java&lt;/code&gt; 를 실행하면서 클래스패스로 clojure.jar 와 현재 디렉토리(' &lt;code&gt;.&lt;/code&gt; ')를 주었습니다. clojure.main 함수를 실행하면서 core.clj 을 인자로 넘겼습니다. core.clj 파일이 컴파일되고 실행되어 명령창에 로그가 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;여기서 눈여겨 볼 것은 사실 당연한 것이지만 clojure.jar의 컴파일러도 JVM에서 실행되었고, 컴파일된 core.clj도 같은 JVM 상에서 실행되고 있다는 사실입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_매크로_도우미_함수&quot;&gt;매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;보통 매크로를 작성하다 보면 매크로에서 자체적으로 사용하는 도우미(Helper) 함수들을 만들어 사용하게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 작성한 &lt;code&gt;log&lt;/code&gt; 매크로에 로그의 시각을 프린트하는 기능을 넣기 위해 &lt;code&gt;now&lt;/code&gt; 도우미 함수를 추가합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro.clj 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now [] ; &amp;lt;== 도우미 함수
  (System/currentTimeMillis))

(defmacro log [x]
  `(println &quot;[log:&quot; (now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위에서 했던 것과 같이 컴파일하고 실행해보고 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.clj
[log: 1504281655322 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;로그에 시각이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;now&lt;/code&gt; 함수는 정확하게 &lt;code&gt;log&lt;/code&gt; 매크로가 실행되는 런타임에 실행되어 해당 시각을 나타내주고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_클로저스크립트의_매크로_작성_방식&quot;&gt;클로저스크립트의 매크로 작성 방식&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저스크립트에서 매크로 작성하는 방식도 클로저와 비슷합니다. 일단 매크로는 .cljs가 아닌 .clj파일에서 정의되어야 한다는 점에서.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그렇다면 위에서 작성한 매크로는 .clj로 작성했으니 당연히 ClojureScript에서도 사용할 수 있겠죠?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljs 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript에서는 매크로 파일(.clj)을 로딩하기 위해서는 &lt;code&gt;:require-macros&lt;/code&gt; 를 사용합니다. &lt;code&gt;:enable-console-print!&lt;/code&gt; 는 &lt;code&gt;:println&lt;/code&gt; 함수가 JS-VM상의 console에 프린트할 수 있도록 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljs 파일을 만들고, 위의 소스와 같은 내용으로 코드를 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ touch core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트_코드_컴파일하기&quot;&gt;클로저스크립트 코드 컴파일하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ClojureScript 파일을 컴파일하기 위해서는 컴파일러의 build-api를 사용해야 합니다. 다음은 build-api를 사용하는 build.clj 파일입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(require 'cljs.build.api)

(cljs.build.api/build &quot;.&quot;
  {:main 'core
   :output-to &quot;out/main.js&quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;cljs.build.api&lt;/code&gt; 를 로딩하고, &lt;code&gt;build&lt;/code&gt; 함수를 사용합니다. &lt;code&gt;build&lt;/code&gt; 함수는 2개의 인자를 받습니다. 첫번째 인자는 컴파일할 소스 디렉토리이고, 두 번째 인자는 컴파일러 옵션입니다. 옵션은 출력 파일을 가리키는 &lt;code&gt;:output-to&lt;/code&gt; 와 주 이름 공간을 가리키는 &lt;code&gt;:main&lt;/code&gt; 만 주어졌습니다. &lt;code&gt;:output-to&lt;/code&gt; 는 컴파일한 결과인 JS 코드를 out/main.js 출력 파일에 쓰라는 설정입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 다운로드받습니다. 이 파일은 클로저스크립트를 컴파일하기 위한 build-api를 담고 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ curl -LOk https://github.com/clojure/clojurescript/releases/download/r1.9.908/cljs.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 cljs.jar를 이용하여 build.clj를 실행시켜 core.cljs를 컴파일합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
WARNING: core is a single segment namespace at line 1 ./core.cljs
WARNING: Use of undeclared Var macro/now at line 6 ./core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;클로저 컴파일러를 실행하던 것과 다른 것은 클패스 패스에 clojure.jar 대신 cljs.jar를 주고, 컴파일을 구동하기 위해 build.clj 파일을 주었다는 것입니다. 그리고 컴파일만 한다는 것입니다. 실행할 플랫폼은 JVM이 아니라 JS-VM입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스크립트의_매크로_도우미_함수&quot;&gt;클로저스크립트의 매크로 도우미 함수&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 경고가 2개 나옵니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫번째 경고는 core.cljs의 이름 공간이 단일 이름 공간이라는 경고입니다. 예제 자체를 최대한 단순하게 하려고 일부러 단일 이름 공간을 사용한 것이니 현재로서는 무시해도 상관없습니다. (이후로 이 글에서는 이 경고는 표시하지 않겠습니다. 여러분들이 콘솔창에서 테스트할 때는 이 경고는 계속 보일 것이지만 그냥 무시하셔도 됩니다)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;두번째 경고는 &lt;code&gt;macro/now&lt;/code&gt; 가 선언되어 있지 않다는 경고입니다. 당연합니다. &lt;code&gt;macro/now&lt;/code&gt; 함수는 .clj에서 정의된 함수이므로 JVM상에서 실행되어야 하는 클로저 코드입니다. 하지만 현재 macro.clj에서 &lt;code&gt;now&lt;/code&gt; 는 &lt;code&gt;log&lt;/code&gt; 매크로 확장시가 아니라 리턴값으로 반환하는 결과 코드에서 사용되고 있습니다. 그리고 이 결과 코드는 JS-VM에서 실행되는 자바스크립트 코드여야 합니다. 하지만 클로저스크립트 컴파일러는 클로저스크립트 코드로 정의된 &lt;code&gt;now&lt;/code&gt; 함수를 찾을 수가 없습니다. 정의된 적이 없으니까요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;해결책은 2가지입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;첫번째 방법은 클로저 코드 &lt;code&gt;now&lt;/code&gt; 함수를 매크로 확장 시에 호출되도록 하는 것이고, 두 번째 방법은 &lt;code&gt;now&lt;/code&gt; 함수를 클로저스크립트 코드로 정의해서 사용하는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;우선 첫 번째 방법을 해보겠습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 macro.clj 파일을 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (System/currentTimeMillis))

(defmacro log [x]
  (let [t# (now)] ; &amp;lt;== now는 매크로 확장시에 호출된다.
  `(println &quot;[log:&quot; ~t# &quot;]&quot; ~x)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;위 예제에서는 &lt;code&gt;now&lt;/code&gt; 함수가 매크로 안에서 직접 호출되고, 그 결과값을 매크로의 결과에 포함합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다시 컴파일하면 정상적으로 성공합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ ls -al
total 57184
drwxr-xr-x  10 guruma  staff       340  9  2 02:25 .
drwxr-xr-x   6 guruma  staff       204  9  2 00:37 ..
-rw-r--r--   1 guruma  staff        99  9  2 01:43 build.clj
-rw-r--r--@  1 guruma  staff  25629199  9  2 01:24 cljs.jar
-rw-r--r--   1 guruma  staff   3622815  9  2 00:36 clojure.jar
-rw-r--r--   1 guruma  staff        86  9  2 00:46 core.clj
-rw-r--r--   1 guruma  staff        98  9  2 01:37 core.cljs
-rw-r--r--   1 guruma  staff       137  9  2 02:25 macro.clj
drwxr-xr-x  11 guruma  staff       374  9  2 02:25 out&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;out 폴더가 생성되는 것을 확인할 수 있습니다. out 폴더에 main.js 파일이 생성되는데, 이 파일이 컴파일된 결과 파일입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_클로저스립트립트_코드_실행하기&quot;&gt;클로저스립트립트 코드 실행하기&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;main.js를 브라우저에서 실행해 보기 위해 index.html 파일을 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
         &amp;lt;script type=&quot;text/javascript&quot; src=&quot;out/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 index.html 파일을 브라우저로 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창을 열어 확인해 보면 로그가 다음과 같이 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1504286749399 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;혹시 코드를 수정하게 되었는데, 수정한 코드가 브라우저에서 제대로 동작하지 않을 시에는 out 폴더를 삭제하신 후 다시 컴파일해 주세요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ rm -rf out
$ java -cp cljs.jar:. clojure.main build.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_공통_도우미_함수&quot;&gt;공통 도우미 함수&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 여기에 문제가 있습니다. &lt;code&gt;now&lt;/code&gt; 함수는 &lt;code&gt;log&lt;/code&gt; 매크로가 컴파일 시에 매크로 확장할 때 실행된다는 점입니다. 원래 의도는 &lt;code&gt;log&lt;/code&gt; 매크로를 사용하는 코드가 런타임 시에 실행될 때 &lt;code&gt;now&lt;/code&gt; 함수가 실행되어야 합니다. 이것이 사실 위에서 두 번째 해결책이었는데, 더 알맞는 것이었던 거죠.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이를 위해서는 &lt;code&gt;now&lt;/code&gt; 함수는 .clj가 아닌 .cljs 파일에서 클로저스크립트 함수로 정의되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 코드가 수정되어야 합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;util.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns util)

(defn now []
  (str &quot;js:&quot; (js/Date.now)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.clj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  (System/currentTimeMillis))

(defmacro log [x]
  `(println &quot;[log:&quot; (util/now) &quot;]&quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [util :refer [now]])
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;새로운 파일 util.cljs를 만들어 클로저스크립트 코드로 &lt;code&gt;now&lt;/code&gt; 함수를 정의하였습니다. 현재 시각을 가져오기 위해서 이번엔 자바스크립트의 &lt;code&gt;Date&lt;/code&gt; 오브젝트를 이용했습니다. 자바 코드인 &lt;code&gt;(System/currentTimeMillis)&lt;/code&gt; 사용할 수 없기 때문입니다. 또한 콘솔 출력 시에 macro.clj의 &lt;code&gt;now&lt;/code&gt; 함수와 구분할 수 있도록 &lt;code&gt;&quot;js:&quot;&lt;/code&gt; 문자열을 앞에 덧붙였습니다. &lt;code&gt;log&lt;/code&gt; 매크로에서는 &lt;code&gt;(util/now)&lt;/code&gt; 형식(form)으로 수정했습니다. util 이라는 이름 공간을 지정해 주어서 매크로 확장 후 정확히 util 이름 공간의 &lt;code&gt;now&lt;/code&gt; 를 호출할 수 있도록 한 것입니다. core.cljs에서는 &lt;code&gt;:require&lt;/code&gt; 를 이용해서 util.cljs를 로딩해 줍니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 실행해봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저의 콘솔창에서 로그가 프린트되는 것을 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: js:1504286749399 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;&quot;js:&quot;&lt;/code&gt; 문자열이 나오는 것을 보고 확실히 이제 &lt;code&gt;now&lt;/code&gt; 함수가 브라우저상에서 호출되어 프린트되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_조건부_컴파일&quot;&gt;조건부 컴파일&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;일단 &lt;code&gt;now&lt;/code&gt; 함수의 실행 시간 문제는 해결되었지만, 다른 문제가 있습니다. 같은 이름과 기능을 하는 2개가 함수가 하나는 macro.clj에 다른 하나는 util.cljs 파일에 각각 따로 정의되어 있다는 문제입니다. 이렇게 되면 관리가 어려워지게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 매크로를 작성하다 보면 대부분은 공통으로 사용될 수 있지만, 일부만 플랫폼에 따라 달라져야 하는 코드들이 분명 있습니다. 극히 일부 플랫폼 의존 코드만 다르고 대부분 코드들은 같은, 매크로나 매크로 도우미 함수를 각각 서로 다른 파일에서 관리해야 한다는 것는 클로저스크립트 매크로 작성 시에 큰 문제였습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;만약 이러한 코드들을 한 파일에서 정의하고 단지 일부 플랫폼 의존 코드만 따로 지정해서 조건부로 플랫폼에 따라 해당 플랫폼 코드만 컴파일할 수 있다면 정말 좋을 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 목적을 위해 처음에는 .cljx를 사용했습니다. 이것은 라이닝언(Leiningen)이라는 빌드툴에서 사용되는 것이었는데, 플랫폼 의존 코드를 지정하면 라이닝언의 cljx 플러그인이 해당 플랫폼 코드만의 파일들로, 즉 .clj와 .cljs 파일로 나누어서 자동으로 생성해 주었습니다. 그 후 클로저스크립트 컴파일러로 이후 컴파일 과정이 이어지는 방식이었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;하지만 이것은 cljx라는 특정 도구를 사용해야 한다는 점에서 모두가 만족할 만한 해결책은 아니었습니다. 왜냐면 라이닝언 등의 해당 툴을 사용하지 못하는 경우도 있기 때문이었습니다. 결국, 조건부 컴파일은 컴파일러 자체 내에 포함되어야 했고, 실제로 Clojure 1.7과 ClojureScript 0.0-3196부터 .cljc 파일에 대해 &lt;a href=&quot;https://clojure.org/guides/reader_conditionals&quot;&gt;Reader Conditionals&lt;/a&gt;라는 기능으로 추가되었습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;__cljc와_reader_conditionals&quot;&gt;.cljc와 Reader Conditionals&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 조건부 컴파일이 가능한 매크로를 .cljc 파일에 아래와 같이 작성합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;macro.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns macro)

(defn now []
  #?(:clj (System/currentTimeMillis)
     :cljs (js/Date.now)))

(defmacro log [x]
  `(println &quot;[log:&quot; (now) &quot; &quot; ~x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 이 Reader Conditionals라는 리더 매크로입니다. 컴파일러가 .clj, .cljs, .cljc 파일을 읽어들이면 제일 먼저 여러 가지 리더 매크로의 처리를 하는데, .cljc인 경우에는 추가로 Reader Conditionals 처리가 더해집니다. 리더 매크로의 이러한 처리들로 만들어진 form들을 컴파일러가 그 이후 단계로 처리하게 되는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;#?&lt;/code&gt; 리더 매크로 안에서 &lt;code&gt;:clj&lt;/code&gt;로 지정된 형식(form)은 클로저 컴파일러가, &lt;code&gt;:cljs&lt;/code&gt;로 지정된 형식(form)은 클로저스크립트 컴파일러가 사용할 수 있도록 처리됩니다. (이외에 :clr와 :default 등도 있습니다. 이들을 플랫폼 tag라고 합니다.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 core.cljs에서 util.cljs을 로딩할 필요가 없습니다. core.cljs파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 macro.cljc를 만들고, 위의 소스 코드대로 작성합니다.
그리고 이제 기존 macro.clj과 util.cljs는 은 필요 없으니 삭제합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ touch macro.cljc
$ rm macro.clj util.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일은 성공합니다. 아무 경고도 없습니다.&lt;br&gt;
(물론 'single segment namespace' 경고는 계속 나옵니다만, 위에서 말한 것처럼 이 경고는 무시합니다.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창에서 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같은 에러가 발생합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;Uncaught ReferenceError: macro is not defined&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;에러 메시지를 보면 macro 라는 심볼이 정의되어 있지 않아서 발생한 에러입니다. 무슨 의미일까요?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일러는 &lt;code&gt;log&lt;/code&gt; 매크로를 확장한 후, 그 결과 코드인 &lt;code&gt;(println &quot;[log:&quot; (now) &quot;] &quot; &quot;hello, world&quot;)&lt;/code&gt; 를 자바스크립트 코드로 변환하게 됩니다. 이를 위해서는 일단 &lt;code&gt;println&lt;/code&gt; 과 &lt;code&gt;now&lt;/code&gt; 심볼을 resolve 해야 합니다. &lt;code&gt;println&lt;/code&gt; 은 cljs.core 이름 공간에서 찾을 수 있습니다. &lt;code&gt;now&lt;/code&gt; 는 macro 이름 공간에서 찾습니다. 그래서 &lt;code&gt;macro/now&lt;/code&gt; 함수가 됩니다.&lt;span class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_1&quot; class=&quot;footnote&quot; href=&quot;#_footnote_1&quot; title=&quot;View footnote.&quot;&gt;1&lt;/a&gt;]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;그런데 문제는 core.cljs 에서입니다. &lt;code&gt;log&lt;/code&gt; 매크로가 확장된 후 &lt;code&gt;macro/now&lt;/code&gt; 를 참조하게 되는데, core.cljs는 macro 이름 공간을 로딩한 적이 없기 때문에 &lt;code&gt;macro&lt;/code&gt; 라는 심볼 자체를 참조할 수 없게 된 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이러한 이유때문에 컴파일러가 &lt;code&gt;macro/now&lt;/code&gt; 라는 심볼이 정의되지 않았다는 에러(Uncaught ReferenceError: macro is not defined)를 내는 것입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;macro 이름 공간을 참조할 수 있도록 core.cljs를 다음과 같이 수정합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro]) ; &amp;lt;== macro 참조
  (:require-macros [macro :refer [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;:require&lt;/code&gt; 로 macro 이름 공간을 참조합니다. 이렇게 하면 macro 이름 공간에서 정의된 심볼을 참조할 수 있게 되어서 &lt;code&gt;macro/now&lt;/code&gt; 함수 호출이 가능하게 됩니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일하고 브라우저를 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창에 다음과 같이 정상적으로 로그가 나오는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1506263117138 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;사실 위의 예제는 설명을 하다 보니 좀 복잡해 진거지만,&lt;br&gt;
실제로는 아래와 같이 더 간단하게 &lt;code&gt;:refer-macros&lt;/code&gt; 를 사용합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljs&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro :refer-macros [log]]))

(enable-console-print!)

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;__cljc_파일에서_매크로를_참조할_때&quot;&gt;.cljc 파일에서 매크로를 참조할 때&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;지금까지 .clj와 .cljs 파일에서 공통으로 사용할 매크로를 .cljc 파일에 정의해서 사용하는 내용이었습니다. 반대로 .cljc 파일에서 매크로를 사용할 수도 있습니다. 당연히 .cljc 파일로 클로저와 클로저스크립트 코드를 같이 작성할 수 있으니, 매크로를 사용하는 것도 가능한 거죠.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;현재 core.clj와 core.cljs 파일이 있는데, 사실 같은 기능을 합니다. log를 찍는거죠. 다만 core.clj는 JVM상에서, core.cljs는 JS-VM상에서.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;기능이 같다면 .cljc로 다음과 같이 작성하는 것이 가능합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require #?(:clj  [macro :refer [log]]
               :cljs [macro :refer-macros [log]])))

#?(:cljs (enable-console-print!))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이제 core.clj 와 core.cljs는 필요없으니 삭제합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ rm core.clj core.cljs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;다음과 같이 core.cljc 파일을 클로저로 컴파일하고 실행해 봅니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp clojure.jar:. clojure.main core.cljc
[log: 1506263238473] hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;컴파일되는 파일인 core.cljc 의  확장자가 .clj 가 아닌 것을 눈여겨 보십시요.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;이번엔 다음과 같이 core.cljc 파일을 클로저스크립트로 컴파일하고, index.html로 브라우저를 실행합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;$ java -cp cljs.jar:. clojure.main build.clj
$ open index.html&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;브라우저 콘솔창을 열고 로그를 확인합니다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;[log: 1506266364171 ]  hello, world&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;같은 효과를 갖지만 &lt;code&gt;#?@&lt;/code&gt;(Reader Conditional Splicing)을 이용하면 &lt;code&gt;macro&lt;/code&gt; 심볼을 한 번만 사용할 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;core.cljc&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns core
  (:require [macro #?@(:clj  [:refer [log]]
                       :cljs [:refer-macros [log]])] ))

#?(:cljs (enable-console-print!))

(log &quot;hello, world&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;faaf&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;div class=&quot;footnote&quot; id=&quot;_footnote_1&quot;&gt;
&lt;a href=&quot;#_footnoteref_1&quot;&gt;1&lt;/a&gt; 지금 설명을 이렇게 하고 있지만 사실 저도 여기서 이상한 점이 있습니다. 제 생각에는 브라우저 콘솔창에서 에러가 나기 전에 컴파일할 때 경고가 나는 것이 맞지 않을까 해서입니다. 왜냐하면 core.cljs에서 :require-macros로 macro.cljc를 로딩하면 클로저 코드로 로딩할 것이므로 now 함수는 클로저 함수일 것이고, 그렇다면 매크로 확장 결과에서의 now 심볼은 클로저스크립트일 것이므로, 컴파일러는 now 심볼을 resolve 하는데 실패하여야 하기 때문입니다. 실제로 우리가 위에서 macro.clj 를 core.cljs에서 처음 로딩할 때 정확히 그랬습니다. 그런데 macro.cljc를 로딩할 때는 경고가 나지 않는 이유는 결국 클로저스크립트 컴파일러가 macro.cljc를 클로저스크립트로도 로딩했다는 이야기가 됩니다. 실제로 이런 질문을 &lt;a href=&quot;https://groups.google.com/forum/#!topic/clojurescript/Wi3xP8KVzzo&quot;&gt;클로저스크립트 구글 그룹스&lt;/a&gt;에 올렸는데 아직 답을 얻지 못하고 있네요. 답을 알게 되면 알려드리도록 하겠습니다.(혹시 답을 아시는 분이 계시다면 알려주시면 감사하겠습니다)
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>
Wed, 20 Sep 2017 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
